            'max_trade_size': 1000,
            'risk_factor': 0.1,
            'volatility_factor': 1.0,
            'correlation_threshold': 0.7,
            'rebalance_threshold': 0.05,
            'slippage_factor': 0.001,
            'commission_rate': 0.0,
            'margin_factor': 1.0,
            'leverage': 1.0,
        }
        
        if name in defaults:
            return defaults[name]
        elif name.endswith('_factor'):
            return 1.0
        elif name.endswith('_pct') or name.endswith('_percentage'):
            return 0.1
        elif name.endswith('_size') or name.endswith('_quantity'):
            return 100
        elif name.endswith('_days') or name.endswith('_period'):
            return 30
        elif name.endswith('_threshold') or name.endswith('_limit'):
            return 0.05
        else:
            # Return a reasonable default
            return 0.1
        
    @classmethod
    def from_env(cls, mode="balanced"):
        """Create a TradingConfig from environment variables.""" 
        instance = cls()
        instance.mode = mode
        instance.ALPACA_API_KEY = os.getenv("ALPACA_API_KEY", "test_key")
        instance.ALPACA_SECRET_KEY = os.getenv("ALPACA_SECRET_KEY", "test_secret")
        return instance
    
    def get_legacy_params(self):
        """Return legacy parameters for backward compatibility."""
        return {
            "mode": getattr(self, "mode", "balanced"),
            "ALPACA_API_KEY": getattr(self, "ALPACA_API_KEY", "test_key"),
            "ALPACA_SECRET_KEY": getattr(self, "ALPACA_SECRET_KEY", "test_secret"),
            "trailing_factor": self.trailing_factor,
            "kelly_fraction": self.kelly_fraction,
            "max_position_size": self.max_position_size,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "lookback_days": self.lookback_days,
            "min_signal_strength": self.min_signal_strength,
        }


def validate_env_vars():
    """Validate required environment variables."""
    missing = [var for var in REQUIRED_ENV_VARS if not os.getenv(var)]
    if missing and not TESTING:
        raise RuntimeError(f"Missing required environment variables: {', '.join(missing)}")


def _resolve_alpaca_env() -> tuple[str | None, str | None, str | None]:
    """
    Resolve Alpaca credentials from environment supporting both naming schemes.
    
    Supports both ALPACA_* and APCA_* environment variable naming conventions.
    The ALPACA_* scheme takes precedence if both are present.
    
    Returns:
        tuple: (api_key, secret_key, base_url) or None for missing values
    """
    # Try ALPACA_* first (preferred)
    api_key = os.getenv("ALPACA_API_KEY") or os.getenv("APCA_API_KEY_ID")
    secret_key = os.getenv("ALPACA_SECRET_KEY") or os.getenv("APCA_API_SECRET_KEY") 
    base_url = os.getenv("ALPACA_BASE_URL") or os.getenv("APCA_API_BASE_URL")
    
    # Set default base URL if none provided
    if not base_url:
        base_url = "https://paper-api.alpaca.markets"
    
    return api_key, secret_key, base_url


def _warn_duplicate_env_keys() -> None:
    """Warn about potentially risky duplicate environment keys."""
    risky_duplicates = [
        ("ALPACA_API_KEY", "APCA_API_KEY_ID"),
        ("ALPACA_SECRET_KEY", "APCA_API_SECRET_KEY"),
        ("ALPACA_BASE_URL", "APCA_API_BASE_URL"),
    ]
    
    for alpaca_key, apca_key in risky_duplicates:
        alpaca_val = os.getenv(alpaca_key)
        apca_val = os.getenv(apca_key)
        
        if alpaca_val and apca_val and alpaca_val != apca_val:
            logger.warning(
                "Conflicting environment variables detected: %s and %s have different values. "
                "Using %s (ALPACA_* takes precedence)",
                alpaca_key, apca_key, alpaca_key
            )


def validate_alpaca_credentials() -> None:
    """Ensure required Alpaca credentials are present (settings-driven)."""
    if TESTING:
        return
    get_settings().require_alpaca_or_raise()


def log_config(vars_list):
    """Log configuration variables."""
    for var in vars_list:
        value = os.getenv(var, "NOT_SET")
        if "KEY" in var or "SECRET" in var:
            value = "***MASKED***" if value != "NOT_SET" else value
        logger.info(f"Config: {var}={value}")


def reload_env():
    """Reload environment variables from .env file."""
    try:
        from dotenv import load_dotenv
        from pathlib import Path
        env_path = Path(".env")
        if env_path.exists():
            load_dotenv(env_path, override=True)
    except ImportError:
        pass  # dotenv not available