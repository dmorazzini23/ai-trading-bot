ai_trading/app.py:20:16: BLE001 Do not catch blind exception: `Exception`
   |
18 |         try:
19 |             from ai_trading.alpaca_api import ALPACA_AVAILABLE as sdk_ok  # type: ignore
20 |         except Exception:
   |                ^^^^^^^^^ BLE001
21 |             sdk_ok = False
22 |         try:
   |

ai_trading/app.py:30:16: BLE001 Do not catch blind exception: `Exception`
   |
28 |             key, secret, base_url = _resolve_alpaca_env()
29 |             paper = bool(base_url and ("paper" in base_url))
30 |         except Exception:
   |                ^^^^^^^^^ BLE001
31 |             trading_client, key, secret, base_url, paper = None, None, None, "", False
32 |         shadow = bool(
   |

ai_trading/broker/alpaca.py:29:1: E402 Module level import not at top of file
   |
29 | from ai_trading.exc import TRANSIENT_HTTP_EXC  # AI-AGENT-REF: Stage 2.1 centralized exc
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
30 | 
31 | _log = get_logger(__name__)
   |

ai_trading/broker/alpaca.py:226:9: PLR0911 Too many return statements (7 > 6)
    |
224 |         return positions
225 | 
226 |     def get_open_position(self, symbol: str) -> Any | None:
    |         ^^^^^^^^^^^^^^^^^ PLR0911
227 |         """Return position for ``symbol`` or None."""  # AI-AGENT-REF
228 |         # Try SDK method first
    |

ai_trading/broker/alpaca.py:259:51: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
257 |         try:
258 |             resp = session.get(f"/v2/positions/{symbol}")
259 |             if getattr(resp, "status_code", 0) == 404:
    |                                                   ^^^ PLR2004
260 |                 return None
261 |             resp.raise_for_status()
    |

ai_trading/broker/alpaca.py:268:60: PLR2004 Magic value used in comparison, consider replacing `404` with a constant variable
    |
266 |             return SimpleNamespace(symbol=sym, qty=qty, avg_entry_price=aep)
267 |         except HTTPError as e:
268 |             if getattr(e.response, "status_code", None) == 404:
    |                                                            ^^^ PLR2004
269 |                 return None
270 |             _log.warning("ALPACA_REST_ERROR", extra={"error": str(e)})
    |

ai_trading/capital_scaling.py:191:19: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
189 |     """Adjust Kelly fraction based on drawdown and volatility."""
190 |     adjustment = 1.0
191 |     if drawdown > 0.10:
    |                   ^^^^ PLR2004
192 |         adjustment *= 0.5
193 |     if volatility_spike:
    |

ai_trading/config/__init__.py:63:12: BLE001 Do not catch blind exception: `Exception`
   |
62 |         load_dotenv(override=True)
63 |     except Exception:
   |            ^^^^^^^^^ BLE001
64 |         pass
   |

ai_trading/config/__init__.py:114:20: BLE001 Do not catch blind exception: `Exception`
    |
112 |             try:
113 |                 get_settings.cache_clear()
114 |             except Exception:
    |                    ^^^^^^^^^ BLE001
115 |                 pass
116 |             _perform_env_validation()
    |

ai_trading/config/__init__.py:144:12: PLW0603 Using the global statement to update `_CONFIG_LOGGED` is discouraged
    |
142 |     MUST NOT log or print in tests.
143 |     """
144 |     global _CONFIG_LOGGED
    |            ^^^^^^^^^^^^^^ PLW0603
145 |     _CONFIG_LOGGED = True
146 |     s = get_settings()
    |

ai_trading/core/hyperparams_schema.py:141:46: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
139 |         def validate_schema_version(cls, v):
140 |             """Validate schema version format."""
141 |             if not v or len(v.split(".")) != 3:
    |                                              ^ PLR2004
142 |                 raise ValueError("schema_version must be in format 'X.Y.Z'")
143 |             return v
    |

ai_trading/core/hyperparams_schema.py:156:12: PLW0603 Using the global statement to update `_last_missing_warning` is discouraged
    |
154 |         Validated hyperparameters schema
155 |     """
156 |     global _last_missing_warning
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
157 | 
158 |     # Check if file exists
    |

ai_trading/core/hyperparams_schema.py:189:12: BLE001 Do not catch blind exception: `Exception`
    |
187 |         logger.error(f"Invalid JSON in hyperparams file {file_path}: {e}")
188 |         return HyperparametersSchema()
189 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
190 |         logger.error(f"Error loading hyperparams from {file_path}: {e}")
191 |         return HyperparametersSchema()
    |

ai_trading/core/hyperparams_schema.py:230:12: BLE001 Do not catch blind exception: `Exception`
    |
228 |         return True
229 | 
230 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
231 |         logger.error(f"Error saving hyperparams to {file_path}: {e}")
232 |         return False
    |

ai_trading/core/hyperparams_schema.py:307:20: BLE001 Do not catch blind exception: `Exception`
    |
305 |                 HyperparametersSchema(**data)
306 |                 report["valid_schema"] = True
307 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
308 |                 report["errors"].append(f"Schema validation failed: {e}")
    |

ai_trading/core/hyperparams_schema.py:312:16: BLE001 Do not catch blind exception: `Exception`
    |
310 |         except json.JSONDecodeError as e:
311 |             report["errors"].append(f"Invalid JSON: {e}")
312 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
313 |             report["errors"].append(f"File read error: {e}")
314 |     else:
    |

ai_trading/core/interfaces.py:611:12: PLW0603 Using the global statement to update `_container` is discouraged
    |
609 | def get_container() -> IDependencyContainer:
610 |     """Get or create global dependency container."""
611 |     global _container
    |            ^^^^^^^^^^ PLW0603
612 |     if _container is None:
613 |         _container = SimpleDependencyContainer()
    |

ai_trading/core/parameter_validator.py:124:16: BLE001 Do not catch blind exception: `Exception`
    |
122 |             return validation_result
123 | 
124 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
125 |             logger.error(f"Error during parameter validation: {e}")
126 |             validation_result["overall_status"] = "ERROR"
    |

ai_trading/core/parameter_validator.py:168:37: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
166 |                 if old_value != 0:
167 |                     change_pct = abs((new_value - old_value) / old_value)
168 |                     if change_pct > 0.5:  # 50% change threshold
    |                                     ^^^ PLR2004
169 |                         result["warnings"].append(
170 |                             f"Large change in {parameter_name}: {change_pct:.1%} change"
    |

ai_trading/core/parameter_validator.py:185:16: BLE001 Do not catch blind exception: `Exception`
    |
183 |             return result
184 | 
185 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
186 |             logger.error(f"Error validating parameter change for {parameter_name}: {e}")
187 |             result["status"] = "ERROR"
    |

ai_trading/core/protocols.py:8:71: F821 Undefined name `BotRuntime`
  |
7 | class AllocatorProtocol(Protocol):
8 |     def allocate(self, signals: Sequence[Mapping[str, Any]], runtime: BotRuntime) -> Mapping[str, Any]: ...
  |                                                                       ^^^^^^^^^^ F821
  |

ai_trading/data/bars.py:56:12: BLE001 Do not catch blind exception: `Exception`
   |
54 |             },
55 |         )
56 |     except Exception:
   |            ^^^^^^^^^ BLE001
57 |         pass
   |

ai_trading/data/bars.py:62:8: BLE001 Do not catch blind exception: `Exception`
   |
60 | try:
61 |     from alpaca.data.requests import StockBarsRequest  # type: ignore
62 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
63 | 
64 |     class StockBarsRequest:  # type: ignore
   |

ai_trading/data/bars.py:70:8: BLE001 Do not catch blind exception: `Exception`
   |
68 | try:
69 |     from alpaca.data.timeframe import TimeFrame, TimeFrameUnit  # type: ignore
70 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
71 | 
72 |     class TimeFrame:  # type: ignore
   |

ai_trading/data/bars.py:107:12: BLE001 Do not catch blind exception: `Exception`
    |
105 |             return df if isinstance(df, pd.DataFrame) else pd.DataFrame()
106 |         return pd.DataFrame(obj) if obj is not None else pd.DataFrame()
107 |     except Exception:
    |            ^^^^^^^^^ BLE001
108 |         return pd.DataFrame()
    |

ai_trading/data/bars.py:123:12: BLE001 Do not catch blind exception: `Exception`
    |
121 |     try:
122 |         return str(tf).lower() in ("1min", "1m", "minute", "1 minute")
123 |     except Exception:
    |            ^^^^^^^^^ BLE001
124 |         return False  # AI-AGENT-REF: broad but safe
    |

ai_trading/data/bars.py:287:12: BLE001 Do not catch blind exception: `Exception`
    |
285 |     try:
286 |         df = get_bars(symbol=symbol, timeframe="1Min", start=start_dt, end=end_dt, feed=feed)
287 |     except Exception:
    |            ^^^^^^^^^ BLE001
288 |         df = None
289 |     if df is None or not hasattr(df, "empty") or getattr(df, "empty", True):
    |

ai_trading/data/bars.py:304:9: E741 Ambiguous variable name: `l`
    |
302 |         o = mkt["open"].resample("1D").first()
303 |         h = mkt["high"].resample("1D").max()
304 |         l = mkt["low"].resample("1D").min()
    |         ^ E741
305 |         c = mkt["close"].resample("1D").last()
306 |         v = mkt.get("volume")
    |

ai_trading/data/bars.py:313:12: BLE001 Do not catch blind exception: `Exception`
    |
311 |         out = out.dropna(how="all").tz_convert("UTC")
312 |         return out
313 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
314 |         _log.warning("RESAMPLE_DAILY_FAILED", extra={"error": str(e)})
315 |         return df
    |

ai_trading/data/bars.py:350:12: BLE001 Do not catch blind exception: `Exception`
    |
348 |                 )
349 |                 return rdf
350 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
351 |         _log.warning(
352 |             "DAILY_MINUTE_RESAMPLE_FAILED", extra={"symbol": symbol, "error": str(e)}
    |

ai_trading/data/bars.py:376:15: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
374 |     df = _get_minute_bars(symbol, start_u, end_u, feed=feed_str)
375 |     rows = len(df)
376 |     if rows < 300:
    |               ^^^ PLR2004
377 |         _log.warning(
378 |             "DATA_HEALTH_MINUTE_INCOMPLETE",
    |

ai_trading/data/bars.py:394:16: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
392 |     payload = _format_fallback_payload("1Min", feed_str, start_u, end_u)
393 |     _log.info("DATA_FALLBACK_ATTEMPT", extra={"provider": "alpaca", "fallback": payload})
394 |     if rows >= 300:
    |                ^^^ PLR2004
395 |         _log.info("DATA_HEALTH: minute fallback ok", extra={"rows": rows})
396 |     return df
    |

ai_trading/data/bars.py:408:16: BLE001 Do not catch blind exception: `Exception`
    |
406 |         try:
407 |             return _ensure_df(pd.DataFrame(bars))
408 |         except Exception:
    |                ^^^^^^^^^ BLE001
409 |             return empty_bars_dataframe()
410 |     if isinstance(payload, pd.DataFrame):
    |

ai_trading/data/corp_actions.py:108:20: BLE001 Do not catch blind exception: `Exception`
    |
106 |                 self.logger.info(f"Loaded {len(self._actions)} symbols with corporate actions")
107 | 
108 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
109 |                 self.logger.error(f"Error loading corporate actions: {e}")
110 |                 self._actions = {}
    |

ai_trading/data/corp_actions.py:132:16: BLE001 Do not catch blind exception: `Exception`
    |
130 |             self.logger.debug(f"Saved corporate actions to {actions_file}")
131 | 
132 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
133 |             self.logger.error(f"Error saving corporate actions: {e}")
    |

ai_trading/data/corp_actions.py:269:12: PLW0603 Using the global statement to update `_global_registry` is discouraged
    |
267 | def get_corp_action_registry() -> CorporateActionRegistry:
268 |     """Get or create global corporate action registry."""
269 |     global _global_registry
    |            ^^^^^^^^^^^^^^^^ PLW0603
270 |     if _global_registry is None:
271 |         _global_registry = CorporateActionRegistry()
    |

ai_trading/data/labels.py:59:12: BLE001 Do not catch blind exception: `Exception`
   |
57 |         return net_returns
58 | 
59 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
60 |         logger.error(f"Error calculating fixed horizon returns: {e}")
61 |         return pd.Series(dtype=float)
   |

ai_trading/data/labels.py:202:12: BLE001 Do not catch blind exception: `Exception`
    |
200 |         return result_df
201 | 
202 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
203 |         logger.error(f"Error in triple barrier labeling: {e}")
204 |         return pd.DataFrame(columns=['t1', 'ret', 'bin'])
    |

ai_trading/data/labels.py:227:12: BLE001 Do not catch blind exception: `Exception`
    |
225 |         return vol
226 | 
227 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
228 |         logger.error(f"Error calculating daily volatility: {e}")
229 |         return pd.Series(dtype=float)
    |

ai_trading/data/market_calendar.py:35:26: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
33 |         return len(days) == 1
34 |     # Fallback: Mon–Fri
35 |     return d.weekday() < 5
   |                          ^ PLR2004
   |

ai_trading/data/market_calendar.py:81:27: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
79 |     while True:
80 |         dd = dd - timedelta(days=1)
81 |         if dd.weekday() < 5:
   |                           ^ PLR2004
82 |             return dd
   |

ai_trading/data/sanitize.py:196:30: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
195 |             prices = bars[col].dropna()
196 |             if len(prices) < 10:  # Need minimum data for outlier detection
    |                              ^^ PLR2004
197 |                 continue
    |

ai_trading/data/sanitize.py:213:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
212 |             # Z-score based outlier detection
213 |             if len(prices) > 2:
    |                              ^ PLR2004
214 |                 z_scores = np.abs((prices - prices.mean()) / prices.std())
215 |                 z_outliers = z_scores > self.config.zscore_threshold
    |

ai_trading/data/sanitize.py:247:32: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
246 |             # Percentile-based volume filter
247 |             if len(volumes) >= 20:  # Need sufficient data for percentile
    |                                ^^ PLR2004
248 |                 volume_threshold = np.percentile(volumes, self.config.min_volume_percentile)
249 |                 low_percentile_mask = volumes < volume_threshold
    |

ai_trading/data/sanitize.py:357:17: PLW2901 `for` loop variable `reason` overwritten by assignment target
    |
355 |             individual_reasons = reason_str.split(',')
356 |             for reason in individual_reasons:
357 |                 reason = reason.strip()
    |                 ^^^^^^ PLW2901
358 |                 if reason:
359 |                     reason_counts[reason] = reason_counts.get(reason, 0) + 1
    |

ai_trading/data/sanitize.py:391:35: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
389 |             limits = self.config.winsorize_limits
390 | 
391 |         if len(series.dropna()) < 10:  # Need minimum data
    |                                   ^^ PLR2004
392 |             return series
    |

ai_trading/data/sanitize.py:426:12: PLW0603 Using the global statement to update `_global_sanitizer` is discouraged
    |
424 | def get_data_sanitizer(config: SanitizationConfig | None = None) -> DataSanitizer:
425 |     """Get or create global data sanitizer instance."""
426 |     global _global_sanitizer
    |            ^^^^^^^^^^^^^^^^^ PLW0603
427 |     if _global_sanitizer is None:
428 |         _global_sanitizer = DataSanitizer(config)
    |

ai_trading/data/timeutils.py:9:1: PLW0127 Self-assignment of variable `UTC`
  |
7 | # AI-AGENT-REF: centralized time helpers
8 | NY = ZoneInfo("America/New_York")
9 | UTC = UTC
  | ^^^ PLW0127
  |

ai_trading/data/timeutils.py:70:14: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   |
68 |     if wd == 0:  # Monday -> Friday
69 |         return d - timedelta(days=3)
70 |     if wd == 6:  # Sunday -> Friday
   |              ^ PLR2004
71 |         return d - timedelta(days=2)
72 |     if wd == 5:  # Saturday -> Friday
   |

ai_trading/data/timeutils.py:72:14: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
70 |     if wd == 6:  # Sunday -> Friday
71 |         return d - timedelta(days=2)
72 |     if wd == 5:  # Saturday -> Friday
   |              ^ PLR2004
73 |         return d - timedelta(days=1)
74 |     return d - timedelta(days=1)
   |

ai_trading/data/universe.py:17:12: BLE001 Do not catch blind exception: `Exception`
   |
15 |         if p.is_file():
16 |             return str(p)
17 |     except Exception:  # pragma: no cover - defensive
   |            ^^^^^^^^^ BLE001
18 |         pass
19 |     return None
   |

ai_trading/data_fetcher.py:39:1: E402 Module level import not at top of file
   |
37 | yf = optional_import("yfinance")
38 | 
39 | from ai_trading.logging import logger  # AI-AGENT-REF: centralized logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
40 | 
41 | # ---------------------------------------------------------------------------
   |

ai_trading/data_fetcher.py:81:8: BLE001 Do not catch blind exception: `Exception`
   |
79 |         Timeout,
80 |     )
81 | except Exception:  # pragma: no cover - requests optional
   |        ^^^^^^^^^ BLE001
82 |     RequestException = Timeout = ConnectionError = HTTPError = Exception  # type: ignore
   |

ai_trading/data_fetcher.py:376:22: PLR2004 Magic value used in comparison, consider replacing `400` with a constant variable
    |
374 |             raise
375 |         payload: dict[str, Any] | list[Any] = {}
376 |         if status != 400 and text:
    |                      ^^^ PLR2004
377 |             if "json" in ctype:
378 |                 try:
    |

ai_trading/data_fetcher.py:396:22: PLR2004 Magic value used in comparison, consider replacing `400` with a constant variable
    |
394 |             data = payload
395 | 
396 |         if status == 400:
    |                      ^^^ PLR2004
397 |             raise ValueError("Invalid feed or bad request")
    |

ai_trading/data_validation.py:58:12: BLE001 Do not catch blind exception: `Exception`
   |
56 |             "minutes_stale": minutes,
57 |         }
58 |     except Exception:
   |            ^^^^^^^^^ BLE001
59 |         return {"symbol": symbol, "is_fresh": False, "minutes_stale": float("inf")}
   |

ai_trading/data_validation.py:129:16: BLE001 Do not catch blind exception: `Exception`
    |
127 |             if df is not None and not df.empty:
128 |                 return True
129 |         except Exception:
    |                ^^^^^^^^^ BLE001
130 |             continue
131 |     return False
    |

ai_trading/data_validation.py:196:12: BLE001 Do not catch blind exception: `Exception`
    |
194 |         df = pd.read_csv(p)
195 |         report["file_readable"] = True
196 |     except Exception:
    |            ^^^^^^^^^ BLE001
197 |         return report
198 |     required = {"timestamp", "symbol", "side", "entry_price", "exit_price", "quantity", "pnl"}
    |

ai_trading/data_validation.py:211:16: BLE001 Do not catch blind exception: `Exception`
    |
209 |             int(row["quantity"])
210 |             float(row["pnl"])
211 |         except Exception:
    |                ^^^^^^^^^ BLE001
212 |             corrupted.append(idx)
213 |     report["corrupted_rows"] = corrupted
    |

ai_trading/database/connection.py:59:16: BLE001 Do not catch blind exception: `Exception`
   |
57 |                 return True
58 | 
59 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
60 |             logger.error(f"Failed to connect to database: {e}")
61 |             return False
   |

ai_trading/database/connection.py:76:16: BLE001 Do not catch blind exception: `Exception`
   |
74 |                 logger.info("Database connection closed successfully")
75 | 
76 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
77 |             logger.error(f"Error disconnecting from database: {e}")
   |

ai_trading/database/connection.py:89:16: BLE001 Do not catch blind exception: `Exception`
   |
87 |             return True
88 | 
89 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
90 |             logger.error(f"Database health check failed: {e}")
91 |             return False
   |

ai_trading/database/connection.py:143:24: BLE001 Do not catch blind exception: `Exception`
    |
141 |                         self._connections.pop(session_id, None)
142 |                     logger.debug(f"Database session {session_id} closed")
143 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
144 |                     logger.error(f"Error closing session {session_id}: {e}")
    |

ai_trading/database/connection.py:238:12: PLW0603 Using the global statement to update `_db_manager` is discouraged
    |
236 | def get_database_manager() -> DatabaseManager:
237 |     """Get the global database manager instance."""
238 |     global _db_manager
    |            ^^^^^^^^^^^ PLW0603
239 |     if _db_manager is None:
240 |         _db_manager = DatabaseManager()
    |

ai_trading/database/connection.py:252:12: PLW0603 Using the global statement to update `_db_manager` is discouraged
    |
250 | def initialize_database(connection_string: str | None = None, **kwargs) -> bool:
251 |     """Initialize the global database manager."""
252 |     global _db_manager
    |            ^^^^^^^^^^^ PLW0603
253 |     try:
254 |         _db_manager = DatabaseManager(connection_string, **kwargs)
    |

ai_trading/database/connection.py:256:12: BLE001 Do not catch blind exception: `Exception`
    |
254 |         _db_manager = DatabaseManager(connection_string, **kwargs)
255 |         return _db_manager.connect()
256 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
257 |         logger.error(f"Failed to initialize database: {e}")
258 |         return False
    |

ai_trading/database/connection.py:263:12: PLW0603 Using the global statement to update `_db_manager` is discouraged
    |
261 | def shutdown_database() -> None:
262 |     """Shutdown the global database manager."""
263 |     global _db_manager
    |            ^^^^^^^^^^^ PLW0603
264 |     if _db_manager:
265 |         _db_manager.disconnect()
    |

ai_trading/database/models.py:188:20: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
    |
186 |         """Categorize risk level based on composite score."""
187 |         score = self.risk_score
188 |         if score < 25:
    |                    ^^ PLR2004
189 |             return "Low"
190 |         elif score < 50:
    |

ai_trading/database/models.py:190:22: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
188 |         if score < 25:
189 |             return "Low"
190 |         elif score < 50:
    |                      ^^ PLR2004
191 |             return "Medium"
192 |         elif score < 75:
    |

ai_trading/database/models.py:192:22: PLR2004 Magic value used in comparison, consider replacing `75` with a constant variable
    |
190 |         elif score < 50:
191 |             return "Medium"
192 |         elif score < 75:
    |                      ^^ PLR2004
193 |             return "High"
194 |         else:
    |

ai_trading/env.py:17:12: PLW0603 Using the global statement to update `_ENV_LOADED` is discouraged
   |
15 |     the source and that ``override=True`` is active.
16 |     """  # AI-AGENT-REF: .env authoritative
17 |     global _ENV_LOADED
   |            ^^^^^^^^^^^ PLW0603
18 |     os.environ.setdefault("MULTI_LOAD_TEST", "safe_value")
19 |     if _ENV_LOADED:
   |

ai_trading/env.py:49:12: BLE001 Do not catch blind exception: `Exception`
   |
47 |                 extra={"dotenv_path": loaded_from},
48 |             )
49 |     except Exception:
   |            ^^^^^^^^^ BLE001
50 |         pass
   |

ai_trading/evaluation/walkforward.py:26:12: PLW0603 Using the global statement to update `matplotlib_available` is discouraged
   |
24 | def _ensure_matplotlib() -> None:
25 |     """Lazy import matplotlib if plotting is enabled."""
26 |     global matplotlib_available, plt, mdates
   |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
27 |     if matplotlib_available:
28 |         return
   |

ai_trading/evaluation/walkforward.py:26:34: PLW0603 Using the global statement to update `plt` is discouraged
   |
24 | def _ensure_matplotlib() -> None:
25 |     """Lazy import matplotlib if plotting is enabled."""
26 |     global matplotlib_available, plt, mdates
   |                                  ^^^ PLW0603
27 |     if matplotlib_available:
28 |         return
   |

ai_trading/evaluation/walkforward.py:26:39: PLW0603 Using the global statement to update `mdates` is discouraged
   |
24 | def _ensure_matplotlib() -> None:
25 |     """Lazy import matplotlib if plotting is enabled."""
26 |     global matplotlib_available, plt, mdates
   |                                       ^^^^^^ PLW0603
27 |     if matplotlib_available:
28 |         return
   |

ai_trading/evaluation/walkforward.py:41:1: E402 Module level import not at top of file
   |
39 |         logger.debug("Matplotlib plotting disabled by configuration")
40 | 
41 | from ..data.splits import walkforward_splits
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
42 | from ..features.pipeline import create_feature_pipeline
   |

ai_trading/evaluation/walkforward.py:42:1: E402 Module level import not at top of file
   |
41 | from ..data.splits import walkforward_splits
42 | from ..features.pipeline import create_feature_pipeline
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/evaluation/walkforward.py:298:16: BLE001 Do not catch blind exception: `Exception`
    |
296 |             return fold_result
297 | 
298 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
299 |             logger.error(f"Error in fold {fold_idx}: {e}")
300 |             return {"fold": fold_idx, "error": str(e)}
    |

ai_trading/evaluation/walkforward.py:349:16: BLE001 Do not catch blind exception: `Exception`
    |
347 |             }
348 | 
349 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
350 |             logger.error(f"Error calculating fold metrics: {e}")
351 |             return {}
    |

ai_trading/evaluation/walkforward.py:430:16: BLE001 Do not catch blind exception: `Exception`
    |
428 |             return aggregate_metrics
429 | 
430 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
431 |             logger.error(f"Error calculating aggregate metrics: {e}")
432 |             return {}
    |

ai_trading/evaluation/walkforward.py:448:16: BLE001 Do not catch blind exception: `Exception`
    |
446 |             return drawdown
447 | 
448 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
449 |             logger.error(f"Error calculating drawdown: {e}")
450 |             return pd.Series(dtype=float)
    |

ai_trading/evaluation/walkforward.py:500:16: BLE001 Do not catch blind exception: `Exception`
    |
498 |             self._create_plots(timestamp)
499 | 
500 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
501 |             logger.error(f"Error saving results: {e}")
    |

ai_trading/evaluation/walkforward.py:587:16: BLE001 Do not catch blind exception: `Exception`
    |
585 |             logger.info(f"Plots saved to {plot_file}")
586 | 
587 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
588 |             logger.error(f"Error creating plots: {e}")
    |

ai_trading/execution/__init__.py:73:8: BLE001 Do not catch blind exception: `Exception`
   |
71 |         ProductionExecutionCoordinator,
72 |     )
73 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
74 |     ExecutionResult = OrderRequest = ProductionExecutionCoordinator = None  # type: ignore
   |

ai_trading/execution/algorithms.py:103:16: BLE001 Do not catch blind exception: `Exception`
    |
101 |             return child_orders
102 | 
103 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
104 |             logger.error(f"Error in VWAP execution: {e}")
105 |             return []
    |

ai_trading/execution/algorithms.py:187:16: BLE001 Do not catch blind exception: `Exception`
    |
185 |             return child_orders
186 | 
187 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
188 |             logger.error(f"Error in TWAP execution: {e}")
189 |             return []
    |

ai_trading/execution/algorithms.py:245:57: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
243 |                 # Adjust order type based on urgency
244 |                 order_type = (
245 |                     OrderType.MARKET if slice_urgency > 0.8 else OrderType.LIMIT
    |                                                         ^^^ PLR2004
246 |                 )
    |

ai_trading/execution/algorithms.py:275:16: BLE001 Do not catch blind exception: `Exception`
    |
273 |             return child_orders
274 | 
275 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
276 |             logger.error(f"Error in Implementation Shortfall execution: {e}")
277 |             return []
    |

ai_trading/execution/algorithms.py:310:16: BLE001 Do not catch blind exception: `Exception`
    |
308 |             return schedule
309 | 
310 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
311 |             logger.error(f"Error calculating execution schedule: {e}")
312 |             return [(total_quantity, self.urgency_factor)]
    |

ai_trading/execution/costs.py:172:20: BLE001 Do not catch blind exception: `Exception`
    |
170 |                 self.logger.info(f"Loaded cost data for {len(self._costs)} symbols")
171 | 
172 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
173 |                 self.logger.error(f"Failed to load cost data: {e}")
    |

ai_trading/execution/costs.py:194:16: BLE001 Do not catch blind exception: `Exception`
    |
192 |             self.logger.debug(f"Saved cost data for {len(self._costs)} symbols")
193 | 
194 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
195 |             self.logger.error(f"Failed to save cost data: {e}")
    |

ai_trading/execution/costs.py:385:28: DTZ011 `datetime.date.today()` used
    |
383 |         """
384 |         if trading_date is None:
385 |             trading_date = date.today()
    |                            ^^^^^^^^^^^^ DTZ011
386 | 
387 |         snapshot_file = self.data_path / f"{trading_date.strftime('%Y%m%d')}.parquet"
    |
    = help: Use `datetime.datetime.now(tz=...).date()` instead

ai_trading/execution/costs.py:439:39: PLR2004 Magic value used in comparison, consider replacing `50.0` with a constant variable
    |
437 |             # In a real implementation, this would check with the broker
438 |             # For now, simulate based on borrow fee
439 |             if costs.borrow_fee_bps > 50.0:  # Very high borrow fee
    |                                       ^^^^ PLR2004
440 |                 return False, "Hard to borrow - high fee"
441 |             elif costs.borrow_fee_bps > 20.0:  # High borrow fee
    |

ai_trading/execution/costs.py:441:41: PLR2004 Magic value used in comparison, consider replacing `20.0` with a constant variable
    |
439 |             if costs.borrow_fee_bps > 50.0:  # Very high borrow fee
440 |                 return False, "Hard to borrow - high fee"
441 |             elif costs.borrow_fee_bps > 20.0:  # High borrow fee
    |                                         ^^^^ PLR2004
442 |                 return True, "Available but expensive"
    |

ai_trading/execution/costs.py:557:12: PLW0603 Using the global statement to update `_global_cost_model` is discouraged
    |
555 | def get_cost_model() -> SymbolCostModel:
556 |     """Get or create global cost model instance."""
557 |     global _global_cost_model
    |            ^^^^^^^^^^^^^^^^^^ PLW0603
558 |     if _global_cost_model is None:
559 |         _global_cost_model = SymbolCostModel()
    |

ai_trading/execution/debug_tracker.py:118:16: BLE001 Do not catch blind exception: `Exception`
    |
116 |             if lock_acquired:
117 |                 self._active_orders[correlation_id] = execution_start
118 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
119 |             self.logger.error(
120 |                 "START_TRACKING_ERROR",
    |

ai_trading/execution/debug_tracker.py:197:16: BLE001 Do not catch blind exception: `Exception`
    |
195 |                         "status"
196 |                     ] = OrderStatus.CANCELLED.value
197 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
198 |             # AI-AGENT-REF: Graceful error handling for lock operations
199 |             self.logger.error(
    |

ai_trading/execution/debug_tracker.py:274:16: BLE001 Do not catch blind exception: `Exception`
    |
272 |                 # Remove from active orders
273 |                 del self._active_orders[correlation_id]
274 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
275 |             self.logger.error(
276 |                 "ORDER_RESULT_ERROR",
    |

ai_trading/execution/debug_tracker.py:405:12: PLW0603 Using the global statement to update `_debug_tracker` is discouraged
    |
403 | def get_debug_tracker() -> ExecutionDebugTracker:
404 |     """Get or create the global debug tracker instance."""
405 |     global _debug_tracker
    |            ^^^^^^^^^^^^^^ PLW0603
406 |     with _tracker_lock:
407 |         if _debug_tracker is None:
    |

ai_trading/execution/idempotency.py:163:12: PLW0603 Using the global statement to update `_global_cache` is discouraged
    |
161 | def get_idempotency_cache() -> OrderIdempotencyCache:
162 |     """Get or create global idempotency cache instance."""
163 |     global _global_cache
    |            ^^^^^^^^^^^^^ PLW0603
164 |     if _global_cache is None:
165 |         _global_cache = OrderIdempotencyCache()
    |

ai_trading/execution/liquidity.py:32:1: E402 Module level import not at top of file
   |
31 | # Use the centralized logger as per AGENTS.md
32 | from ai_trading.logging import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 | 
34 | from ..core.enums import OrderType
   |

ai_trading/execution/liquidity.py:34:1: E402 Module level import not at top of file
   |
32 | from ai_trading.logging import logger
33 | 
34 | from ..core.enums import OrderType
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/execution/liquidity.py:157:54: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
155 |         try:
156 |             volume_data = market_data.get("volume", [])
157 |             if not volume_data or len(volume_data) < 10:
    |                                                      ^^ PLR2004
158 |                 return {"error": "Insufficient volume data"}
    |

ai_trading/execution/liquidity.py:165:70: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
164 |             # Recent volume statistics
165 |             recent_volume = volume_data[-10:] if len(volume_data) >= 10 else volume_data
    |                                                                      ^^ PLR2004
166 |             avg_volume = statistics.mean(recent_volume)
167 |             volume_std = (
    |

ai_trading/execution/liquidity.py:172:36: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
171 |             # Volume trend
172 |             if len(volume_data) >= 20:
    |                                    ^^ PLR2004
173 |                 recent_avg = statistics.mean(volume_data[-10:])
174 |                 older_avg = statistics.mean(volume_data[-20:-10])
    |

ai_trading/execution/liquidity.py:216:54: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
214 |                 # Estimate spread based on price volatility if actual spread not available
215 |                 price_data = market_data.get("close", [])
216 |                 if price_data and len(price_data) >= 10:
    |                                                      ^^ PLR2004
217 |                     recent_prices = (
218 |                         price_data[-10:]
    |

ai_trading/execution/liquidity.py:261:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
260 |             # Spread quality assessment
261 |             if spread_bps < 5:
    |                             ^ PLR2004
262 |                 spread_quality = "excellent"
263 |             elif spread_bps < 15:
    |

ai_trading/execution/liquidity.py:263:31: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
261 |             if spread_bps < 5:
262 |                 spread_quality = "excellent"
263 |             elif spread_bps < 15:
    |                               ^^ PLR2004
264 |                 spread_quality = "good"
265 |             elif spread_bps < 30:
    |

ai_trading/execution/liquidity.py:265:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
263 |             elif spread_bps < 15:
264 |                 spread_quality = "good"
265 |             elif spread_bps < 30:
    |                               ^^ PLR2004
266 |                 spread_quality = "fair"
267 |             else:
    |

ai_trading/execution/liquidity.py:297:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
295 |             # Ensure same length
296 |             min_length = min(len(volume_data), len(price_data))
297 |             if min_length < 5:
    |                             ^ PLR2004
298 |                 return {"error": "Insufficient data points"}
    |

ai_trading/execution/liquidity.py:325:39: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
324 |             # 30-day average if enough data
325 |             if len(dollar_volumes) >= 20:
    |                                       ^^ PLR2004
326 |                 monthly_avg = statistics.mean(dollar_volumes[-20:])
327 |             else:
    |

ai_trading/execution/liquidity.py:357:27: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
355 |             # US market hours (assuming UTC timing needs adjustment)
356 |             # This is a simplified version - production would use proper timezone handling
357 |             if weekday >= 5:  # Weekend
    |                           ^ PLR2004
358 |                 market_session = MarketHours.AFTER_HOURS
359 |                 liquidity_impact = "very_low"
    |

ai_trading/execution/liquidity.py:360:18: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
358 |                 market_session = MarketHours.AFTER_HOURS
359 |                 liquidity_impact = "very_low"
360 |             elif 9 <= hour < 16:  # Regular market hours (simplified)
    |                  ^ PLR2004
361 |                 if hour == 9 and minute < 30:
362 |                     market_session = MarketHours.MARKET_OPEN
    |

ai_trading/execution/liquidity.py:360:30: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
    |
358 |                 market_session = MarketHours.AFTER_HOURS
359 |                 liquidity_impact = "very_low"
360 |             elif 9 <= hour < 16:  # Regular market hours (simplified)
    |                              ^^ PLR2004
361 |                 if hour == 9 and minute < 30:
362 |                     market_session = MarketHours.MARKET_OPEN
    |

ai_trading/execution/liquidity.py:361:28: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
359 |                 liquidity_impact = "very_low"
360 |             elif 9 <= hour < 16:  # Regular market hours (simplified)
361 |                 if hour == 9 and minute < 30:
    |                            ^ PLR2004
362 |                     market_session = MarketHours.MARKET_OPEN
363 |                     liquidity_impact = "high"
    |

ai_trading/execution/liquidity.py:361:43: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
359 |                 liquidity_impact = "very_low"
360 |             elif 9 <= hour < 16:  # Regular market hours (simplified)
361 |                 if hour == 9 and minute < 30:
    |                                           ^^ PLR2004
362 |                     market_session = MarketHours.MARKET_OPEN
363 |                     liquidity_impact = "high"
    |

ai_trading/execution/liquidity.py:364:30: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
362 |                     market_session = MarketHours.MARKET_OPEN
363 |                     liquidity_impact = "high"
364 |                 elif hour >= 15 and minute >= 30:
    |                              ^^ PLR2004
365 |                     market_session = MarketHours.MARKET_CLOSE
366 |                     liquidity_impact = "high"
    |

ai_trading/execution/liquidity.py:364:47: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
362 |                     market_session = MarketHours.MARKET_OPEN
363 |                     liquidity_impact = "high"
364 |                 elif hour >= 15 and minute >= 30:
    |                                               ^^ PLR2004
365 |                     market_session = MarketHours.MARKET_CLOSE
366 |                     liquidity_impact = "high"
    |

ai_trading/execution/liquidity.py:370:18: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
368 |                     market_session = MarketHours.REGULAR_HOURS
369 |                     liquidity_impact = "normal"
370 |             elif 4 <= hour < 9:
    |                  ^ PLR2004
371 |                 market_session = MarketHours.PRE_MARKET
372 |                 liquidity_impact = "low"
    |

ai_trading/execution/liquidity.py:370:30: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
368 |                     market_session = MarketHours.REGULAR_HOURS
369 |                     liquidity_impact = "normal"
370 |             elif 4 <= hour < 9:
    |                              ^ PLR2004
371 |                 market_session = MarketHours.PRE_MARKET
372 |                 liquidity_impact = "low"
    |

ai_trading/execution/liquidity.py:378:36: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
377 |             # Additional factors
378 |             is_friday = weekday == 4
    |                                    ^ PLR2004
379 |             is_monday = weekday == 0
380 |             is_option_expiry = self._is_option_expiry_week(current_time)
    |

ai_trading/execution/liquidity.py:383:38: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
382 |             # Adjust liquidity impact based on special conditions
383 |             if is_friday and hour >= 15:
    |                                      ^^ PLR2004
384 |                 liquidity_impact = "low"  # Friday afternoon
385 |             elif is_monday and hour <= 10:
    |

ai_trading/execution/liquidity.py:385:40: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
383 |             if is_friday and hour >= 15:
384 |                 liquidity_impact = "low"  # Friday afternoon
385 |             elif is_monday and hour <= 10:
    |                                        ^^ PLR2004
386 |                 liquidity_impact = "reduced"  # Monday morning
387 |             elif is_option_expiry:
    |

ai_trading/execution/liquidity.py:393:42: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
391 |                 "market_session": market_session,
392 |                 "liquidity_impact": liquidity_impact,
393 |                 "is_weekend": weekday >= 5,
    |                                          ^ PLR2004
394 |                 "is_friday": is_friday,
395 |                 "is_monday": is_monday,
    |

ai_trading/execution/liquidity.py:419:31: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
417 |             # Volume score
418 |             volume_ratio = volume_analysis.get("volume_ratio", 0)
419 |             if volume_ratio > 2.0:
    |                               ^^^ PLR2004
420 |                 volume_score = 4
421 |             elif volume_ratio > 1.5:
    |

ai_trading/execution/liquidity.py:421:33: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
419 |             if volume_ratio > 2.0:
420 |                 volume_score = 4
421 |             elif volume_ratio > 1.5:
    |                                 ^^^ PLR2004
422 |                 volume_score = 3
423 |             elif volume_ratio > 0.8:
    |

ai_trading/execution/liquidity.py:423:33: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
421 |             elif volume_ratio > 1.5:
422 |                 volume_score = 3
423 |             elif volume_ratio > 0.8:
    |                                 ^^^ PLR2004
424 |                 volume_score = 2
425 |             elif volume_ratio > 0.5:
    |

ai_trading/execution/liquidity.py:425:33: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
423 |             elif volume_ratio > 0.8:
424 |                 volume_score = 2
425 |             elif volume_ratio > 0.5:
    |                                 ^^^ PLR2004
426 |                 volume_score = 1
427 |             else:
    |

ai_trading/execution/liquidity.py:445:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
443 |             # Spread score
444 |             spread_bps = spread_analysis.get("spread_basis_points", 50)
445 |             if spread_bps < 5:
    |                             ^ PLR2004
446 |                 spread_score = 4
447 |             elif spread_bps < 15:
    |

ai_trading/execution/liquidity.py:447:31: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
445 |             if spread_bps < 5:
446 |                 spread_score = 4
447 |             elif spread_bps < 15:
    |                               ^^ PLR2004
448 |                 spread_score = 3
449 |             elif spread_bps < 30:
    |

ai_trading/execution/liquidity.py:449:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
447 |             elif spread_bps < 15:
448 |                 spread_score = 3
449 |             elif spread_bps < 30:
    |                               ^^ PLR2004
450 |                 spread_score = 2
451 |             elif spread_bps < 50:
    |

ai_trading/execution/liquidity.py:451:31: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
449 |             elif spread_bps < 30:
450 |                 spread_score = 2
451 |             elif spread_bps < 50:
    |                               ^^ PLR2004
452 |                 spread_score = 1
453 |             else:
    |

ai_trading/execution/liquidity.py:462:34: PLR2004 Magic value used in comparison, consider replacing `3.5` with a constant variable
    |
461 |             # Convert to liquidity level
462 |             if weighted_score >= 3.5:
    |                                  ^^^ PLR2004
463 |                 return LiquidityLevel.VERY_HIGH
464 |             elif weighted_score >= 2.5:
    |

ai_trading/execution/liquidity.py:464:36: PLR2004 Magic value used in comparison, consider replacing `2.5` with a constant variable
    |
462 |             if weighted_score >= 3.5:
463 |                 return LiquidityLevel.VERY_HIGH
464 |             elif weighted_score >= 2.5:
    |                                    ^^^ PLR2004
465 |                 return LiquidityLevel.HIGH
466 |             elif weighted_score >= 1.5:
    |

ai_trading/execution/liquidity.py:466:36: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
464 |             elif weighted_score >= 2.5:
465 |                 return LiquidityLevel.HIGH
466 |             elif weighted_score >= 1.5:
    |                                    ^^^ PLR2004
467 |                 return LiquidityLevel.NORMAL
468 |             elif weighted_score >= 0.5:
    |

ai_trading/execution/liquidity.py:468:36: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
466 |             elif weighted_score >= 1.5:
467 |                 return LiquidityLevel.NORMAL
468 |             elif weighted_score >= 0.5:
    |                                    ^^^ PLR2004
469 |                 return LiquidityLevel.LOW
470 |             else:
    |

ai_trading/execution/liquidity.py:594:31: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
592 |         """Classify current volume pattern."""
593 |         try:
594 |             if volume_ratio > 1.5 and volume_trend > 0.1:
    |                               ^^^ PLR2004
595 |                 return "surging"
596 |             elif volume_ratio > 1.2:
    |

ai_trading/execution/liquidity.py:594:54: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
592 |         """Classify current volume pattern."""
593 |         try:
594 |             if volume_ratio > 1.5 and volume_trend > 0.1:
    |                                                      ^^^ PLR2004
595 |                 return "surging"
596 |             elif volume_ratio > 1.2:
    |

ai_trading/execution/liquidity.py:596:33: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
    |
594 |             if volume_ratio > 1.5 and volume_trend > 0.1:
595 |                 return "surging"
596 |             elif volume_ratio > 1.2:
    |                                 ^^^ PLR2004
597 |                 return "elevated"
598 |             elif volume_ratio < 0.5 and volume_trend < -0.1:
    |

ai_trading/execution/liquidity.py:598:33: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
596 |             elif volume_ratio > 1.2:
597 |                 return "elevated"
598 |             elif volume_ratio < 0.5 and volume_trend < -0.1:
    |                                 ^^^ PLR2004
599 |                 return "declining"
600 |             elif volume_ratio < 0.8:
    |

ai_trading/execution/liquidity.py:598:56: PLR2004 Magic value used in comparison, consider replacing `-0.1` with a constant variable
    |
596 |             elif volume_ratio > 1.2:
597 |                 return "elevated"
598 |             elif volume_ratio < 0.5 and volume_trend < -0.1:
    |                                                        ^^^^ PLR2004
599 |                 return "declining"
600 |             elif volume_ratio < 0.8:
    |

ai_trading/execution/liquidity.py:600:33: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
598 |             elif volume_ratio < 0.5 and volume_trend < -0.1:
599 |                 return "declining"
600 |             elif volume_ratio < 0.8:
    |                                 ^^^ PLR2004
601 |                 return "below_average"
602 |             else:
    |

ai_trading/execution/liquidity.py:618:20: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
617 |             # Rough estimate: if it's the third week of the month
618 |             return 15 <= day <= 21
    |                    ^^ PLR2004
619 | 
620 |         except COMMON_EXC as e:
    |

ai_trading/execution/liquidity.py:618:33: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
617 |             # Rough estimate: if it's the third week of the month
618 |             return 15 <= day <= 21
    |                                 ^^ PLR2004
619 | 
620 |         except COMMON_EXC as e:
    |

ai_trading/execution/liquidity.py:645:54: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
644 |             # Keep only last 50 entries
645 |             if len(self.liquidity_history[symbol]) > 50:
    |                                                      ^^ PLR2004
646 |                 self.liquidity_history[symbol] = self.liquidity_history[symbol][-50:]
    |

ai_trading/execution/liquidity.py:658:58: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
656 |             if (
657 |                 symbol not in self.liquidity_history
658 |                 or len(self.liquidity_history[symbol]) < 2
    |                                                          ^ PLR2004
659 |             ):
660 |                 return {"error": "Insufficient history"}
    |

ai_trading/execution/liquidity.py:669:39: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
668 |             # Calculate trends
669 |             if len(dollar_volumes) >= 2:
    |                                       ^ PLR2004
670 |                 dollar_volume_trend = (
671 |                     (dollar_volumes[-1] - dollar_volumes[0]) / dollar_volumes[0]
    |

ai_trading/execution/liquidity.py:686:37: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
684 |             ]
685 | 
686 |             if len(level_values) >= 2:
    |                                     ^ PLR2004
687 |                 level_trend = level_values[-1] - level_values[0]
688 |                 if level_trend > 0:
    |

ai_trading/execution/liquidity.py:841:37: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
839 |             ) + liquidity_percentages.get("very_low", 0)
840 | 
841 |             if high_liquidity_pct > 60:
    |                                     ^^ PLR2004
842 |                 portfolio_assessment = "excellent"
843 |             elif high_liquidity_pct > 40:
    |

ai_trading/execution/liquidity.py:843:39: PLR2004 Magic value used in comparison, consider replacing `40` with a constant variable
    |
841 |             if high_liquidity_pct > 60:
842 |                 portfolio_assessment = "excellent"
843 |             elif high_liquidity_pct > 40:
    |                                       ^^ PLR2004
844 |                 portfolio_assessment = "good"
845 |             elif low_liquidity_pct < 20:
    |

ai_trading/execution/liquidity.py:845:38: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
843 |             elif high_liquidity_pct > 40:
844 |                 portfolio_assessment = "good"
845 |             elif low_liquidity_pct < 20:
    |                                      ^^ PLR2004
846 |                 portfolio_assessment = "adequate"
847 |             else:
    |

ai_trading/execution/live_trading.py:19:1: E402 Module level import not at top of file
   |
18 | # Internal config import
19 | from ai_trading.config import AlpacaConfig, get_alpaca_config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | 
21 | # Alpaca SDK imports
   |

ai_trading/execution/live_trading.py:25:8: BLE001 Do not catch blind exception: `Exception`
   |
23 |     from alpaca.common.exceptions import APIError  # type: ignore
24 |     from alpaca.trading.client import TradingClient  # type: ignore
25 | except Exception:  # AI-AGENT-REF: local fallback when SDK missing
   |        ^^^^^^^^^ BLE001
26 |     TradingClient = None  # type: ignore
   |

ai_trading/execution/live_trading.py:32:1: E402 Module level import not at top of file
   |
32 | from ai_trading.broker.alpaca import AlpacaBroker
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/execution/live_trading.py:52:36: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
50 | def submit_market_order(symbol: str, side: str, quantity: int):
51 |     symbol = str(symbol)
52 |     if not symbol or len(symbol) > 5 or not symbol.isalpha():
   |                                    ^ PLR2004
53 |         return {"status": "error", "code": "SYMBOL_INVALID", "error": symbol}
54 |     try:
   |

ai_trading/execution/live_trading.py:56:12: BLE001 Do not catch blind exception: `Exception`
   |
54 |     try:
55 |         quantity = int(_pos_num("qty", quantity))
56 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
57 |         _log.error(
58 |             "ORDER_INPUT_INVALID",
   |

ai_trading/execution/live_trading.py:139:24: BLE001 Do not catch blind exception: `Exception`
    |
137 |                         MockTradingClient,  # AI-AGENT-REF: test mock
138 |                     )
139 |                 except Exception:
    |                        ^^^^^^^^^ BLE001
140 |                     MockTradingClient = None
141 |                 if MockTradingClient:
    |

ai_trading/execution/live_trading.py:202:30: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
200 |         try:  # AI-AGENT-REF: validate submit inputs
201 |             symbol = _req_str("symbol", symbol)
202 |             if len(symbol) > 5 or not symbol.isalpha():
    |                              ^ PLR2004
203 |                 return {
204 |                     "status": "error",
    |

ai_trading/execution/live_trading.py:276:30: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
274 |         try:  # AI-AGENT-REF: validate submit inputs
275 |             symbol = _req_str("symbol", symbol)
276 |             if len(symbol) > 5 or not symbol.isalpha():
    |                              ^ PLR2004
277 |                 return {
278 |                     "status": "error",
    |

ai_trading/execution/microstructure.py:149:16: BLE001 Do not catch blind exception: `Exception`
    |
147 |             return features
148 | 
149 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
150 |             logger.error(f"Error analyzing spread features: {e}")
151 |             return {}
    |

ai_trading/execution/microstructure.py:171:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
170 |             # Classification logic
171 |             if spread_bps < 5 and market_depth > 10000 and spread_quality > 0.8:
    |                             ^ PLR2004
172 |                 return MarketRegimeFeature.HIGH_FREQUENCY
173 |             elif spread_bps > 50 or market_depth < 1000:
    |

ai_trading/execution/microstructure.py:171:50: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
170 |             # Classification logic
171 |             if spread_bps < 5 and market_depth > 10000 and spread_quality > 0.8:
    |                                                  ^^^^^ PLR2004
172 |                 return MarketRegimeFeature.HIGH_FREQUENCY
173 |             elif spread_bps > 50 or market_depth < 1000:
    |

ai_trading/execution/microstructure.py:171:77: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
170 |             # Classification logic
171 |             if spread_bps < 5 and market_depth > 10000 and spread_quality > 0.8:
    |                                                                             ^^^ PLR2004
172 |                 return MarketRegimeFeature.HIGH_FREQUENCY
173 |             elif spread_bps > 50 or market_depth < 1000:
    |

ai_trading/execution/microstructure.py:173:31: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
171 |             if spread_bps < 5 and market_depth > 10000 and spread_quality > 0.8:
172 |                 return MarketRegimeFeature.HIGH_FREQUENCY
173 |             elif spread_bps > 50 or market_depth < 1000:
    |                               ^^ PLR2004
174 |                 return MarketRegimeFeature.ILLIQUID
175 |             elif spread_bps > 20 and spread_quality < 0.4:
    |

ai_trading/execution/microstructure.py:173:52: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
171 |             if spread_bps < 5 and market_depth > 10000 and spread_quality > 0.8:
172 |                 return MarketRegimeFeature.HIGH_FREQUENCY
173 |             elif spread_bps > 50 or market_depth < 1000:
    |                                                    ^^^^ PLR2004
174 |                 return MarketRegimeFeature.ILLIQUID
175 |             elif spread_bps > 20 and spread_quality < 0.4:
    |

ai_trading/execution/microstructure.py:175:31: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
173 |             elif spread_bps > 50 or market_depth < 1000:
174 |                 return MarketRegimeFeature.ILLIQUID
175 |             elif spread_bps > 20 and spread_quality < 0.4:
    |                               ^^ PLR2004
176 |                 return MarketRegimeFeature.STRESSED
177 |             elif market_depth > 5000 and 5 <= spread_bps <= 15:
    |

ai_trading/execution/microstructure.py:175:55: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
173 |             elif spread_bps > 50 or market_depth < 1000:
174 |                 return MarketRegimeFeature.ILLIQUID
175 |             elif spread_bps > 20 and spread_quality < 0.4:
    |                                                       ^^^ PLR2004
176 |                 return MarketRegimeFeature.STRESSED
177 |             elif market_depth > 5000 and 5 <= spread_bps <= 15:
    |

ai_trading/execution/microstructure.py:177:33: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
    |
175 |             elif spread_bps > 20 and spread_quality < 0.4:
176 |                 return MarketRegimeFeature.STRESSED
177 |             elif market_depth > 5000 and 5 <= spread_bps <= 15:
    |                                 ^^^^ PLR2004
178 |                 return MarketRegimeFeature.INSTITUTIONAL
179 |             else:
    |

ai_trading/execution/microstructure.py:177:42: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
175 |             elif spread_bps > 20 and spread_quality < 0.4:
176 |                 return MarketRegimeFeature.STRESSED
177 |             elif market_depth > 5000 and 5 <= spread_bps <= 15:
    |                                          ^ PLR2004
178 |                 return MarketRegimeFeature.INSTITUTIONAL
179 |             else:
    |

ai_trading/execution/microstructure.py:177:61: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
175 |             elif spread_bps > 20 and spread_quality < 0.4:
176 |                 return MarketRegimeFeature.STRESSED
177 |             elif market_depth > 5000 and 5 <= spread_bps <= 15:
    |                                                             ^^ PLR2004
178 |                 return MarketRegimeFeature.INSTITUTIONAL
179 |             else:
    |

ai_trading/execution/microstructure.py:182:16: BLE001 Do not catch blind exception: `Exception`
    |
180 |                 return MarketRegimeFeature.RETAIL_DOMINATED
181 | 
182 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
183 |             logger.error(f"Error classifying spread regime: {e}")
184 |             return MarketRegimeFeature.RETAIL_DOMINATED
    |

ai_trading/execution/microstructure.py:191:37: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
189 |         """Calculate effective and realized spreads from trade history."""
190 |         try:
191 |             if len(trade_history) < 2:
    |                                     ^ PLR2004
192 |                 return 0.0, 0.0
    |

ai_trading/execution/microstructure.py:242:16: BLE001 Do not catch blind exception: `Exception`
    |
240 |             return avg_effective, avg_realized
241 | 
242 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
243 |             logger.error(f"Error calculating trade spreads: {e}")
244 |             return 0.0, 0.0
    |

ai_trading/execution/microstructure.py:328:57: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
326 |                 )
327 |                 features["large_trade_ratio"] = sum(
328 |                     1 for size in trade_sizes if size > 1000
    |                                                         ^^^^ PLR2004
329 |                 ) / len(trade_sizes)
    |

ai_trading/execution/microstructure.py:333:16: BLE001 Do not catch blind exception: `Exception`
    |
331 |             return features
332 | 
333 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
334 |             logger.error(f"Error analyzing order flow: {e}")
335 |             return {}
    |

ai_trading/execution/microstructure.py:355:38: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
353 |             is_toxic = (
354 |                 toxicity_score > self.toxicity_threshold
355 |                 or trade_intensity > 5.0  # Very high intensity
    |                                      ^^^ PLR2004
356 |                 or order_imbalance > 0.8  # Severe imbalance
357 |             )
    |

ai_trading/execution/microstructure.py:356:38: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
354 |                 toxicity_score > self.toxicity_threshold
355 |                 or trade_intensity > 5.0  # Very high intensity
356 |                 or order_imbalance > 0.8  # Severe imbalance
    |                                      ^^^ PLR2004
357 |             )
    |

ai_trading/execution/microstructure.py:360:33: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
359 |             risk_level = "high" if is_toxic else "normal"
360 |             if toxicity_score > 0.7 or trade_intensity > 10:
    |                                 ^^^ PLR2004
361 |                 risk_level = "extreme"
    |

ai_trading/execution/microstructure.py:360:58: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
359 |             risk_level = "high" if is_toxic else "normal"
360 |             if toxicity_score > 0.7 or trade_intensity > 10:
    |                                                          ^^ PLR2004
361 |                 risk_level = "extreme"
    |

ai_trading/execution/microstructure.py:371:16: BLE001 Do not catch blind exception: `Exception`
    |
369 |             }
370 | 
371 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
372 |             logger.error(f"Error detecting toxic flow: {e}")
373 |             return {"is_toxic": False, "risk_level": "unknown", "error": str(e)}
    |

ai_trading/execution/microstructure.py:378:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
376 |         """Calculate trade intensity (trades per minute)."""
377 |         try:
378 |             if len(trade_data) < 2:
    |                                  ^ PLR2004
379 |                 return 0.0
    |

ai_trading/execution/microstructure.py:389:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
387 |                 if trade.get("timestamp")
388 |             ]
389 |             if len(timestamps) < 2:
    |                                  ^ PLR2004
390 |                 return 0.0
    |

ai_trading/execution/microstructure.py:427:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
425 |         """Calculate order flow toxicity using adverse selection measure."""
426 |         try:
427 |             if len(trade_data) < 5 or len(quote_data) < 5:
    |                                  ^ PLR2004
428 |                 return 0.0
    |

ai_trading/execution/microstructure.py:427:57: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
425 |         """Calculate order flow toxicity using adverse selection measure."""
426 |         try:
427 |             if len(trade_data) < 5 or len(quote_data) < 5:
    |                                                         ^ PLR2004
428 |                 return 0.0
    |

ai_trading/execution/microstructure.py:483:34: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
481 |         """Estimate information content of trades."""
482 |         try:
483 |             if len(trade_data) < 3:
    |                                  ^ PLR2004
484 |                 return 0.0
    |

ai_trading/execution/microstructure.py:500:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
498 |             ]
499 | 
500 |             if len(prices) < 2 or not volumes:
    |                              ^ PLR2004
501 |                 return 0.0
    |

ai_trading/execution/microstructure.py:523:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
521 |         """Calculate deviation from volume-weighted average price."""
522 |         try:
523 |             if len(trade_data) < 2:
    |                                  ^ PLR2004
524 |                 return 0.0
    |

ai_trading/execution/microstructure.py:557:58: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
555 |         concerns = []
556 | 
557 |         if flow_features.get("order_flow_toxicity", 0) > 0.4:
    |                                                          ^^^ PLR2004
558 |             concerns.append("High flow toxicity")
    |

ai_trading/execution/microstructure.py:560:54: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
558 |             concerns.append("High flow toxicity")
559 | 
560 |         if flow_features.get("trade_intensity", 0) > 5:
    |                                                      ^ PLR2004
561 |             concerns.append("Elevated trade intensity")
    |

ai_trading/execution/microstructure.py:563:59: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
561 |             concerns.append("Elevated trade intensity")
562 | 
563 |         if abs(flow_features.get("order_imbalance", 0)) > 0.6:
    |                                                           ^^^ PLR2004
564 |             concerns.append("Significant order imbalance")
    |

ai_trading/execution/microstructure.py:566:58: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
564 |             concerns.append("Significant order imbalance")
565 | 
566 |         if flow_features.get("information_content", 0) > 0.7:
    |                                                          ^^^ PLR2004
567 |             concerns.append("High information content")
    |

ai_trading/execution/microstructure.py:577:58: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
575 |         recommendations = []
576 | 
577 |         if flow_features.get("order_flow_toxicity", 0) > 0.3:
    |                                                          ^^^ PLR2004
578 |             recommendations.append("Use limit orders to avoid adverse selection")
579 |             recommendations.append("Consider breaking large orders into smaller sizes")
    |

ai_trading/execution/microstructure.py:581:54: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
579 |             recommendations.append("Consider breaking large orders into smaller sizes")
580 | 
581 |         if flow_features.get("trade_intensity", 0) > 5:
    |                                                      ^ PLR2004
582 |             recommendations.append("Increase monitoring frequency")
583 |             recommendations.append("Consider delaying execution until flow normalizes")
    |

ai_trading/execution/microstructure.py:585:59: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
583 |             recommendations.append("Consider delaying execution until flow normalizes")
584 | 
585 |         if abs(flow_features.get("order_imbalance", 0)) > 0.5:
    |                                                           ^^^ PLR2004
586 |             recommendations.append("Monitor for potential price movement")
587 |             recommendations.append("Adjust order timing based on imbalance direction")
    |

ai_trading/execution/microstructure.py:696:16: BLE001 Do not catch blind exception: `Exception`
    |
694 |             return microstructure_data
695 | 
696 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
697 |             logger.error(f"Error analyzing market microstructure for {symbol}: {e}")
698 |             return self._create_default_microstructure_data(symbol)
    |

ai_trading/execution/microstructure.py:761:16: BLE001 Do not catch blind exception: `Exception`
    |
759 |             }
760 | 
761 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
762 |             logger.error(f"Error estimating execution impact: {e}")
763 |             return {"error": str(e), "total_impact_bps": 999.0}
    |

ai_trading/execution/microstructure.py:779:62: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
777 |             # Average trade size
778 |             recent_trades = (
779 |                 trade_history[-20:] if len(trade_history) >= 20 else trade_history
    |                                                              ^^ PLR2004
780 |             )
781 |             trade_sizes = [
    |

ai_trading/execution/microstructure.py:809:37: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
807 |             features = {}
808 | 
809 |             if len(trade_history) < 10:
    |                                     ^^ PLR2004
810 |                 return {
811 |                     "realized_volatility": 0.0,
    |

ai_trading/execution/microstructure.py:823:30: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
821 |             ]
822 | 
823 |             if len(prices) < 10:
    |                              ^^ PLR2004
824 |                 return {
825 |                     "realized_volatility": 0.0,
    |

ai_trading/execution/microstructure.py:842:31: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
841 |             # Price variance ratio (test for mean reversion)
842 |             if len(prices) >= 20:
    |                               ^^ PLR2004
843 |                 variance_1 = (
844 |                     statistics.variance(prices[-10:]) if len(prices[-10:]) > 1 else 0
    |

ai_trading/execution/microstructure.py:858:32: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
857 |             # Microstructure noise estimate
858 |             if len(returns) >= 5:
    |                                ^ PLR2004
859 |                 # Autocorrelation of returns as noise proxy
860 |                 lag1_corr = self._calculate_autocorrelation(returns, lag=1)
    |

ai_trading/execution/microstructure.py:867:16: BLE001 Do not catch blind exception: `Exception`
    |
865 |             return features
866 | 
867 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
868 |             logger.error(f"Error analyzing microstructure volatility: {e}")
869 |             return {
    |

ai_trading/execution/microstructure.py:922:49: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
921 |             # Spread quality
922 |             if microstructure_data.spread_bps < 20:
    |                                                 ^^ PLR2004
923 |                 confidence_factors.append(0.9)
924 |             elif microstructure_data.spread_bps < 50:
    |

ai_trading/execution/microstructure.py:924:51: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
922 |             if microstructure_data.spread_bps < 20:
923 |                 confidence_factors.append(0.9)
924 |             elif microstructure_data.spread_bps < 50:
    |                                                   ^^ PLR2004
925 |                 confidence_factors.append(0.6)
926 |             else:
    |

ai_trading/execution/microstructure.py:930:58: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
929 |             # Flow characteristics
930 |             if microstructure_data.order_flow_toxicity < 0.3:
    |                                                          ^^^ PLR2004
931 |                 confidence_factors.append(0.8)
932 |             else:
    |

ai_trading/execution/order_policy.py:77:34: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
   |
75 |     def is_wide_spread(self) -> bool:
76 |         """Check if spread is unusually wide."""
77 |         return self.spread_bps > 10.0  # 10 bps threshold
   |                                  ^^^^ PLR2004
   |

ai_trading/execution/order_policy.py:280:67: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
278 |             "cost_bps": cost_estimate,
279 |             "cost_dollars": position_value * (cost_estimate / 10000),
280 |             "slippage_risk": "high" if market_data.volume_ratio > 2.0 else "normal",
    |                                                                   ^^^ PLR2004
281 |         }
    |

ai_trading/execution/order_policy.py:326:34: PLR2004 Magic value used in comparison, consider replacing `0.005` with a constant variable
    |
324 |             price_deviation = abs(current_mid - original_limit) / original_limit
325 | 
326 |             if price_deviation > 0.005:  # 0.5% deviation
    |                                  ^^^^^ PLR2004
327 |                 return True, f"Market moved significantly ({price_deviation:.2%})"
    |

ai_trading/execution/order_policy.py:410:12: PLW0603 Using the global statement to update `_global_router` is discouraged
    |
408 | def get_smart_router() -> SmartOrderRouter:
409 |     """Get or create global smart order router."""
410 |     global _global_router
    |            ^^^^^^^^^^^^^^ PLW0603
411 |     if _global_router is None:
412 |         _global_router = SmartOrderRouter()
    |

ai_trading/execution/pnl_attributor.py:177:30: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
    |
175 |         # Calculate position change PnL (realized from position size changes)
176 |         qty_change = new_snapshot.quantity - old_snapshot.quantity
177 |         if abs(qty_change) > 1e-6:  # Position size changed
    |                              ^^^^ PLR2004
178 |             # For position size changes, calculate realized PnL
179 |             if qty_change < 0:  # Selling/reducing position
    |

ai_trading/execution/pnl_attributor.py:196:33: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
    |
194 |         price_change = new_snapshot.market_price - old_snapshot.market_price
195 |         if (
196 |             abs(price_change) > 1e-6 and old_snapshot.quantity != 0
    |                                 ^^^^ PLR2004
197 |         ):  # Price changed and we had position
198 |             # Use the position quantity before any changes for market movement calculation
    |

ai_trading/execution/pnl_attributor.py:454:30: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
452 |         explanations = []
453 |         for source, amount in pnl_by_source.items():
454 |             if abs(amount) > 0.01:  # Only include significant amounts
    |                              ^^^^ PLR2004
455 |                 sign = "gained" if amount > 0 else "lost"
456 |                 explanations.append(
    |

ai_trading/execution/pnl_attributor.py:527:12: PLW0603 Using the global statement to update `_pnl_attributor` is discouraged
    |
525 | def get_pnl_attributor() -> PnLAttributor:
526 |     """Get or create the global PnL attributor instance."""
527 |     global _pnl_attributor
    |            ^^^^^^^^^^^^^^^ PLW0603
528 |     with _attributor_lock:
529 |         if _pnl_attributor is None:
    |

ai_trading/execution/position_reconciler.py:164:16: BLE001 Do not catch blind exception: `Exception`
    |
162 |             return broker_positions
163 | 
164 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
165 |             self.logger.error(
166 |                 "BROKER_POSITION_FETCH_ERROR",
    |

ai_trading/execution/position_reconciler.py:214:49: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
213 |             # Keep history bounded
214 |             if len(self._discrepancy_history) > 1000:
    |                                                 ^^^^ PLR2004
215 |                 self._discrepancy_history = self._discrepancy_history[-500:]
    |

ai_trading/execution/position_reconciler.py:229:52: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
228 |             # Keep reconciliation history bounded
229 |             if len(self._reconciliation_history) > 100:
    |                                                    ^^^ PLR2004
230 |                 self._reconciliation_history = self._reconciliation_history[-50:]
    |

ai_trading/execution/position_reconciler.py:363:20: BLE001 Do not catch blind exception: `Exception`
    |
361 |                 time.sleep(self.reconciliation_interval)
362 | 
363 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
364 |                 self.logger.error(
365 |                     "RECONCILIATION_LOOP_ERROR",
    |

ai_trading/execution/position_reconciler.py:457:12: PLW0603 Using the global statement to update `_position_reconciler` is discouraged
    |
455 | def get_position_reconciler(api_client=None) -> PositionReconciler:
456 |     """Get or create the global position reconciler instance."""
457 |     global _position_reconciler
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
458 |     with _reconciler_lock:
459 |         if _position_reconciler is None:
    |

ai_trading/execution/production_engine.py:19:8: BLE001 Do not catch blind exception: `Exception`
   |
17 |     from alpaca.common.exceptions import APIError  # type: ignore
18 |     from alpaca.trading.client import TradingClient  # type: ignore
19 | except Exception:  # AI-AGENT-REF: local fallback when SDK missing
   |        ^^^^^^^^^ BLE001
20 |     TradingClient = None  # type: ignore
   |

ai_trading/execution/production_engine.py:197:28: PLR2004 Magic value used in comparison, consider replacing `1000000` with a constant variable
    |
195 |             self._validation_errors.append("Quantity must be positive")
196 | 
197 |         if self.quantity > 1000000:  # Reasonable upper limit
    |                            ^^^^^^^ PLR2004
198 |             self._validation_errors.append("Quantity exceeds maximum limit")
    |

ai_trading/execution/production_engine.py:219:65: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
218 |         # Risk parameter validation
219 |         if self.max_slippage_bps < 0 or self.max_slippage_bps > 1000:
    |                                                                 ^^^^ PLR2004
220 |             self._validation_errors.append(
221 |                 "Max slippage must be between 0 and 1000 basis points"
    |

ai_trading/execution/production_engine.py:548:15: PLR0911 Too many return statements (7 > 6)
    |
546 |             raise
547 | 
548 |     async def _comprehensive_safety_check(self, order: Order) -> dict[str, Any]:
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
549 |         """Perform comprehensive safety checks before execution."""
550 |         try:
    |

ai_trading/execution/production_engine.py:651:33: PLR2004 Magic value used in comparison, consider replacing `1000000` with a constant variable
    |
650 |             # Estimate impact based on order size
651 |             if notional_value > 1000000:  # $1M+
    |                                 ^^^^^^^ PLR2004
652 |                 impact_level = "high"
653 |                 estimated_slippage_bps = 15
    |

ai_trading/execution/production_engine.py:654:35: PLR2004 Magic value used in comparison, consider replacing `100000` with a constant variable
    |
652 |                 impact_level = "high"
653 |                 estimated_slippage_bps = 15
654 |             elif notional_value > 100000:  # $100K+
    |                                   ^^^^^^ PLR2004
655 |                 impact_level = "medium"
656 |                 estimated_slippage_bps = 8
    |

ai_trading/execution/production_engine.py:770:37: PLR2004 Magic value used in comparison, consider replacing `50000` with a constant variable
    |
768 |                 # Send alerts for significant orders
769 |                 notional_value = order.quantity * execution_result["fill_price"]
770 |                 if notional_value > 50000:  # Alert for orders > $50k
    |                                     ^^^^^ PLR2004
771 |                     await self.alert_manager.send_trading_alert(
772 |                         "Order Executed",
    |

ai_trading/execution/reconcile.py:32:38: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
   |
30 |     def is_significant(self) -> bool:
31 |         """Check if drift is significant enough to reconcile."""
32 |         return abs(self.drift_pct) > 0.01 or abs(self.drift_qty) > 0.001
   |                                      ^^^^ PLR2004
   |

ai_trading/execution/reconcile.py:32:68: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
   |
30 |     def is_significant(self) -> bool:
31 |         """Check if drift is significant enough to reconcile."""
32 |         return abs(self.drift_pct) > 0.01 or abs(self.drift_qty) > 0.001
   |                                                                    ^^^^^ PLR2004
   |

ai_trading/execution/reconcile.py:344:12: PLW0603 Using the global statement to update `_global_reconciler` is discouraged
    |
342 | def get_reconciler() -> PositionReconciler:
343 |     """Get or create global reconciler instance."""
344 |     global _global_reconciler
    |            ^^^^^^^^^^^^^^^^^^ PLW0603
345 |     if _global_reconciler is None:
346 |         _global_reconciler = PositionReconciler()
    |

ai_trading/execution/simulator.py:87:16: BLE001 Do not catch blind exception: `Exception`
   |
85 |             return total_slippage
86 | 
87 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
88 |             logger.error(f"Error calculating slippage: {e}")
89 |             return 0.0
   |

ai_trading/execution/simulator.py:121:16: BLE001 Do not catch blind exception: `Exception`
    |
119 |             )
120 | 
121 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
122 |             logger.error(f"Error updating market conditions: {e}")
    |

ai_trading/execution/simulator.py:215:16: BLE001 Do not catch blind exception: `Exception`
    |
213 |             return result
214 | 
215 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
216 |             logger.error(f"Error simulating fill: {e}")
217 |             return {
    |

ai_trading/execution/simulator.py:231:38: PLR2004 Magic value used in comparison, consider replacing `0.98` with a constant variable
    |
229 |         # Market orders almost always fill
230 |         if order_type == OrderType.MARKET:
231 |             return random.random() < 0.98
    |                                      ^^^^ PLR2004
232 | 
233 |         # Limit orders depend on price attractiveness
    |

ai_trading/execution/simulator.py:256:46: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
254 |         fill_time = 0
255 | 
256 |         while remaining > 0 and len(fills) < 5:  # Max 5 partial fills
    |                                              ^ PLR2004
257 |             # Random fill size (20-80% of remaining)
258 |             fill_pct = random.uniform(0.2, 0.8)
    |

ai_trading/execution/simulator.py:311:16: BLE001 Do not catch blind exception: `Exception`
    |
309 |             )
310 | 
311 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
312 |             logger.error(f"Error updating fill simulator: {e}")
    |

ai_trading/execution/transaction_costs.py:17:1: E402 Module level import not at top of file
   |
15 |   _log = logging.getLogger(__name__)  # AI-AGENT-REF: module logger
16 |   
17 | / from ai_trading.core.constants import (  # AI-AGENT-REF: direct import without shim
18 | |     EXECUTION_PARAMETERS,
19 | |     RISK_PARAMETERS,
20 | | )
   | |_^ E402
   |

ai_trading/execution/transaction_costs.py:504:30: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
502 |                 expected_profit > required_profit and  # Meets safety margin
503 |                 net_expected_profit > 0 and           # Positive net profit
504 |                 cost_ratio < 0.5 and                  # Costs < 50% of expected profit
    |                              ^^^ PLR2004
505 |                 confidence_level >= 0.6               # Sufficient confidence
506 |             )
    |

ai_trading/execution/transaction_costs.py:505:37: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
503 |                 net_expected_profit > 0 and           # Positive net profit
504 |                 cost_ratio < 0.5 and                  # Costs < 50% of expected profit
505 |                 confidence_level >= 0.6               # Sufficient confidence
    |                                     ^^^ PLR2004
506 |             )
    |

ai_trading/execution/transaction_costs.py:581:30: PLR2004 Magic value used in comparison, consider replacing `1000000` with a constant variable
    |
580 |             # Simple classification based on volume
581 |             if avg_volume >= 1000000:
    |                              ^^^^^^^ PLR2004
582 |                 return LiquidityTier.HIGH_LIQUIDITY
583 |             elif avg_volume >= 100000:
    |

ai_trading/execution/transaction_costs.py:583:32: PLR2004 Magic value used in comparison, consider replacing `100000` with a constant variable
    |
581 |             if avg_volume >= 1000000:
582 |                 return LiquidityTier.HIGH_LIQUIDITY
583 |             elif avg_volume >= 100000:
    |                                ^^^^^^ PLR2004
584 |                 return LiquidityTier.MEDIUM_LIQUIDITY
585 |             elif avg_volume >= 10000:
    |

ai_trading/execution/transaction_costs.py:585:32: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
583 |             elif avg_volume >= 100000:
584 |                 return LiquidityTier.MEDIUM_LIQUIDITY
585 |             elif avg_volume >= 10000:
    |                                ^^^^^ PLR2004
586 |                 return LiquidityTier.LOW_LIQUIDITY
587 |             else:
    |

ai_trading/features/pipeline.py:190:16: BLE001 Do not catch blind exception: `Exception`
    |
188 |             return features
189 | 
190 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
191 |             logger.error(f"Error adding return features: {e}")
192 |             return features
    |

ai_trading/features/pipeline.py:226:16: BLE001 Do not catch blind exception: `Exception`
    |
224 |             return features
225 | 
226 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
227 |             logger.error(f"Error adding volatility features: {e}")
228 |             return features
    |

ai_trading/features/pipeline.py:263:16: BLE001 Do not catch blind exception: `Exception`
    |
261 |             return features
262 | 
263 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
264 |             logger.error(f"Error adding volume features: {e}")
265 |             return features
    |

ai_trading/features/pipeline.py:300:28: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
    |
298 |             trend_ma = features["trend_slope"].rolling(20).mean()
299 |             features["trend_regime"] = np.where(
300 |                 trend_ma > 0.001,
    |                            ^^^^^ PLR2004
301 |                 1,  # Uptrend
302 |                 np.where(trend_ma < -0.001, -1, 0),  # Downtrend, Sideways
    |

ai_trading/features/pipeline.py:302:37: PLR2004 Magic value used in comparison, consider replacing `-0.001` with a constant variable
    |
300 |                 trend_ma > 0.001,
301 |                 1,  # Uptrend
302 |                 np.where(trend_ma < -0.001, -1, 0),  # Downtrend, Sideways
    |                                     ^^^^^^ PLR2004
303 |             )
    |

ai_trading/features/pipeline.py:324:16: BLE001 Do not catch blind exception: `Exception`
    |
322 |             return features
323 | 
324 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
325 |             logger.error(f"Error adding regime features: {e}")
326 |             return features
    |

ai_trading/features/pipeline.py:343:16: F821 Undefined name `sklearn_available`
    |
341 |     """
342 |     try:
343 |         if not sklearn_available:
    |                ^^^^^^^^^^^^^^^^^ F821
344 |             logger.warning("sklearn not available, returning simple pipeline")
345 |             return Pipeline(
    |

ai_trading/features/pipeline.py:430:12: BLE001 Do not catch blind exception: `Exception`
    |
428 |         return True
429 | 
430 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
431 |         logger.error(f"Error validating pipeline: {e}")
432 |         return False
    |

ai_trading/governance/promotion.py:121:16: BLE001 Do not catch blind exception: `Exception`
    |
119 |             return True
120 | 
121 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
122 |             self.logger.error(f"Error starting shadow testing for {model_id}: {e}")
123 |             return False
    |

ai_trading/governance/promotion.py:203:16: BLE001 Do not catch blind exception: `Exception`
    |
201 |             )
202 | 
203 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
204 |             self.logger.error(f"Error updating shadow metrics for {model_id}: {e}")
    |

ai_trading/governance/promotion.py:278:16: BLE001 Do not catch blind exception: `Exception`
    |
276 |             return eligible, evaluation
277 | 
278 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
279 |             self.logger.error(
280 |                 f"Error checking promotion eligibility for {model_id}: {e}"
    |

ai_trading/governance/promotion.py:333:16: BLE001 Do not catch blind exception: `Exception`
    |
331 |             return True
332 | 
333 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
334 |             self.logger.error(f"Error promoting model {model_id}: {e}")
335 |             return False
    |

ai_trading/governance/promotion.py:386:16: BLE001 Do not catch blind exception: `Exception`
    |
384 |                 last_updated=last_updated,
385 |             )
386 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
387 |             self.logger.error(f"Error loading shadow metrics for {model_id}: {e}")
388 |             return None
    |

ai_trading/governance/promotion.py:409:16: BLE001 Do not catch blind exception: `Exception`
    |
407 |             )
408 | 
409 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
410 |             self.logger.error(f"Error creating active symlink for {strategy}: {e}")
    |

ai_trading/governance/promotion.py:419:16: BLE001 Do not catch blind exception: `Exception`
    |
417 |                 symlink_path.unlink()
418 |                 self.logger.debug(f"Removed active symlink for {strategy}")
419 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
420 |             self.logger.error(f"Error removing active symlink for {strategy}: {e}")
    |

ai_trading/governance/promotion.py:462:20: BLE001 Do not catch blind exception: `Exception`
    |
460 |                     shadow_models.append(shadow_info)
461 | 
462 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
463 |                 self.logger.debug(
464 |                     f"Error checking shadow status for model {model_id}: {e}"
    |

ai_trading/governance/promotion.py:477:12: PLW0603 Using the global statement to update `_global_promotion_manager` is discouraged
    |
475 | def get_promotion_manager() -> ModelPromotion:
476 |     """Get or create global promotion manager."""
477 |     global _global_promotion_manager
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^ PLW0603
478 |     if _global_promotion_manager is None:
479 |         _global_promotion_manager = ModelPromotion()
    |

ai_trading/health_monitor.py:85:19: F821 Undefined name `Tuple`
   |
83 |     disk_used_gb: float
84 |     disk_available_gb: float
85 |     load_average: Tuple[float, float, float]
   |                   ^^^^^ F821
86 |     process_count: int
87 |     open_files: int
   |

ai_trading/health_monitor.py:158:16: BLE001 Do not catch blind exception: `Exception`
    |
156 |             self.consecutive_failures += 1
157 | 
158 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
159 |             response_time = (time.time() - start_time) * 1000
160 |             status = HealthStatus.CRITICAL
    |

ai_trading/health_monitor.py:324:20: BLE001 Do not catch blind exception: `Exception`
    |
322 |                 await asyncio.sleep(self.check_interval)
323 | 
324 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
325 |                 self.logger.error(f"Error in monitoring loop: {e}")
326 |                 await asyncio.sleep(10)  # Short delay before retry
    |

ai_trading/health_monitor.py:422:16: BLE001 Do not catch blind exception: `Exception`
    |
420 |             return metrics
421 | 
422 |         except Exception as e:  # pragma: no cover - unexpected psutil errors
    |                ^^^^^^^^^ BLE001
423 |             self.logger.error(f"Error collecting system metrics: {e}")
424 |             return SystemMetrics(
    |

ai_trading/health_monitor.py:691:12: PLW0603 Using the global statement to update `_health_monitor` is discouraged
    |
689 | def get_health_monitor() -> HealthMonitor:
690 |     """Get or create global health monitor instance."""
691 |     global _health_monitor
    |            ^^^^^^^^^^^^^^^ PLW0603
692 |     if _health_monitor is None:
693 |         _health_monitor = HealthMonitor()
    |

ai_trading/indicators.py:21:8: BLE001 Do not catch blind exception: `Exception`
   |
19 | try:  # pragma: no cover - optional dependency
20 |     from numba import jit as _numba_jit
21 | except Exception:  # pragma: no cover - numba not installed
   |        ^^^^^^^^^ BLE001
22 |     _numba_jit = None
   |

ai_trading/indicators.py:59:24: PLR2004 Magic value used in comparison, consider replacing `52` with a constant variable
   |
57 |             raise ValueError("Input series cannot be empty")
58 | 
59 |         if len(high) < 52:  # Need at least 52 periods for proper calculation
   |                        ^^ PLR2004
60 |             raise ValueError("Insufficient data: need at least 52 periods for Ichimoku")
   |

ai_trading/indicators.py:509:12: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
507 |     arr = series.values
508 |     n = len(arr)
509 |     if n > 10000:
    |            ^^^^^ PLR2004
510 |         step = max(1, n // 10000)
511 |         arr = arr[::step]
    |

ai_trading/integrations/rate_limit.py:445:12: PLW0603 Using the global statement to update `_global_rate_limiter` is discouraged
    |
443 | def get_rate_limiter() -> RateLimiter:
444 |     """Get or create global rate limiter instance."""
445 |     global _global_rate_limiter
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
446 |     if _global_rate_limiter is None:
447 |         _global_rate_limiter = RateLimiter()
    |

ai_trading/logging/__init__.py:147:17: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
145 |         if n == 0:
146 |             return ""
147 |         if n <= 6:
    |                 ^ PLR2004
148 |             return "***"
149 |         return f"{s[:2]}***{s[-2:]}"
    |

ai_trading/logging/__init__.py:230:17: PLW2901 `for` loop variable `v` overwritten by assignment target
    |
228 |                 continue
229 |             if _should_mask_secret(k, v):
230 |                 v = _mask_secret(v)  # type: ignore[arg-type]
    |                 ^ PLW2901
231 |             payload[k] = v
232 |         if record.exc_info:
    |

ai_trading/logging/__init__.py:267:21: PLW2901 `for` loop variable `v` overwritten by assignment target
    |
265 |             }:
266 |                 if "key" in k.lower() or "secret" in k.lower():
267 |                     v = _mask_secret(v)
    |                     ^ PLW2901
268 |                 payload[k] = v
    |

ai_trading/logging/__init__.py:329:12: PLW0603 Using the global statement to update `_LOGGING_CONFIGURED` is discouraged
    |
327 | def ensure_logging_configured(level: int | None = None) -> None:
328 |     """Configure root logging once."""  # AI-AGENT-REF: prevent duplicate handlers
329 |     global _LOGGING_CONFIGURED
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
330 |     root = logging.getLogger()
331 |     if _LOGGING_CONFIGURED or root.handlers:
    |

ai_trading/logging/__init__.py:359:12: PLW0603 Using the global statement to update `_configured` is discouraged
    |
357 | def setup_logging(debug: bool = False, log_file: str | None = None) -> logging.Logger:
358 |     """Configure the root logger in an idempotent way."""
359 |     global _configured, _log_queue, _listener, _LOGGING_CONFIGURED
    |            ^^^^^^^^^^^ PLW0603
360 | 
361 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent any duplicate setup
    |

ai_trading/logging/__init__.py:359:25: PLW0603 Using the global statement to update `_log_queue` is discouraged
    |
357 | def setup_logging(debug: bool = False, log_file: str | None = None) -> logging.Logger:
358 |     """Configure the root logger in an idempotent way."""
359 |     global _configured, _log_queue, _listener, _LOGGING_CONFIGURED
    |                         ^^^^^^^^^^ PLW0603
360 | 
361 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent any duplicate setup
    |

ai_trading/logging/__init__.py:359:37: PLW0603 Using the global statement to update `_listener` is discouraged
    |
357 | def setup_logging(debug: bool = False, log_file: str | None = None) -> logging.Logger:
358 |     """Configure the root logger in an idempotent way."""
359 |     global _configured, _log_queue, _listener, _LOGGING_CONFIGURED
    |                                     ^^^^^^^^^ PLW0603
360 | 
361 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent any duplicate setup
    |

ai_trading/logging/__init__.py:359:37: PLW0603 Using the global statement to update `_listener` is discouraged
    |
357 | def setup_logging(debug: bool = False, log_file: str | None = None) -> logging.Logger:
358 |     """Configure the root logger in an idempotent way."""
359 |     global _configured, _log_queue, _listener, _LOGGING_CONFIGURED
    |                                     ^^^^^^^^^ PLW0603
360 | 
361 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent any duplicate setup
    |

ai_trading/logging/__init__.py:359:48: PLW0603 Using the global statement to update `_LOGGING_CONFIGURED` is discouraged
    |
357 | def setup_logging(debug: bool = False, log_file: str | None = None) -> logging.Logger:
358 |     """Configure the root logger in an idempotent way."""
359 |     global _configured, _log_queue, _listener, _LOGGING_CONFIGURED
    |                                                ^^^^^^^^^^^^^^^^^^^ PLW0603
360 | 
361 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent any duplicate setup
    |

ai_trading/logging/__init__.py:558:22: DTZ011 `datetime.date.today()` used
    |
556 |     if not equity_curve:
557 |         return
558 |     as_of = as_of or date.today()
    |                      ^^^^^^^^^^^^ DTZ011
559 |     returns = pd.Series(equity_curve).pct_change().dropna()
560 |     roll = returns.tail(20)
    |
    = help: Use `datetime.datetime.now(tz=...).date()` instead

ai_trading/logging/__init__.py:795:12: PLW0603 Using the global statement to update `_LOGGING_CONFIGURED` is discouraged
    |
793 |         Number of backup log files to keep (default: 5)
794 |     """
795 |     global _LOGGING_CONFIGURED
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
796 | 
797 |     # AI-AGENT-REF: Thread-safe check of global flag to prevent duplicate enhanced logging setup
    |

ai_trading/logging/__init__.py:945:22: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
944 |     # Too many handlers (potential duplicates)
945 |     if after_count > 2:
    |                      ^ PLR2004
946 |         validation_result["validation_passed"] = False
947 |         validation_result["issues"].append(
    |

ai_trading/logging/normalize.py:15:12: BLE001 Do not catch blind exception: `Exception`
   |
13 |     try:
14 |         return str(value).strip().lower()
15 |     except Exception:
   |            ^^^^^^^^^ BLE001
16 |         return ""
   |

ai_trading/logging_filters.py:19:20: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
17 |     if not val:
18 |         return val
19 |     if len(val) <= 8:
   |                    ^ PLR2004
20 |         return "***"
21 |     return val[:4] + "…" + val[-4:]
   |

ai_trading/main.py:19:1: E402 Module level import not at top of file
   |
17 | load_dotenv(_DOTENV_PATH or None, override=True)
18 | 
19 | from ai_trading.logging import get_logger  # AI-AGENT-REF: early structured logging
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | 
21 | logger = get_logger(__name__)
   |

ai_trading/main.py:30:1: E402 Module level import not at top of file
   |
29 | # AI-AGENT-REF: Import only essential modules after env load for import-light entrypoint
30 | from ai_trading.settings import get_seed_int
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
31 | from ai_trading.config import get_settings
32 | from ai_trading.utils import get_free_port, get_pid_on_port
   |

ai_trading/main.py:31:1: E402 Module level import not at top of file
   |
29 | # AI-AGENT-REF: Import only essential modules after env load for import-light entrypoint
30 | from ai_trading.settings import get_seed_int
31 | from ai_trading.config import get_settings
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
32 | from ai_trading.utils import get_free_port, get_pid_on_port
33 | from ai_trading.utils.prof import StageTimer, SoftBudget
   |

ai_trading/main.py:32:1: E402 Module level import not at top of file
   |
30 | from ai_trading.settings import get_seed_int
31 | from ai_trading.config import get_settings
32 | from ai_trading.utils import get_free_port, get_pid_on_port
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 | from ai_trading.utils.prof import StageTimer, SoftBudget
34 | from ai_trading.logging.redact import redact as _redact  # AI-AGENT-REF: startup banner redaction
   |

ai_trading/main.py:33:1: E402 Module level import not at top of file
   |
31 | from ai_trading.config import get_settings
32 | from ai_trading.utils import get_free_port, get_pid_on_port
33 | from ai_trading.utils.prof import StageTimer, SoftBudget
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
34 | from ai_trading.logging.redact import redact as _redact  # AI-AGENT-REF: startup banner redaction
35 | from ai_trading.net.http import (
   |

ai_trading/main.py:34:1: E402 Module level import not at top of file
   |
32 | from ai_trading.utils import get_free_port, get_pid_on_port
33 | from ai_trading.utils.prof import StageTimer, SoftBudget
34 | from ai_trading.logging.redact import redact as _redact  # AI-AGENT-REF: startup banner redaction
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
35 | from ai_trading.net.http import (
36 |     build_retrying_session,
   |

ai_trading/main.py:35:1: E402 Module level import not at top of file
   |
33 |   from ai_trading.utils.prof import StageTimer, SoftBudget
34 |   from ai_trading.logging.redact import redact as _redact  # AI-AGENT-REF: startup banner redaction
35 | / from ai_trading.net.http import (
36 | |     build_retrying_session,
37 | |     set_global_session,
38 | | )  # AI-AGENT-REF: retrying HTTP session
   | |_^ E402
39 |   from ai_trading.position_sizing import (
40 |       resolve_max_position_size,
   |

ai_trading/main.py:39:1: E402 Module level import not at top of file
   |
37 |       set_global_session,
38 |   )  # AI-AGENT-REF: retrying HTTP session
39 | / from ai_trading.position_sizing import (
40 | |     resolve_max_position_size,
41 | |     _resolve_max_position_size,
42 | | )  # AI-AGENT-REF: dynamic max position sizing
   | |_^ E402
   |

ai_trading/main.py:54:12: PLW0603 Using the global statement to update `run_cycle` is discouraged
   |
53 | def _get_run_cycle():
54 |     global run_cycle
   |            ^^^^^^^^^ PLW0603
55 |     if run_cycle is _default_run_cycle:
56 |         from ai_trading.runner import run_cycle as _runner_run_cycle
   |

ai_trading/main.py:98:1: E402 Module level import not at top of file
    |
 97 | # AI-AGENT-REF: Create global config AFTER .env loading and Settings import
 98 | from typing import Any
    | ^^^^^^^^^^^^^^^^^^^^^^ E402
 99 | 
100 | config: Any | None = None
    |

ai_trading/main.py:227:12: PLW0603 Using the global statement to update `config` is discouraged
    |
225 |     Sets up logging, validates configuration, and starts the bot.
226 |     """
227 |     global config
    |            ^^^^^^ PLW0603
228 | 
229 |     # AI-AGENT-REF: Setup logging exactly once at startup
    |

ai_trading/main.py:332:12: PLW0603 Using the global statement to update `config` is discouraged
    |
330 |     """Start the API thread and repeatedly run trading cycles."""
331 |     args = parse_cli(argv)
332 |     global config
    |            ^^^^^^ PLW0603
333 |     config = get_settings()
334 |     S = get_settings()
    |

ai_trading/main.py:384:12: BLE001 Do not catch blind exception: `Exception`
    |
382 |                 extra={**sizing_meta, "resolved": resolved_size},
383 |             )
384 |     except Exception as e:  # pragma: no cover - defensive
    |            ^^^^^^^^^ BLE001
385 |         logger.warning("POSITION_SIZING_ERROR", extra={"error": str(e)})
    |

ai_trading/main.py:493:67: PLW1508 Invalid type for environment variable default; expected `str` or `None`
    |
491 |             budget = SoftBudget(
492 |                 interval_sec=float(interval),
493 |                 fraction=float(os.getenv("CYCLE_BUDGET_FRACTION", 0.8)),
    |                                                                   ^^^ PLW1508
494 |             )
495 |             try:
    |

ai_trading/main.py:499:64: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
497 |                 if count % memory_check_interval == 0:
498 |                     gc_result = optimize_memory()
499 |                     if gc_result.get("objects_collected", 0) > 100:
    |                                                                ^^^ PLR2004
500 |                         logger.info(
501 |                             f"Cycle {count}: Garbage collected {gc_result['objects_collected']} objects"
    |

ai_trading/market/cache.py:13:8: BLE001 Do not catch blind exception: `Exception`
   |
11 | try:
12 |     import pandas as pd  # type: ignore
13 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
14 |     pd = None  # tests can mock
   |

ai_trading/market/cache.py:66:12: BLE001 Do not catch blind exception: `Exception`
   |
64 |     try:
65 |         return pd.read_parquet(p)
66 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
67 |         logger.debug("Failed to read cache file %s: %s", p, e)
68 |         return None
   |

ai_trading/market/cache.py:80:12: BLE001 Do not catch blind exception: `Exception`
   |
78 |     try:
79 |         df.to_parquet(p, index=False)
80 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
81 |         logger.debug("Failed to write cache file %s: %s", p, e)
   |

ai_trading/market/calendars.py:251:51: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
249 |         # Crypto patterns
250 |         if any(crypto in symbol for crypto in ["BTC", "ETH", "USD", "USDT"]):
251 |             if "USD" in symbol and len(symbol) <= 6:
    |                                                   ^ PLR2004
252 |                 return AssetClass.CRYPTO
    |

ai_trading/market/calendars.py:257:32: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
255 |         if (
256 |             symbol.endswith(("F", "G", "H", "J", "K", "M", "N", "Q", "U", "V", "X", "Z"))
257 |             and len(symbol) >= 3
    |                                ^ PLR2004
258 |             and symbol[-2:].isdigit()
259 |         ):
    |

ai_trading/market/calendars.py:433:12: PLW0603 Using the global statement to update `_global_calendar` is discouraged
    |
431 | def get_calendar_registry() -> CalendarRegistry:
432 |     """Get or create global calendar registry."""
433 |     global _global_calendar
    |            ^^^^^^^^^^^^^^^^ PLW0603
434 |     if _global_calendar is None:
435 |         _global_calendar = CalendarRegistry()
    |

ai_trading/metrics/__init__.py:44:8: BLE001 Do not catch blind exception: `Exception`
   |
42 |     Summary = _Summary
43 |     start_http_server = _start_http_server
44 | except Exception:
   |        ^^^^^^^^^ BLE001
45 |     # Minimal no-op fallbacks so imports & tests never crash if the pkg is missing
46 |     class _NoopRegistry:
   |

ai_trading/metrics/__init__.py:83:1: E402 Module level import not at top of file
   |
82 | # AI-AGENT-REF: expose basic metrics helpers under canonical package
83 | from ai_trading.monitoring.metrics import calculate_atr, safe_divide
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/ml_model.py:27:16: BLE001 Do not catch blind exception: `Exception`
   |
25 |         try:
26 |             n = len(X)
27 |         except Exception:
   |                ^^^^^^^^^ BLE001
28 |             n = 0
29 |         return np.zeros(n)
   |

ai_trading/ml_model.py:108:12: BLE001 Do not catch blind exception: `Exception`
    |
106 |     try:
107 |         return list(preds)
108 |     except Exception:
    |            ^^^^^^^^^ BLE001
109 |         return []
    |

ai_trading/model_loader.py:34:12: BLE001 Do not catch blind exception: `Exception`
   |
32 |     try:
33 |         df = get_daily_df(symbol, start, end)
34 |     except Exception as exc:  # pragma: no cover - network may fail
   |            ^^^^^^^^^ BLE001
35 |         logger.warning("Data fetch failed for %s: %s", symbol, exc)
36 |         df = pd.DataFrame({"close": np.linspace(1.0, 2.0, 30)})
   |

ai_trading/model_loader.py:54:12: BLE001 Do not catch blind exception: `Exception`
   |
52 |         with open(MODELS_DIR / f"{symbol}.pkl", "wb") as f:
53 |             pickle.dump(model, f)
54 |     except Exception as exc:  # pragma: no cover - disk issues
   |            ^^^^^^^^^ BLE001
55 |         logger.warning("Failed saving model for %s: %s", symbol, exc)
   |

ai_trading/model_loader.py:68:16: BLE001 Do not catch blind exception: `Exception`
   |
66 |             with open(path, "rb") as f:
67 |                 model = pickle.load(f)
68 |         except Exception as exc:
   |                ^^^^^^^^^ BLE001
69 |             logger.warning("Model load failed for %s: %s", symbol, exc)
70 |             model = None
   |

ai_trading/model_loader.py:78:1: E402 Module level import not at top of file
   |
77 | # AI-AGENT-REF: Defer model loading in testing environments to prevent import blocking
78 | import os
   | ^^^^^^^^^ E402
79 | import sys
   |

ai_trading/model_loader.py:79:1: E402 Module level import not at top of file
   |
77 | # AI-AGENT-REF: Defer model loading in testing environments to prevent import blocking
78 | import os
79 | import sys
   | ^^^^^^^^^^ E402
80 | 
81 | # AI-AGENT-REF: More aggressive testing mode detection to prevent import hangs
   |

ai_trading/model_registry.py:17:8: BLE001 Do not catch blind exception: `Exception`
   |
15 | try:
16 |     from ai_trading.logging import logger  # project logger
17 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
18 |     import logging
   |

ai_trading/model_registry.py:40:16: BLE001 Do not catch blind exception: `Exception`
   |
38 |         try:
39 |             return json.loads(self.index_file.read_text(encoding="utf-8"))
40 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
41 |             logger.warning("Failed to load registry index: %s", e)
42 |             return {}
   |

ai_trading/monitoring/alerts.py:178:16: BLE001 Do not catch blind exception: `Exception`
    |
176 |             return alert
177 | 
178 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
179 |             logger.error(f"Error creating alert: {e}")
180 |             # Return dummy alert to prevent cascading errors
    |

ai_trading/monitoring/alerts.py:215:16: BLE001 Do not catch blind exception: `Exception`
    |
213 |             return False
214 | 
215 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
216 |             logger.error(f"Error acknowledging alert {alert_id}: {e}")
217 |             return False
    |

ai_trading/monitoring/alerts.py:232:16: BLE001 Do not catch blind exception: `Exception`
    |
230 |             return False
231 | 
232 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
233 |             logger.error(f"Error resolving alert {alert_id}: {e}")
234 |             return False
    |

ai_trading/monitoring/alerts.py:246:20: BLE001 Do not catch blind exception: `Exception`
    |
244 |             try:
245 |                 handler(alert)
246 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
247 |                 logger.error(f"Error in alert handler {handler.__name__}: {e}")
    |

ai_trading/monitoring/alerts.py:283:20: BLE001 Do not catch blind exception: `Exception`
    |
281 |                 psleep(3600)
282 | 
283 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
284 |                 logger.error(f"Error in alert cleanup: {e}")
285 |                 psleep(300)  # Sleep 5 minutes on error
    |

ai_trading/monitoring/alerts.py:352:16: BLE001 Do not catch blind exception: `Exception`
    |
350 |                 )
351 | 
352 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
353 |             logger.error(f"Error checking portfolio risk: {e}")
    |

ai_trading/monitoring/alerts.py:378:37: PLR2004 Magic value used in comparison, consider replacing `-0.10` with a constant variable
    |
376 |             # Check position loss
377 |             unrealized_pnl_pct = position_metrics.get("unrealized_pnl_pct", 0)
378 |             if unrealized_pnl_pct < -0.10:  # 10% loss threshold
    |                                     ^^^^^ PLR2004
379 |                 self._create_risk_alert(
380 |                     f"position_loss_{symbol}",
    |

ai_trading/monitoring/alerts.py:388:16: BLE001 Do not catch blind exception: `Exception`
    |
386 |                 )
387 | 
388 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
389 |             logger.error(f"Error checking position risk for {symbol}: {e}")
    |

ai_trading/monitoring/alerts.py:401:28: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
399 |             # Check fill rate
400 |             fill_rate = execution_metrics.get("fill_rate", 1.0)
401 |             if fill_rate < 0.8:  # 80% minimum fill rate
    |                            ^^^ PLR2004
402 |                 self._create_risk_alert(
403 |                     "low_fill_rate",
    |

ai_trading/monitoring/alerts.py:422:16: BLE001 Do not catch blind exception: `Exception`
    |
420 |                 )
421 | 
422 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
423 |             logger.error(f"Error checking execution risk: {e}")
    |

ai_trading/monitoring/alerts.py:449:16: BLE001 Do not catch blind exception: `Exception`
    |
447 |             self.last_alert_times[alert_key] = current_time
448 | 
449 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
450 |             logger.error(f"Error creating risk alert: {e}")
    |

ai_trading/monitoring/dashboard.py:48:19: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
   |
46 |                 for m in self.metrics_collector.trade_metrics
47 |                 if (datetime.now(UTC) - m["timestamp"]).total_seconds()
48 |                 < 3600  # Last hour
   |                   ^^^^ PLR2004
49 |             ]
   |

ai_trading/monitoring/dashboard.py:72:16: BLE001 Do not catch blind exception: `Exception`
   |
70 |             return result
71 | 
72 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
73 |             logger.error(f"Error calculating current P&L: {e}")
74 |             return {"realized_pnl": 0.0, "trade_count": 0, "win_rate": 0.0}
   |

ai_trading/monitoring/dashboard.py:108:16: BLE001 Do not catch blind exception: `Exception`
    |
106 |             return result
107 | 
108 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
109 |             logger.error(f"Error calculating portfolio summary: {e}")
110 |             return {"total_value": 0.0, "day_change": 0.0, "day_change_pct": 0.0}
    |

ai_trading/monitoring/dashboard.py:143:16: BLE001 Do not catch blind exception: `Exception`
    |
141 |             return result
142 | 
143 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
144 |             logger.error(f"Error calculating risk summary: {e}")
145 |             return {"var_95": 0.0, "max_drawdown": 0.0, "current_drawdown": 0.0}
    |

ai_trading/monitoring/dashboard.py:178:16: BLE001 Do not catch blind exception: `Exception`
    |
176 |             return result
177 | 
178 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
179 |             logger.error(f"Error calculating execution summary: {e}")
180 |             return {"orders_submitted": 0, "orders_filled": 0, "fill_rate": 0.0}
    |

ai_trading/monitoring/dashboard.py:251:16: BLE001 Do not catch blind exception: `Exception`
    |
249 |             return dashboard_data
250 | 
251 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
252 |             logger.error(f"Error generating dashboard data: {e}")
253 |             return {
    |

ai_trading/monitoring/dashboard.py:322:16: BLE001 Do not catch blind exception: `Exception`
    |
320 |             return summary
321 | 
322 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
323 |             logger.error(f"Error generating trading activity summary: {e}")
324 |             return {"total_trades": 0, "total_volume": 0.0}
    |

ai_trading/monitoring/dashboard.py:357:16: BLE001 Do not catch blind exception: `Exception`
    |
355 |             }
356 | 
357 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
358 |             logger.error(f"Error generating alert summary: {e}")
359 |             return {"active_count": 0, "severity_breakdown": {}, "recent_count": 0}
    |

ai_trading/monitoring/dashboard.py:382:28: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
    |
380 |             # Determine overall health status
381 |             status = "healthy"
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
    |                            ^^ PLR2004
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |

ai_trading/monitoring/dashboard.py:382:49: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
    |
380 |             # Determine overall health status
381 |             status = "healthy"
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
    |                                                 ^^ PLR2004
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |

ai_trading/monitoring/dashboard.py:382:65: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
380 |             # Determine overall health status
381 |             status = "healthy"
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
    |                                                                 ^^^^ PLR2004
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |

ai_trading/monitoring/dashboard.py:384:28: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |                            ^^ PLR2004
385 |                 status = "critical"
    |

ai_trading/monitoring/dashboard.py:384:49: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |                                                 ^^ PLR2004
385 |                 status = "critical"
    |

ai_trading/monitoring/dashboard.py:384:65: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
    |
382 |             if cpu_usage > 80 or memory_usage > 80 or latency > 1000:
383 |                 status = "warning"
384 |             if cpu_usage > 95 or memory_usage > 95 or latency > 5000:
    |                                                                 ^^^^ PLR2004
385 |                 status = "critical"
    |

ai_trading/monitoring/dashboard.py:395:16: BLE001 Do not catch blind exception: `Exception`
    |
393 |             }
394 | 
395 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
396 |             logger.error(f"Error generating system health: {e}")
397 |             return {"status": "error", "cpu_usage": 0, "memory_usage": 0}
    |

ai_trading/monitoring/dashboard.py:456:16: BLE001 Do not catch blind exception: `Exception`
    |
454 |             }
455 | 
456 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
457 |             logger.error(f"Error generating chart data: {e}")
458 |             return {"portfolio_value": [], "risk_metrics": [], "trading_volume": []}
    |

ai_trading/monitoring/drift.py:123:20: BLE001 Do not catch blind exception: `Exception`
    |
121 |                 )
122 | 
123 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
124 |                 self.logger.error(f"Failed to load baseline stats: {e}")
    |

ai_trading/monitoring/drift.py:138:16: BLE001 Do not catch blind exception: `Exception`
    |
136 |             )
137 | 
138 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
139 |             self.logger.error(f"Failed to save baseline stats: {e}")
    |

ai_trading/monitoring/drift.py:186:28: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
184 |             bins = np.unique(bins)  # Remove duplicates
185 | 
186 |             if len(bins) < 2:
    |                            ^ PLR2004
187 |                 return 0.0
    |

ai_trading/monitoring/drift.py:208:16: BLE001 Do not catch blind exception: `Exception`
    |
206 |             return float(psi)
207 | 
208 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
209 |             self.logger.warning(f"PSI calculation failed: {e}")
210 |             return 0.0
    |

ai_trading/monitoring/drift.py:424:16: BLE001 Do not catch blind exception: `Exception`
    |
422 |                 json.dump(attribution_dicts, f, indent=2)
423 | 
424 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
425 |             self.logger.error(f"Failed to save attribution history: {e}")
    |

ai_trading/monitoring/drift.py:547:16: BLE001 Do not catch blind exception: `Exception`
    |
545 |                 f.write(json.dumps(evaluation) + "\n")
546 | 
547 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
548 |             self.logger.error(f"Failed to log shadow evaluation: {e}")
    |

ai_trading/monitoring/drift.py:558:12: PLW0603 Using the global statement to update `_global_drift_monitor` is discouraged
    |
556 | def get_drift_monitor() -> DriftMonitor:
557 |     """Get or create global drift monitor instance."""
558 |     global _global_drift_monitor
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
559 |     if _global_drift_monitor is None:
560 |         _global_drift_monitor = DriftMonitor()
    |

ai_trading/monitoring/drift.py:566:12: PLW0603 Using the global statement to update `_global_shadow_mode` is discouraged
    |
564 | def get_shadow_mode() -> ShadowMode:
565 |     """Get or create global shadow mode instance."""
566 |     global _global_shadow_mode
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
567 |     if _global_shadow_mode is None:
568 |         _global_shadow_mode = ShadowMode()
    |

ai_trading/monitoring/metrics.py:162:40: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
161 |         # Keep only recent observations to prevent memory growth
162 |         if len(self.histograms[key]) > 1000:
    |                                        ^^^^ PLR2004
163 |             self.histograms[key] = self.histograms[key][-500:]
    |

ai_trading/monitoring/metrics.py:246:38: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
245 |         # Keep only recent trades to prevent memory growth
246 |         if len(self.trade_history) > 10000:
    |                                      ^^^^^ PLR2004
247 |             self.trade_history = self.trade_history[-5000:]
    |

ai_trading/monitoring/order_health_monitor.py:213:24: BLE001 Do not catch blind exception: `Exception`
    |
211 |                             },
212 |                         )
213 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
214 |                     self.logger.error(
215 |                         "Failed to cancel stale order %s: %s", order_info.order_id, e
    |

ai_trading/monitoring/order_health_monitor.py:230:40: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
228 |                 ).total_seconds()
229 | 
230 |                 if time_since_update > 300:  # 5 minutes since last update
    |                                        ^^^ PLR2004
231 |                     if partial_info.retry_count < self.max_retry_attempts:
232 |                         retry_candidates.append(partial_info)
    |

ai_trading/monitoring/order_health_monitor.py:275:16: BLE001 Do not catch blind exception: `Exception`
    |
273 |                     )
274 | 
275 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
276 |             self.logger.error(
277 |                 "Partial fill retry failed for %s: %s", partial_info.order_id, e
    |

ai_trading/monitoring/order_health_monitor.py:429:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
427 |         # Calculate trends
428 |         trend_data = {}
429 |         if len(recent_metrics) >= 2:
    |                                   ^ PLR2004
430 |             latest = recent_metrics[-1]
431 |             previous = recent_metrics[-2]
    |

ai_trading/monitoring/order_health_monitor.py:476:16: BLE001 Do not catch blind exception: `Exception`
    |
474 |             self.logger.info("Order health metrics exported to %s", filepath)
475 | 
476 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
477 |             self.logger.error("Failed to export metrics: %s", e)
    |

ai_trading/monitoring/order_health_monitor.py:486:12: PLW0603 Using the global statement to update `_order_health_monitor` is discouraged
    |
484 | def get_order_health_monitor(execution_engine=None) -> OrderHealthMonitor:
485 |     """Get or create the global order health monitor instance."""
486 |     global _order_health_monitor
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
487 | 
488 |     if _order_health_monitor is None:
    |

ai_trading/monitoring/slo.py:321:20: BLE001 Do not catch blind exception: `Exception`
    |
319 |             try:
320 |                 callback(metric_name, current_value)
321 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
322 |                 self.logger.error(
323 |                     f"Error in circuit breaker callback for {metric_name}: {e}"
    |

ai_trading/monitoring/slo.py:459:16: BLE001 Do not catch blind exception: `Exception`
    |
457 |             self.logger.info(f"Loaded SLO configuration from {config_path}")
458 | 
459 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
460 |             self.logger.error(f"Error loading SLO configuration: {e}")
    |

ai_trading/monitoring/slo.py:469:12: PLW0603 Using the global statement to update `_global_slo_monitor` is discouraged
    |
467 | def get_slo_monitor() -> SLOMonitor:
468 |     """Get or create global SLO monitor."""
469 |     global _global_slo_monitor
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
470 |     if _global_slo_monitor is None:
471 |         _global_slo_monitor = SLOMonitor()
    |

ai_trading/monitoring/system_health.py:7:8: BLE001 Do not catch blind exception: `Exception`
  |
5 |     import psutil  # type: ignore
6 |     _HAS_PSUTIL = True
7 | except Exception:
  |        ^^^^^^^^^ BLE001
8 |     psutil = None  # type: ignore
9 |     _HAS_PSUTIL = False
  |

ai_trading/monitoring/system_health.py:23:16: BLE001 Do not catch blind exception: `Exception`
   |
21 |                 }
22 |             )
23 |         except Exception:
   |                ^^^^^^^^^ BLE001
24 |             # keep minimal snapshot if psutil misbehaves
25 |             pass
   |

ai_trading/net/http.py:58:12: PLW0603 Using the global statement to update `_GLOBAL_SESSION` is discouraged
   |
56 |     """Register global session singleton."""  # AI-AGENT-REF
57 | 
58 |     global _GLOBAL_SESSION
   |            ^^^^^^^^^^^^^^^ PLW0603
59 |     _GLOBAL_SESSION = s
   |

ai_trading/pipeline.py:10:1: E402 Module level import not at top of file
   |
 9 | # ML dependencies
10 | from sklearn.base import BaseEstimator, TransformerMixin
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
11 | from sklearn.linear_model import SGDRegressor
12 | from sklearn.pipeline import Pipeline
   |

ai_trading/pipeline.py:11:1: E402 Module level import not at top of file
   |
 9 | # ML dependencies
10 | from sklearn.base import BaseEstimator, TransformerMixin
11 | from sklearn.linear_model import SGDRegressor
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
12 | from sklearn.pipeline import Pipeline
13 | from sklearn.preprocessing import StandardScaler
   |

ai_trading/pipeline.py:12:1: E402 Module level import not at top of file
   |
10 | from sklearn.base import BaseEstimator, TransformerMixin
11 | from sklearn.linear_model import SGDRegressor
12 | from sklearn.pipeline import Pipeline
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
13 | from sklearn.preprocessing import StandardScaler
   |

ai_trading/pipeline.py:13:1: E402 Module level import not at top of file
   |
11 | from sklearn.linear_model import SGDRegressor
12 | from sklearn.pipeline import Pipeline
13 | from sklearn.preprocessing import StandardScaler
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/portfolio/core.py:64:12: BLE001 Do not catch blind exception: `Exception`
   |
62 |                 )
63 |             )
64 |     except Exception:
   |            ^^^^^^^^^ BLE001
65 |         df_min = pd.DataFrame()
66 |     return _last_close_from(df_min)
   |

ai_trading/portfolio/core.py:77:16: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
75 |             return {}
76 | 
77 |         if n > 50:  # Prevent excessive diversification
   |                ^^ PLR2004
78 |             logger.warning("Too many symbols (%d), limiting to 50", n)
79 |             symbols = symbols[:50]
   |

ai_trading/portfolio/core.py:94:36: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
   |
92 |         # Validate weights sum to 1.0
93 |         weight_sum = sum(weights.values())
94 |         if abs(weight_sum - 1.0) > 0.01:
   |                                    ^^^^ PLR2004
95 |             logger.warning("Portfolio weights sum to %.3f, normalizing", weight_sum)
96 |             weights = {s: w / weight_sum for s, w in weights.items()}
   |

ai_trading/portfolio/core.py:171:12: BLE001 Do not catch blind exception: `Exception`
    |
169 |             extra={"component": "portfolio_summary", "error_type": "data"},
170 |         )
171 |     except Exception as exc:  # Final safety net for unexpected errors
    |            ^^^^^^^^^ BLE001
172 |         logger.warning(
173 |             "Portfolio summary failed - unexpected error: %s",
    |

ai_trading/portfolio/optimizer.py:132:41: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
130 |             portfolio_returns = self._calculate_portfolio_returns(positions, returns_data, current_prices)
131 | 
132 |             if len(portfolio_returns) < 20:  # Minimum sample size
    |                                         ^^ PLR2004
133 |                 logger.warning("Insufficient data for Kelly efficiency calculation")
134 |                 return 0.0
    |

ai_trading/portfolio/optimizer.py:312:9: PLR0911 Too many return statements (9 > 6)
    |
310 |             return TradeImpactAnalysis(0, 0, 0, 0, 0, 0, -1, 0)  # Reject by default
311 | 
312 |     def make_portfolio_decision(self,
    |         ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
313 |                               symbol: str,
314 |                               proposed_position: float,
    |

ai_trading/portfolio/optimizer.py:348:49: PLR2004 Magic value used in comparison, consider replacing `-0.05` with a constant variable
    |
347 |             # 4. Check Kelly efficiency improvement
348 |             if impact.kelly_efficiency_change < -0.05:  # Don't reduce efficiency by more than 5%
    |                                                 ^^^^^ PLR2004
349 |                 return PortfolioDecision.REJECT, f"Kelly efficiency would decrease by {abs(impact.kelly_efficiency_change):.3f}"
    |

ai_trading/portfolio/optimizer.py:352:36: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
351 |             # 5. Check confidence level
352 |             if impact.confidence < 0.6:
    |                                    ^^^ PLR2004
353 |                 return PortfolioDecision.DEFER, f"Low confidence {impact.confidence:.3f} in analysis"
    |

ai_trading/portfolio/optimizer.py:356:16: PLR2004 Magic value used in comparison, consider replacing `0.005` with a constant variable
    |
355 |             # 6. Consider batching for small improvements
356 |             if 0.005 <= impact.net_benefit < self.improvement_threshold:
    |                ^^^^^ PLR2004
357 |                 return PortfolioDecision.BATCH, f"Small improvement {impact.net_benefit:.3f} suitable for batching"
    |

ai_trading/portfolio/optimizer.py:415:44: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
413 |             if self.last_rebalance is not None:
414 |                 days_since_rebalance = (datetime.now(UTC) - self.last_rebalance).days
415 |                 if days_since_rebalance >= 90:  # Quarterly rebalancing
    |                                            ^^ PLR2004
416 |                     return True, f"Quarterly rebalance due ({days_since_rebalance} days since last)"
    |

ai_trading/portfolio/optimizer.py:445:74: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
443 |         try:
444 |             returns_data = market_data.get('returns', {})
445 |             if symbol not in returns_data or len(returns_data[symbol]) < 10:
    |                                                                          ^^ PLR2004
446 |                 return 0.0
    |

ai_trading/portfolio/optimizer.py:469:38: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
467 |             # Simplified risk estimate based on volatility
468 |             symbol_returns = returns_data[symbol]
469 |             if len(symbol_returns) < 10:
    |                                      ^^ PLR2004
470 |                 return 0.0
    |

ai_trading/portfolio/optimizer.py:503:46: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
501 |             if symbol not in returns_data:
502 |                 confidence *= 0.3
503 |             elif len(returns_data[symbol]) < 20:
    |                                              ^^ PLR2004
504 |                 confidence *= 0.7
    |

ai_trading/portfolio/risk_controls.py:200:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
198 |         correlation_matrix = correlation_matrix.fillna(0)
199 | 
200 |         if len(correlation_matrix) < 2:
    |                                      ^ PLR2004
201 |             return dict.fromkeys(returns_data.columns, 0)
    |

ai_trading/portfolio/risk_controls.py:233:16: BLE001 Do not catch blind exception: `Exception`
    |
231 |             return cluster_assignments
232 | 
233 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
234 |             self.logger.error(f"Clustering failed: {e}")
235 |             return dict.fromkeys(returns_data.columns, 0)
    |

ai_trading/portfolio/risk_controls.py:307:41: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
305 |             self.green_days_count += 1
306 |             # Gradually recover risk capacity
307 |             if self.green_days_count >= 5 and self.drawdown_multiplier < 1.0:
    |                                         ^ PLR2004
308 |                 self.drawdown_multiplier = min(1.0, self.drawdown_multiplier + 0.1)
309 |                 self.logger.info(
    |

ai_trading/portfolio/risk_controls.py:506:12: PLW0603 Using the global statement to update `_global_risk_controller` is discouraged
    |
504 | def get_risk_controller() -> AdaptiveRiskController:
505 |     """Get or create global risk controller instance."""
506 |     global _global_risk_controller
    |            ^^^^^^^^^^^^^^^^^^^^^^^ PLW0603
507 |     if _global_risk_controller is None:
508 |         _global_risk_controller = AdaptiveRiskController()
    |

ai_trading/position/__init__.py:7:8: BLE001 Do not catch blind exception: `Exception`
  |
5 | try:
6 |     from .core import MarketRegime  # AI-AGENT-REF: real enum if available
7 | except Exception:
  |        ^^^^^^^^^ BLE001
8 |     from enum import Enum
  |

ai_trading/position/correlation_analyzer.py:260:58: PLR2004 Magic value used in comparison, consider replacing `40.0` with a constant variable
    |
259 |             # Check individual position size
260 |             if self.last_analysis.largest_position_pct > 40.0:
    |                                                          ^^^^ PLR2004
261 |                 # Find if this is the largest position
262 |                 position_data = self._extract_position_data(current_positions)
    |

ai_trading/position/correlation_analyzer.py:268:37: PLR2004 Magic value used in comparison, consider replacing `30.0` with a constant variable
    |
266 |                         / self.last_analysis.total_value
267 |                     ) * 100
268 |                     if symbol_pct > 30.0:
    |                                     ^^^^ PLR2004
269 |                         return True, f"Position size: {symbol_pct:.1f}%"
    |

ai_trading/position/correlation_analyzer.py:277:9: PLR0911 Too many return statements (7 > 6)
    |
275 |             return False, ""
276 | 
277 |     def get_correlation_adjustment_factor(self, symbol: str) -> float:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
278 |         """
279 |         Get correlation-based adjustment factor for position management.
    |

ai_trading/position/correlation_analyzer.py:305:34: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
304 |             # Convert correlation to adjustment factor
305 |             if avg_correlation > 0.8:
    |                                  ^^^ PLR2004
306 |                 return 0.6  # High correlation - be more conservative
307 |             elif avg_correlation > 0.6:
    |

ai_trading/position/correlation_analyzer.py:307:36: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
305 |             if avg_correlation > 0.8:
306 |                 return 0.6  # High correlation - be more conservative
307 |             elif avg_correlation > 0.6:
    |                                    ^^^ PLR2004
308 |                 return 0.8  # Moderate correlation
309 |             elif avg_correlation < 0.3:
    |

ai_trading/position/correlation_analyzer.py:309:36: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
307 |             elif avg_correlation > 0.6:
308 |                 return 0.8  # Moderate correlation
309 |             elif avg_correlation < 0.3:
    |                                    ^^^ PLR2004
310 |                 return 1.2  # Low correlation - can be more aggressive
311 |             else:
    |

ai_trading/position/correlation_analyzer.py:402:68: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
400 |             # Calculate correlation
401 |             corr_matrix = np.corrcoef(returns1, returns2)
402 |             correlation = corr_matrix[0, 1] if len(corr_matrix) == 2 else 0.0
    |                                                                    ^ PLR2004
403 | 
404 |             # Handle NaN correlations
    |

ai_trading/position/correlation_analyzer.py:554:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
552 |         """Calculate average correlation within a sector."""
553 |         try:
554 |             if len(symbols) < 2:
    |                               ^ PLR2004
555 |                 return 0.0
    |

ai_trading/position/correlation_analyzer.py:691:67: PLR2004 Magic value used in comparison, consider replacing `35.0` with a constant variable
    |
690 |             # General rebalancing recommendations
691 |             if portfolio_metrics.get("largest_position_pct", 0) > 35.0:
    |                                                                   ^^^^ PLR2004
692 |                 rebalance.append("Consider reducing largest position size")
    |

ai_trading/position/correlation_analyzer.py:694:62: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
692 |                 rebalance.append("Consider reducing largest position size")
693 | 
694 |             if portfolio_metrics.get("avg_correlation", 0) > 0.6:
    |                                                              ^^^ PLR2004
695 |                 rebalance.append(
696 |                     "Portfolio shows high correlation - consider diversification"
    |

ai_trading/position/correlation_analyzer.py:701:64: PLR2004 Magic value used in comparison, consider replacing `50.0` with a constant variable
    |
699 |             if (
700 |                 len(sector_exposures) > 0
701 |                 and sector_exposures[0].portfolio_percentage > 50.0
    |                                                                ^^^^ PLR2004
702 |             ):
703 |                 rebalance.append(
    |

ai_trading/position/intelligent_manager.py:228:52: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
226 |             ]:
227 |                 # For partial actions, hold if confidence is not very high
228 |                 return recommendation.confidence < 0.8
    |                                                    ^^^ PLR2004
229 |             else:
230 |                 # Default to holding for NO_ACTION
    |

ai_trading/position/intelligent_manager.py:236:41: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
234 |             self.logger.warning("should_hold_position failed for %s: %s", symbol, exc)
235 |             # Fallback to simple logic
236 |             return unrealized_pnl_pct > 5.0 or days_held < 3
    |                                         ^^^ PLR2004
237 | 
238 |     def get_portfolio_recommendations(
    |

ai_trading/position/intelligent_manager.py:236:60: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
234 |             self.logger.warning("should_hold_position failed for %s: %s", symbol, exc)
235 |             # Fallback to simple logic
236 |             return unrealized_pnl_pct > 5.0 or days_held < 3
    |                                                            ^ PLR2004
237 | 
238 |     def get_portfolio_recommendations(
    |

ai_trading/position/intelligent_manager.py:392:19: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
390 |                 self.last_portfolio_analysis
391 |                 and (datetime.now(UTC) - self.last_portfolio_analysis.timestamp).seconds
392 |                 < 300
    |                   ^^^ PLR2004
393 |             ):
394 |                 portfolio_analysis = self.last_portfolio_analysis
    |

ai_trading/position/intelligent_manager.py:456:38: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
    |
454 |             # Adjust scores based on regime
455 |             patience_multiplier = regime_params.get("profit_taking_patience", 1.0)
456 |             if patience_multiplier > 1.2:
    |                                      ^^^ PLR2004
457 |                 hold_score += 0.3 * regime_confidence
458 |                 contributing_factors.append(
    |

ai_trading/position/intelligent_manager.py:461:40: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
459 |                     f"Trending market favors holding ({regime.value})"
460 |                 )
461 |             elif patience_multiplier < 0.8:
    |                                        ^^^ PLR2004
462 |                 sell_score += 0.2 * regime_confidence
463 |                 contributing_factors.append(
    |

ai_trading/position/intelligent_manager.py:489:35: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
488 |                 # Exit urgency
489 |                 if exit_urgency > 0.7:
    |                                   ^^^ PLR2004
490 |                     sell_score += 0.3
491 |                     contributing_factors.append(
    |

ai_trading/position/intelligent_manager.py:507:41: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
505 |                     target.quantity_pct for target in triggered_targets
506 |                 )
507 |                 if total_pct_to_sell >= 50:
    |                                         ^^ PLR2004
508 |                     sell_score += 0.3
509 |                     contributing_factors.append(
    |

ai_trading/position/intelligent_manager.py:530:37: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
529 |             correlation_factor = correlation_analysis.get("correlation_factor", 1.0)
530 |             if correlation_factor < 0.8:
    |                                     ^^^ PLR2004
531 |                 sell_score += 0.1
532 |                 contributing_factors.append("High portfolio correlation")
    |

ai_trading/position/intelligent_manager.py:533:39: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
    |
531 |                 sell_score += 0.1
532 |                 contributing_factors.append("High portfolio correlation")
533 |             elif correlation_factor > 1.2:
    |                                       ^^^ PLR2004
534 |                 hold_score += 0.1
535 |                 contributing_factors.append("Low portfolio correlation")
    |

ai_trading/position/intelligent_manager.py:598:24: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
596 |         max_score = max(hold_score, sell_score, partial_sell_score)
597 | 
598 |         if max_score < 0.2:
    |                        ^^^ PLR2004
599 |             return PositionAction.NO_ACTION, 0.3, 0.0
    |

ai_trading/position/intelligent_manager.py:606:53: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
604 |         )  # Urgency starts at 0.3 score
605 | 
606 |         if sell_score == max_score and sell_score > 0.4:
    |                                                     ^^^ PLR2004
607 |             return PositionAction.FULL_SELL, confidence, urgency
608 |         elif partial_sell_score == max_score and partial_sell_score > 0.3:
    |

ai_trading/position/intelligent_manager.py:608:71: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
606 |         if sell_score == max_score and sell_score > 0.4:
607 |             return PositionAction.FULL_SELL, confidence, urgency
608 |         elif partial_sell_score == max_score and partial_sell_score > 0.3:
    |                                                                       ^^^ PLR2004
609 |             return PositionAction.PARTIAL_SELL, confidence, urgency
610 |         elif hold_score == max_score and hold_score > 0.3:
    |

ai_trading/position/intelligent_manager.py:610:55: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
608 |         elif partial_sell_score == max_score and partial_sell_score > 0.3:
609 |             return PositionAction.PARTIAL_SELL, confidence, urgency
610 |         elif hold_score == max_score and hold_score > 0.3:
    |                                                       ^^^ PLR2004
611 |             return PositionAction.HOLD, confidence, urgency
612 |         elif sell_score > hold_score and sell_score > 0.2:
    |

ai_trading/position/intelligent_manager.py:612:55: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
610 |         elif hold_score == max_score and hold_score > 0.3:
611 |             return PositionAction.HOLD, confidence, urgency
612 |         elif sell_score > hold_score and sell_score > 0.2:
    |                                                       ^^^ PLR2004
613 |             return PositionAction.REDUCE_SIZE, confidence * 0.8, urgency
614 |         else:
    |

ai_trading/position/intelligent_manager.py:664:9: PLR0911 Too many return statements (8 > 6)
    |
662 |             return None, None, None, None
663 | 
664 |     def _determine_primary_reason(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
665 |         self,
666 |         action: PositionAction,
    |

ai_trading/position/intelligent_manager.py:684:67: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
683 |         technical_signals = technical_analysis.get("signals")
684 |         if technical_signals and technical_signals.exit_urgency > 0.7:
    |                                                                   ^^^ PLR2004
685 |             return (
686 |                 f"Technical exit signal (urgency: {technical_signals.exit_urgency:.2f})"
    |

ai_trading/position/legacy_manager.py:228:52: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
226 |             # Get minute data for momentum calculation
227 |             df = self.ctx.data_fetcher.get_minute_df(self.ctx, symbol)
228 |             if df is None or df.empty or len(df) < 20:
    |                                                    ^^ PLR2004
229 |                 return 0.0
    |

ai_trading/position/legacy_manager.py:283:26: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
282 |             # P&L component (40% weight)
283 |             if pnl_pct > 5.0:
    |                          ^^^ PLR2004
284 |                 score += 0.4 * min(1.0, pnl_pct / 20.0)  # Cap at 20% gain
285 |             elif pnl_pct < -10.0:
    |

ai_trading/position/legacy_manager.py:285:28: PLR2004 Magic value used in comparison, consider replacing `-10.0` with a constant variable
    |
283 |             if pnl_pct > 5.0:
284 |                 score += 0.4 * min(1.0, pnl_pct / 20.0)  # Cap at 20% gain
285 |             elif pnl_pct < -10.0:
    |                            ^^^^^ PLR2004
286 |                 score -= 0.2  # Penalize large losses
    |

ai_trading/position/legacy_manager.py:362:29: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
361 |                 # Determine signal
362 |                 if score >= 0.6:  # High score = hold
    |                             ^^^ PLR2004
363 |                     hold_signals[symbol] = "hold"
364 |                     self.logger.info(
    |

ai_trading/position/legacy_manager.py:367:31: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
365 |                         "POSITION_SIGNAL_HOLD | %s score=%.2f", symbol, score
366 |                     )
367 |                 elif score <= 0.3:  # Low score = sell
    |                               ^^^ PLR2004
368 |                     hold_signals[symbol] = "sell"
369 |                     self.logger.info(
    |

ai_trading/position/legacy_manager.py:439:29: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
437 | ) -> bool:
438 |     """Standalone function for position hold decision - used by problem statement example."""
439 |     if unrealized_pnl_pct > 5.0:  # Hold winners with >5% gain
    |                             ^^^ PLR2004
440 |         return True
441 |     if days_held < 3:  # Hold new positions for at least 3 days
    |

ai_trading/position/legacy_manager.py:441:20: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
439 |     if unrealized_pnl_pct > 5.0:  # Hold winners with >5% gain
440 |         return True
441 |     if days_held < 3:  # Hold new positions for at least 3 days
    |                    ^ PLR2004
442 |         return True
    |

ai_trading/position/market_regime.py:126:43: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
124 |             # Store in history
125 |             self.regime_history.append(regime_metrics)
126 |             if len(self.regime_history) > 100:  # Keep last 100 regime readings
    |                                           ^^^ PLR2004
127 |                 self.regime_history.pop(0)
    |

ai_trading/position/market_regime.py:139:16: BLE001 Do not catch blind exception: `Exception`
    |
137 |             return regime_metrics
138 | 
139 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
140 |             self.logger.warning("detect_regime failed: %s", exc)
141 |             return self._get_default_regime()
    |

ai_trading/position/market_regime.py:219:16: BLE001 Do not catch blind exception: `Exception`
    |
217 |             return None
218 | 
219 |         except Exception:
    |                ^^^^^^^^^ BLE001
220 |             return None
    |

ai_trading/position/market_regime.py:262:16: BLE001 Do not catch blind exception: `Exception`
    |
260 |             return {"strength": trend_strength, "direction": normalized_slope}
261 | 
262 |         except Exception:
    |                ^^^^^^^^^ BLE001
263 |             return {"strength": 0.0, "direction": 0.0}
    |

ai_trading/position/market_regime.py:276:31: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
274 |             returns = closes.pct_change().dropna()
275 | 
276 |             if len(returns) < 20:
    |                               ^^ PLR2004
277 |                 return {"percentile": 50.0, "current_vol": 0.0}
    |

ai_trading/position/market_regime.py:299:16: BLE001 Do not catch blind exception: `Exception`
    |
297 |             return {"percentile": percentile, "current_vol": current_vol}
298 | 
299 |         except Exception:
    |                ^^^^^^^^^ BLE001
300 |             return {"percentile": 50.0, "current_vol": 0.0}
    |

ai_trading/position/market_regime.py:305:59: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
303 |         """Analyze momentum indicators for regime classification."""
304 |         try:
305 |             if "close" not in data.columns or len(data) < 30:
    |                                                           ^^ PLR2004
306 |                 return {"score": 0.5, "rsi": 50.0}
    |

ai_trading/position/market_regime.py:318:31: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
317 |             # Price momentum (10-day vs 20-day)
318 |             if len(closes) >= 20:
    |                               ^^ PLR2004
319 |                 recent_avg = closes.tail(10).mean()
320 |                 older_avg = closes.tail(20).head(10).mean()
    |

ai_trading/position/market_regime.py:334:16: BLE001 Do not catch blind exception: `Exception`
    |
332 |             return {"score": momentum_score, "rsi": rsi if not pd.isna(rsi) else 50.0}
333 | 
334 |         except Exception:
    |                ^^^^^^^^^ BLE001
335 |             return {"score": 0.5, "rsi": 50.0}
    |

ai_trading/position/market_regime.py:340:59: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
338 |         """Analyze mean reversion tendency."""
339 |         try:
340 |             if "close" not in data.columns or len(data) < 30:
    |                                                           ^^ PLR2004
341 |                 return {"score": 0.5}
    |

ai_trading/position/market_regime.py:365:16: BLE001 Do not catch blind exception: `Exception`
    |
363 |             return {"score": mean_reversion_score}
364 | 
365 |         except Exception:
    |                ^^^^^^^^^ BLE001
366 |             return {"score": 0.5}
    |

ai_trading/position/market_regime.py:386:16: BLE001 Do not catch blind exception: `Exception`
    |
384 |             return rsi.iloc[-1] if not pd.isna(rsi.iloc[-1]) else 50.0
385 | 
386 |         except Exception:
    |                ^^^^^^^^^ BLE001
387 |             return 50.0
    |

ai_trading/position/market_regime.py:410:29: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
409 |         # Breakout/Breakdown detection
410 |         if momentum_score > 0.8 and trend_strength > 0.6:
    |                             ^^^ PLR2004
411 |             return (
412 |                 MarketRegime.BREAKOUT if trend_direction > 0 else MarketRegime.BREAKDOWN
    |

ai_trading/position/market_regime.py:410:54: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
409 |         # Breakout/Breakdown detection
410 |         if momentum_score > 0.8 and trend_strength > 0.6:
    |                                                      ^^^ PLR2004
411 |             return (
412 |                 MarketRegime.BREAKOUT if trend_direction > 0 else MarketRegime.BREAKDOWN
    |

ai_trading/position/market_regime.py:417:34: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
415 |         # Trending markets
416 |         if trend_strength > self.trending_threshold:
417 |             if trend_direction > 0.3:
    |                                  ^^^ PLR2004
418 |                 return MarketRegime.TRENDING_BULL
419 |             elif trend_direction < -0.3:
    |

ai_trading/position/market_regime.py:419:36: PLR2004 Magic value used in comparison, consider replacing `-0.3` with a constant variable
    |
417 |             if trend_direction > 0.3:
418 |                 return MarketRegime.TRENDING_BULL
419 |             elif trend_direction < -0.3:
    |                                    ^^^^ PLR2004
420 |                 return MarketRegime.TRENDING_BEAR
    |

ai_trading/position/market_regime.py:447:16: BLE001 Do not catch blind exception: `Exception`
    |
445 |             return max(0.0, min(1.0, confidence))
446 | 
447 |         except Exception:
    |                ^^^^^^^^^ BLE001
448 |             return 0.5
    |

ai_trading/position/market_regime.py:465:16: BLE001 Do not catch blind exception: `Exception`
    |
463 |             return duration
464 | 
465 |         except Exception:
    |                ^^^^^^^^^ BLE001
466 |             return 0
    |

ai_trading/position/profit_taking.py:400:35: PLR2004 Magic value used in comparison, consider replacing `3.0` with a constant variable
    |
399 |             # If already showing high velocity, create time-decay target
400 |             if current_gain_pct > 3.0:  # Already profitable
    |                                   ^^^ PLR2004
401 |                 # Create target that becomes more attractive over time
402 |                 velocity_target = ProfitTarget(
    |

ai_trading/position/profit_taking.py:468:35: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
    |
466 |             ) * 100
467 | 
468 |             if current_gain_pct > 10.0:  # Significant gain
    |                                   ^^^^ PLR2004
469 |                 # Create correlation-based target for portfolio risk management
470 |                 correlation_target = ProfitTarget(
    |

ai_trading/position/profit_taking.py:486:73: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
484 |                         and t.triggered
485 |                         and t.trigger_time
486 |                         and (datetime.now(UTC) - t.trigger_time).days < 5
    |                                                                         ^ PLR2004
487 |                     )
488 |                 ]
    |

ai_trading/position/profit_taking.py:514:58: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
512 |         """Find resistance levels from price data."""
513 |         try:
514 |             if "high" not in data.columns or len(data) < 20:
    |                                                          ^^ PLR2004
515 |                 return []
    |

ai_trading/position/profit_taking.py:544:59: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
542 |         """Create RSI overbought profit target."""
543 |         try:
544 |             if "close" not in data.columns or len(data) < 20:
    |                                                           ^^ PLR2004
545 |                 return None
    |

ai_trading/position/technical_analyzer.py:117:58: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
115 |             # Get market data
116 |             market_data = self._get_market_data(symbol)
117 |             if market_data is None or len(market_data) < 50:
    |                                                          ^^ PLR2004
118 |                 return self._get_default_signals(symbol)
    |

ai_trading/position/technical_analyzer.py:171:16: BLE001 Do not catch blind exception: `Exception`
    |
169 |             return signals
170 | 
171 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
172 |             self.logger.warning("analyze_signals failed for %s: %s", symbol, exc)
173 |             return self._get_default_signals(symbol)
    |

ai_trading/position/technical_analyzer.py:193:31: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
192 |             # Calculate price rate of change
193 |             if len(closes) >= 10:
    |                               ^^ PLR2004
194 |                 roc = (closes.iloc[-1] / closes.iloc[-10] - 1.0) * 100
195 |             else:
    |

ai_trading/position/technical_analyzer.py:261:30: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
260 |             # Bearish divergence: price up, momentum down
261 |             if price_trend > 0.1 and rsi_trend < -0.1:
    |                              ^^^ PLR2004
262 |                 divergence_type = DivergenceType.BEARISH
263 |                 divergence_strength = abs(price_trend) + abs(rsi_trend)
    |

ai_trading/position/technical_analyzer.py:261:50: PLR2004 Magic value used in comparison, consider replacing `-0.1` with a constant variable
    |
260 |             # Bearish divergence: price up, momentum down
261 |             if price_trend > 0.1 and rsi_trend < -0.1:
    |                                                  ^^^^ PLR2004
262 |                 divergence_type = DivergenceType.BEARISH
263 |                 divergence_strength = abs(price_trend) + abs(rsi_trend)
    |

ai_trading/position/technical_analyzer.py:266:32: PLR2004 Magic value used in comparison, consider replacing `-0.1` with a constant variable
    |
265 |             # Bullish divergence: price down, momentum up
266 |             elif price_trend < -0.1 and rsi_trend > 0.1:
    |                                ^^^^ PLR2004
267 |                 divergence_type = DivergenceType.BULLISH
268 |                 divergence_strength = abs(price_trend) + abs(rsi_trend)
    |

ai_trading/position/technical_analyzer.py:266:53: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
265 |             # Bullish divergence: price down, momentum up
266 |             elif price_trend < -0.1 and rsi_trend > 0.1:
    |                                                     ^^^ PLR2004
267 |                 divergence_type = DivergenceType.BULLISH
268 |                 divergence_strength = abs(price_trend) + abs(rsi_trend)
    |

ai_trading/position/technical_analyzer.py:308:34: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
306 |             vol_trend_slope = self._calculate_trend(recent_volumes)
307 | 
308 |             if vol_trend_slope > 0.1:
    |                                  ^^^ PLR2004
309 |                 vol_trend = "increasing"
310 |             elif vol_trend_slope < -0.1:
    |

ai_trading/position/technical_analyzer.py:310:36: PLR2004 Magic value used in comparison, consider replacing `-0.1` with a constant variable
    |
308 |             if vol_trend_slope > 0.1:
309 |                 vol_trend = "increasing"
310 |             elif vol_trend_slope < -0.1:
    |                                    ^^^^ PLR2004
311 |                 vol_trend = "decreasing"
312 |             else:
    |

ai_trading/position/technical_analyzer.py:316:54: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
315 |             # Price-volume relationship
316 |             if closes is not None and len(closes) >= 5:
    |                                                      ^ PLR2004
317 |                 recent_prices = closes.tail(5).tolist()
318 |                 price_trend = self._calculate_trend(recent_prices)
    |

ai_trading/position/technical_analyzer.py:340:59: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
338 |         """Analyze relative strength vs market/sector."""
339 |         try:
340 |             if "close" not in data.columns or len(data) < 20:
    |                                                           ^^ PLR2004
341 |                 return {"score": 0.5, "rank": 0.5}
    |

ai_trading/position/technical_analyzer.py:354:41: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
352 |                 market_data is not None
353 |                 and "close" in market_data.columns
354 |                 and len(market_data) >= 20
    |                                         ^^ PLR2004
355 |             ):
356 |                 market_prices = market_data["close"]
    |

ai_trading/position/technical_analyzer.py:392:32: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
390 |                 "high" not in data.columns
391 |                 or "low" not in data.columns
392 |                 or len(data) < 50
    |                                ^^ PLR2004
393 |             ):
394 |                 return {
    |

ai_trading/position/technical_analyzer.py:475:33: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
473 |             # Momentum component (30% weight)
474 |             momentum_score = momentum.get("score", 0.5)
475 |             if momentum_score > 0.7:
    |                                 ^^^ PLR2004
476 |                 score += 0.3
477 |             elif momentum_score > 0.6:
    |

ai_trading/position/technical_analyzer.py:477:35: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
475 |             if momentum_score > 0.7:
476 |                 score += 0.3
477 |             elif momentum_score > 0.6:
    |                                   ^^^ PLR2004
478 |                 score += 0.2
479 |             elif momentum_score < 0.3:
    |

ai_trading/position/technical_analyzer.py:479:35: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
477 |             elif momentum_score > 0.6:
478 |                 score += 0.2
479 |             elif momentum_score < 0.3:
    |                                   ^^^ PLR2004
480 |                 score -= 0.2
481 |             elif momentum_score < 0.4:
    |

ai_trading/position/technical_analyzer.py:481:35: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
479 |             elif momentum_score < 0.3:
480 |                 score -= 0.2
481 |             elif momentum_score < 0.4:
    |                                   ^^^ PLR2004
482 |                 score -= 0.1
    |

ai_trading/position/technical_analyzer.py:503:31: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
501 |             vol_trend = volume.get("trend", "neutral")
502 | 
503 |             if vol_strength > 0.7 and vol_trend == "increasing":
    |                               ^^^ PLR2004
504 |                 score += 0.2
505 |             elif vol_strength < 0.3:
    |

ai_trading/position/technical_analyzer.py:505:33: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
503 |             if vol_strength > 0.7 and vol_trend == "increasing":
504 |                 score += 0.2
505 |             elif vol_strength < 0.3:
    |                                 ^^^ PLR2004
506 |                 score -= 0.1
    |

ai_trading/position/technical_analyzer.py:510:27: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
508 |             # Relative strength component (15% weight)
509 |             rs_score = rel_strength.get("score", 0.5)
510 |             if rs_score > 0.6:
    |                           ^^^ PLR2004
511 |                 score += 0.15
512 |             elif rs_score < 0.4:
    |

ai_trading/position/technical_analyzer.py:512:29: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
510 |             if rs_score > 0.6:
511 |                 score += 0.15
512 |             elif rs_score < 0.4:
    |                             ^^^ PLR2004
513 |                 score -= 0.15
    |

ai_trading/position/technical_analyzer.py:519:38: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
517 |             support_distance = support_resistance.get("support_distance", 10.0)
518 | 
519 |             if resistance_distance < 2.0:  # Very close to resistance
    |                                      ^^^ PLR2004
520 |                 score -= 0.1
521 |             elif support_distance < 2.0:  # Very close to support
    |

ai_trading/position/technical_analyzer.py:521:37: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
519 |             if resistance_distance < 2.0:  # Very close to resistance
520 |                 score -= 0.1
521 |             elif support_distance < 2.0:  # Very close to support
    |                                     ^^^ PLR2004
522 |                 score -= 0.05
    |

ai_trading/position/technical_analyzer.py:525:25: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
524 |             # Convert score to recommendation
525 |             if score >= 0.3:
    |                         ^^^ PLR2004
526 |                 return SignalStrength.VERY_STRONG
527 |             elif score >= 0.15:
    |

ai_trading/position/technical_analyzer.py:527:27: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
    |
525 |             if score >= 0.3:
526 |                 return SignalStrength.VERY_STRONG
527 |             elif score >= 0.15:
    |                           ^^^^ PLR2004
528 |                 return SignalStrength.STRONG
529 |             elif score >= -0.15:
    |

ai_trading/position/technical_analyzer.py:529:27: PLR2004 Magic value used in comparison, consider replacing `-0.15` with a constant variable
    |
527 |             elif score >= 0.15:
528 |                 return SignalStrength.STRONG
529 |             elif score >= -0.15:
    |                           ^^^^^ PLR2004
530 |                 return SignalStrength.NEUTRAL
531 |             elif score >= -0.3:
    |

ai_trading/position/technical_analyzer.py:531:27: PLR2004 Magic value used in comparison, consider replacing `-0.3` with a constant variable
    |
529 |             elif score >= -0.15:
530 |                 return SignalStrength.NEUTRAL
531 |             elif score >= -0.3:
    |                           ^^^^ PLR2004
532 |                 return SignalStrength.WEAK
533 |             else:
    |

ai_trading/position/technical_analyzer.py:555:33: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
553 |             # Weak momentum = moderate urgency
554 |             momentum_score = momentum.get("score", 0.5)
555 |             if momentum_score < 0.3:
    |                                 ^^^ PLR2004
556 |                 urgency += 0.3
557 |             elif momentum_score < 0.4:
    |

ai_trading/position/technical_analyzer.py:557:35: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
555 |             if momentum_score < 0.3:
556 |                 urgency += 0.3
557 |             elif momentum_score < 0.4:
    |                                   ^^^ PLR2004
558 |                 urgency += 0.2
    |

ai_trading/position/technical_analyzer.py:561:73: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
560 |             # Volume confirmation of weakness
561 |             if volume.get("trend") == "increasing" and momentum_score < 0.5:
    |                                                                         ^^^ PLR2004
562 |                 urgency += 0.2  # High volume selling
    |

ai_trading/position/technical_analyzer.py:576:67: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
574 |                 # Try minute data first for more granular analysis
575 |                 df = self.ctx.data_fetcher.get_minute_df(self.ctx, symbol)
576 |                 if df is not None and not df.empty and len(df) >= 50:
    |                                                                   ^^ PLR2004
577 |                     return df
    |

ai_trading/position/technical_analyzer.py:636:30: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
634 |         """Calculate trend (slope) of a series of values."""
635 |         try:
636 |             if len(values) < 3:
    |                              ^ PLR2004
637 |                 return 0.0
    |

ai_trading/position/trailing_stops.py:165:16: BLE001 Do not catch blind exception: `Exception`
    |
163 |             return stop_level
164 | 
165 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
166 |             self.logger.warning("update_trailing_stop failed for %s: %s", symbol, exc)
167 |             return None
    |

ai_trading/position/trailing_stops.py:276:16: BLE001 Do not catch blind exception: `Exception`
    |
274 |             return new_stop
275 | 
276 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
277 |             self.logger.warning(
278 |                 "_calculate_adaptive_stop failed for %s: %s", symbol, exc
    |

ai_trading/position/trailing_stops.py:479:16: BLE001 Do not catch blind exception: `Exception`
    |
477 |                 )
478 | 
479 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
480 |             self.logger.warning("_check_stop_trigger failed: %s", exc)
    |

ai_trading/position_sizing.py:36:12: BLE001 Do not catch blind exception: `Exception`
   |
34 |     try:
35 |         return float(val)
36 |     except Exception:
   |            ^^^^^^^^^ BLE001
37 |         return default
   |

ai_trading/position_sizing.py:105:47: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
103 |             },
104 |         )
105 |         if getattr(resp, "status_code", 0) != 200:
    |                                               ^^^ PLR2004
106 |             return 0.0
107 |         data = resp.json()  # type: ignore[no-any-return]
    |

ai_trading/position_sizing.py:110:12: BLE001 Do not catch blind exception: `Exception`
    |
108 |         eq = _coerce_float(data.get("equity"), 0.0)
109 |         return eq
110 |     except Exception:
    |            ^^^^^^^^^ BLE001
111 |         return 0.0
    |

ai_trading/predict.py:10:8: BLE001 Do not catch blind exception: `Exception`
   |
 8 |     _CACHETOOLS_AVAILABLE = True
 9 |     _sentiment_cache = TTLCache(maxsize=1000, ttl=3600)
10 | except Exception:
   |        ^^^^^^^^^ BLE001
11 |     _CACHETOOLS_AVAILABLE = False
12 |     _sentiment_cache: dict[str, float] = {}
   |

ai_trading/predict.py:49:12: BLE001 Do not catch blind exception: `Exception`
   |
47 |         data = resp.json()
48 |         score = float(data.get("score", 0.0))
49 |     except Exception:
   |            ^^^^^^^^^ BLE001
50 |         score = 0.0
   |

ai_trading/predict.py:55:37: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
   |
53 |         _sentiment_cache[symbol] = score
54 |     else:
55 |         if len(_sentiment_cache) >= 1000:
   |                                     ^^^^ PLR2004
56 |             first_key = next(iter(_sentiment_cache), None)
57 |             if first_key is not None:
   |

ai_trading/production_system.py:473:74: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
472 |             # Integrate decisions
473 |             if mtf_action in ["BUY", "WEAK_BUY"] and regime_multiplier > 0.5:
    |                                                                          ^^^ PLR2004
474 |                 integrated["action"] = "BUY"
475 |                 integrated["confidence"] = mtf_confidence * regime_multiplier
    |

ai_trading/production_system.py:481:78: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
479 |                 )
480 | 
481 |             elif mtf_action in ["SELL", "WEAK_SELL"] and regime_multiplier > 0.5:
    |                                                                              ^^^ PLR2004
482 |                 integrated["action"] = "SELL"
483 |                 integrated["confidence"] = mtf_confidence * regime_multiplier
    |

ai_trading/rebalancer.py:23:1: E402 Module level import not at top of file
   |
23 | from ai_trading.config import get_settings
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
24 | from ai_trading.portfolio import compute_portfolio_weights
25 | from ai_trading.settings import get_rebalance_interval_min
   |

ai_trading/rebalancer.py:24:1: E402 Module level import not at top of file
   |
23 | from ai_trading.config import get_settings
24 | from ai_trading.portfolio import compute_portfolio_weights
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
25 | from ai_trading.settings import get_rebalance_interval_min
   |

ai_trading/rebalancer.py:25:1: E402 Module level import not at top of file
   |
23 | from ai_trading.config import get_settings
24 | from ai_trading.portfolio import compute_portfolio_weights
25 | from ai_trading.settings import get_rebalance_interval_min
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/rebalancer.py:47:1: E402 Module level import not at top of file
   |
46 | # AI-AGENT-REF: Enhanced rebalancer with tax awareness
47 | from ai_trading.core.constants import RISK_PARAMETERS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
48 | 
49 | # AI-AGENT-REF: Portfolio-first trading integration
   |

ai_trading/rebalancer.py:50:1: E402 Module level import not at top of file
   |
49 | # AI-AGENT-REF: Portfolio-first trading integration
50 | from ai_trading.portfolio import create_portfolio_optimizer
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
51 | from ai_trading.risk.adaptive_sizing import AdaptivePositionSizer
52 | from ai_trading.strategies.regime_detector import (
   |

ai_trading/rebalancer.py:51:1: E402 Module level import not at top of file
   |
49 | # AI-AGENT-REF: Portfolio-first trading integration
50 | from ai_trading.portfolio import create_portfolio_optimizer
51 | from ai_trading.risk.adaptive_sizing import AdaptivePositionSizer
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
52 | from ai_trading.strategies.regime_detector import (
53 |     create_regime_detector,
   |

ai_trading/rebalancer.py:52:1: E402 Module level import not at top of file
   |
50 |   from ai_trading.portfolio import create_portfolio_optimizer
51 |   from ai_trading.risk.adaptive_sizing import AdaptivePositionSizer
52 | / from ai_trading.strategies.regime_detector import (
53 | |     create_regime_detector,
54 | | )
   | |_^ E402
55 |   
56 |   # Log availability after imports are guaranteed
   |

ai_trading/rebalancer.py:291:39: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
289 |                 weight_diff = target_weight - current_weight
290 | 
291 |                 if abs(weight_diff) > 0.01:  # 1% threshold
    |                                       ^^^^ PLR2004
292 |                     current_price = float(current_prices.get(symbol, np.nan))
293 |                     if not (math.isfinite(current_price) and current_price > 0.0):
    |

ai_trading/rebalancer.py:333:48: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
331 |                             # Suggest delaying if close to long-term threshold with gains
332 |                             if (
333 |                                 holding_days > 300
    |                                                ^^^ PLR2004
334 |                                 and holding_days < 365
335 |                                 and total_gain_loss > 0
    |

ai_trading/rebalancer.py:334:52: PLR2004 Magic value used in comparison, consider replacing `365` with a constant variable
    |
332 |                             if (
333 |                                 holding_days > 300
334 |                                 and holding_days < 365
    |                                                    ^^^ PLR2004
335 |                                 and total_gain_loss > 0
336 |                                 and not tax_impact.get("is_long_term", False)
    |

ai_trading/rebalancer.py:420:80: PLR2004 Magic value used in comparison, consider replacing `31` with a constant variable
    |
418 |             if entry_date:
419 |                 days_held = (datetime.now(UTC) - entry_date).days
420 |                 recency_penalty = max(0, (31 - days_held) * 10) if days_held < 31 else 0
    |                                                                                ^^ PLR2004
421 |             else:
422 |                 recency_penalty = 0
    |

ai_trading/rebalancer.py:566:30: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
564 |                 1 for trade in rebalance_trades if trade.get("trade_quantity", 0) < 0
565 |             )
566 |             if total_sells > 5:
    |                              ^ PLR2004
567 |                 recommendations.append(
568 |                     "Consider spreading sales across multiple periods to manage tax impact"
    |

ai_trading/rebalancer.py:639:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
    |
637 | def enhanced_maybe_rebalance(ctx) -> None:
638 |     """Enhanced rebalance check with tax optimization and market conditions."""
639 |     global _last_rebalance
    |            ^^^^^^^^^^^^^^^ PLW0603
640 |     now = datetime.now(UTC)
    |

ai_trading/rebalancer.py:639:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
    |
637 | def enhanced_maybe_rebalance(ctx) -> None:
638 |     """Enhanced rebalance check with tax optimization and market conditions."""
639 |     global _last_rebalance
    |            ^^^^^^^^^^^^^^^ PLW0603
640 |     now = datetime.now(UTC)
    |

ai_trading/rebalancer.py:639:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
    |
637 | def enhanced_maybe_rebalance(ctx) -> None:
638 |     """Enhanced rebalance check with tax optimization and market conditions."""
639 |     global _last_rebalance
    |            ^^^^^^^^^^^^^^^ PLW0603
640 |     now = datetime.now(UTC)
    |

ai_trading/rebalancer.py:639:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
    |
637 | def enhanced_maybe_rebalance(ctx) -> None:
638 |     """Enhanced rebalance check with tax optimization and market conditions."""
639 |     global _last_rebalance
    |            ^^^^^^^^^^^^^^^ PLW0603
640 |     now = datetime.now(UTC)
    |

ai_trading/rebalancer.py:721:12: PLW0603 Using the global statement to update `_portfolio_optimizer` is discouraged
    |
719 |     quarterly tax-optimized rebalancing with intelligent decision making.
720 |     """
721 |     global _portfolio_optimizer, _regime_detector
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
722 | 
723 |     try:
    |

ai_trading/rebalancer.py:721:34: PLW0603 Using the global statement to update `_regime_detector` is discouraged
    |
719 |     quarterly tax-optimized rebalancing with intelligent decision making.
720 |     """
721 |     global _portfolio_optimizer, _regime_detector
    |                                  ^^^^^^^^^^^^^^^^ PLW0603
722 | 
723 |     try:
    |

ai_trading/rebalancer.py:861:5: PLR0911 Too many return statements (7 > 6)
    |
861 | def _check_portfolio_first_rebalancing(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
862 |     ctx, current_drift: float, drift_threshold: float
863 | ) -> tuple:
    |

ai_trading/rebalancer.py:879:36: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
878 |         days_since_rebalance = (datetime.now(UTC) - last_rebalance).days
879 |         if days_since_rebalance >= 90:  # Quarterly rebalancing
    |                                    ^^ PLR2004
880 |             return (
881 |                 True,
    |

ai_trading/rebalancer.py:902:57: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
900 |                         metrics.volatility_regime.value
901 |                         in ["extremely_high", "extremely_low"]
902 |                         and metrics.regime_confidence > 0.8
    |                                                         ^^^ PLR2004
903 |                     ):
904 |                         return (
    |

ai_trading/rebalancer.py:965:31: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
    |
963 |             try:
964 |                 qty = float(quantity)
965 |                 if abs(qty) > 0.001:  # Filter out very small positions
    |                               ^^^^^ PLR2004
966 |                     filtered_positions[symbol] = qty
967 |             except (ValueError, TypeError):
    |

ai_trading/rebalancer.py:1080:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
     |
1078 | def maybe_rebalance(ctx) -> None:
1079 |     """Rebalance when interval has elapsed."""
1080 |     global _last_rebalance
     |            ^^^^^^^^^^^^^^^ PLW0603
1081 |     now = datetime.now(UTC)
1082 |     if (now - _last_rebalance) >= timedelta(minutes=rebalance_interval_min()):
     |

ai_trading/rebalancer.py:1080:12: PLW0603 Using the global statement to update `_last_rebalance` is discouraged
     |
1078 | def maybe_rebalance(ctx) -> None:
1079 |     """Rebalance when interval has elapsed."""
1080 |     global _last_rebalance
     |            ^^^^^^^^^^^^^^^ PLW0603
1081 |     now = datetime.now(UTC)
1082 |     if (now - _last_rebalance) >= timedelta(minutes=rebalance_interval_min()):
     |

ai_trading/risk/adaptive_sizing.py:74:9: PLR0911 Too many return statements (10 > 6)
   |
72 |         )
73 | 
74 |     def analyze_market_regime(
   |         ^^^^^^^^^^^^^^^^^^^^^ PLR0911
75 |         self,
76 |         price_data: dict[str, list[float]],
   |

ai_trading/risk/adaptive_sizing.py:115:37: PLR2004 Magic value used in comparison, consider replacing `-0.5` with a constant variable
    |
113 |             # Regime classification logic
114 |             if vol_percentile > self.vol_thresholds["extremely_high"]:
115 |                 if trend_strength < -0.5:
    |                                     ^^^^ PLR2004
116 |                     return MarketRegime.CRISIS
117 |                 else:
    |

ai_trading/risk/adaptive_sizing.py:121:35: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
119 |             elif vol_percentile < self.vol_thresholds["extremely_low"]:
120 |                 return MarketRegime.LOW_VOLATILITY
121 |             elif trend_strength > 0.3:
    |                                   ^^^ PLR2004
122 |                 return MarketRegime.BULL_TRENDING
123 |             elif trend_strength < -0.3:
    |

ai_trading/risk/adaptive_sizing.py:123:35: PLR2004 Magic value used in comparison, consider replacing `-0.3` with a constant variable
    |
121 |             elif trend_strength > 0.3:
122 |                 return MarketRegime.BULL_TRENDING
123 |             elif trend_strength < -0.3:
    |                                   ^^^^ PLR2004
124 |                 return MarketRegime.BEAR_TRENDING
125 |             else:
    |

ai_trading/risk/adaptive_sizing.py:132:9: PLR0911 Too many return statements (8 > 6)
    |
130 |             return MarketRegime.NORMAL
131 | 
132 |     def assess_volatility_regime(self, returns: list[float]) -> VolatilityRegime:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
133 |         """
134 |         Assess current volatility regime based on returns.
    |

ai_trading/risk/adaptive_sizing.py:231:30: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
229 |         """Calculate trend strength using linear regression slope."""
230 |         try:
231 |             if len(prices) < 10:
    |                              ^^ PLR2004
232 |                 return 0.0
    |

ai_trading/risk/adaptive_sizing.py:259:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
257 |         """Calculate rolling volatility from prices."""
258 |         try:
259 |             if len(prices) < 2:
    |                              ^ PLR2004
260 |                 return 0.0
    |

ai_trading/risk/adaptive_sizing.py:272:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
270 |             )
271 | 
272 |             if len(recent_returns) < 2:
    |                                      ^ PLR2004
273 |                 return 0.0
    |

ai_trading/risk/adaptive_sizing.py:308:66: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
306 |         """Calculate Pearson correlation coefficient."""
307 |         try:
308 |             if len(returns1) != len(returns2) or len(returns1) < 2:
    |                                                                  ^ PLR2004
309 |                 return 0.0
    |

ai_trading/risk/adaptive_sizing.py:480:57: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
478 |                     "volatility_regime": volatility_regime.value,
479 |                     "correlation_environment": (
480 |                         "high" if correlation_penalty > 0.3 else "normal"
    |                                                         ^^^ PLR2004
481 |                     ),
482 |                 },
    |

ai_trading/risk/adaptive_sizing.py:612:63: PLR2004 Magic value used in comparison, consider replacing `0.03` with a constant variable
    |
610 |                 "estimated_daily_risk": estimated_daily_risk,
611 |                 "risk_percentage_of_account": risk_pct_of_account,
612 |                 "risk_level": "high" if risk_pct_of_account > 0.03 else "normal",
    |                                                               ^^^^ PLR2004
613 |                 "leverage_factor": (
614 |                     notional_value / account_equity if account_equity > 0 else 0
    |

ai_trading/risk/adaptive_sizing.py:646:34: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
644 |             "correlation_penalty", 0
645 |         )
646 |         if correlation_penalty > 0.3:
    |                                  ^^^ PLR2004
647 |             warnings.append("High correlation with existing positions - size reduced")
    |

ai_trading/risk/adaptive_sizing.py:657:26: PLR2004 Magic value used in comparison, consider replacing `1.1` with a constant variable
    |
655 |         factors = []
656 | 
657 |         if regime_mult > 1.1:
    |                          ^^^ PLR2004
658 |             factors.append("favorable market regime")
659 |         elif regime_mult < 0.9:
    |

ai_trading/risk/adaptive_sizing.py:659:28: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
657 |         if regime_mult > 1.1:
658 |             factors.append("favorable market regime")
659 |         elif regime_mult < 0.9:
    |                            ^^^ PLR2004
660 |             factors.append("unfavorable market regime")
    |

ai_trading/risk/adaptive_sizing.py:662:23: PLR2004 Magic value used in comparison, consider replacing `1.1` with a constant variable
    |
660 |             factors.append("unfavorable market regime")
661 | 
662 |         if vol_mult > 1.1:
    |                       ^^^ PLR2004
663 |             factors.append("low volatility environment")
664 |         elif vol_mult < 0.9:
    |

ai_trading/risk/adaptive_sizing.py:664:25: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
662 |         if vol_mult > 1.1:
663 |             factors.append("low volatility environment")
664 |         elif vol_mult < 0.9:
    |                         ^^^ PLR2004
665 |             factors.append("high volatility environment")
    |

ai_trading/risk/adaptive_sizing.py:667:34: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
665 |             factors.append("high volatility environment")
666 | 
667 |         if correlation_penalty > 0.2:
    |                                  ^^^ PLR2004
668 |             factors.append("high correlation with existing positions")
    |

ai_trading/risk/engine.py:31:1: E402 Module level import not at top of file
   |
29 | ta = _optional_import("pandas_ta")
30 | 
31 | from ai_trading.config.management import SEED, TradingConfig
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
32 | 
33 | try:  # AI-AGENT-REF: resilient Alpaca import
   |

ai_trading/risk/engine.py:43:1: E402 Module level import not at top of file
   |
43 | from ai_trading.config.settings import get_settings
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
44 | 
45 | try:
   |

ai_trading/risk/engine.py:209:59: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
207 |         if (
208 |             self._last_portfolio_cap is None
209 |             or abs(self._last_portfolio_cap - port_cap) > 0.01
    |                                                           ^^^^ PLR2004
210 |             or self._last_equity_cap is None
211 |             or abs(self._last_equity_cap - base_cap) > 0.01
    |

ai_trading/risk/engine.py:211:56: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
209 |             or abs(self._last_portfolio_cap - port_cap) > 0.01
210 |             or self._last_equity_cap is None
211 |             or abs(self._last_equity_cap - base_cap) > 0.01
    |                                                        ^^^^ PLR2004
212 |         ):
213 |             logger.info(
    |

ai_trading/risk/engine.py:284:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
283 |         # If no historical data, just use the base cap without conservative scaling
284 |         if len(self._returns) < 3:  # Need minimum data for meaningful statistics
    |                                 ^ PLR2004
285 |             return base_cap
    |

ai_trading/risk/engine.py:298:27: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
296 |         max_dd = abs(np.min(drawdown)) if len(drawdown) > 0 else 0
297 | 
298 |         if sharpe_proxy > 0.5 and max_dd < 0.05:
    |                           ^^^ PLR2004
299 |             multiplier = min(1.2, 1 + sharpe_proxy * 0.3)
300 |         elif sharpe_proxy < -0.3 or max_dd > 0.1:
    |

ai_trading/risk/engine.py:298:44: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
296 |         max_dd = abs(np.min(drawdown)) if len(drawdown) > 0 else 0
297 | 
298 |         if sharpe_proxy > 0.5 and max_dd < 0.05:
    |                                            ^^^^ PLR2004
299 |             multiplier = min(1.2, 1 + sharpe_proxy * 0.3)
300 |         elif sharpe_proxy < -0.3 or max_dd > 0.1:
    |

ai_trading/risk/engine.py:300:29: PLR2004 Magic value used in comparison, consider replacing `-0.3` with a constant variable
    |
298 |         if sharpe_proxy > 0.5 and max_dd < 0.05:
299 |             multiplier = min(1.2, 1 + sharpe_proxy * 0.3)
300 |         elif sharpe_proxy < -0.3 or max_dd > 0.1:
    |                             ^^^^ PLR2004
301 |             multiplier = max(0.3, 1 - max_dd * 2)
302 |         else:
    |

ai_trading/risk/engine.py:300:46: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
298 |         if sharpe_proxy > 0.5 and max_dd < 0.05:
299 |             multiplier = min(1.2, 1 + sharpe_proxy * 0.3)
300 |         elif sharpe_proxy < -0.3 or max_dd > 0.1:
    |                                              ^^^ PLR2004
301 |             multiplier = max(0.3, 1 - max_dd * 2)
302 |         else:
    |

ai_trading/risk/engine.py:622:9: PLR0911 Too many return statements (11 > 6)
    |
620 |             return False
621 | 
622 |     def position_size(self, signal: Any, cash: float, price: float, api=None) -> int:
    |         ^^^^^^^^^^^^^ PLR0911
623 |         """
624 |         Calculate optimal position size using Kelly criterion and risk management.
    |

ai_trading/risk/engine.py:764:25: PLR0124 Name compared with itself, consider replacing `raw_qty == raw_qty`
    |
762 |                 is_raw_qty_finite = (
763 |                     isinstance(raw_qty, int | float)
764 |                     and raw_qty == raw_qty
    |                         ^^^^^^^ PLR0124
765 |                     and abs(raw_qty) != float("inf")
766 |                 )
    |

ai_trading/risk/engine.py:769:25: PLR0124 Name compared with itself, consider replacing `min_qty == min_qty`
    |
767 |                 is_min_qty_finite = (
768 |                     isinstance(min_qty, int | float)
769 |                     and min_qty == min_qty
    |                         ^^^^^^^ PLR0124
770 |                     and abs(min_qty) != float("inf")
771 |                 )
    |

ai_trading/risk/engine.py:1114:32: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
     |
1112 |                 return False
1113 | 
1114 |             if abs(quantity) > 10000:  # Sanity check for very large orders
     |                                ^^^^^ PLR2004
1115 |                 logger.warning("Order quantity unusually large: %s shares", quantity)
1116 |                 # Don't reject, but log for review
     |

ai_trading/risk/engine.py:1145:19: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
     |
1143 |     # AI-AGENT-REF: clamp before applying drawdown adjustment
1144 |     kelly_fraction = min(max(kelly_fraction, 0.0), 1.0)
1145 |     if drawdown > 0.10:
     |                   ^^^^ PLR2004
1146 |         kelly_fraction *= 0.5
1147 |     return capital * kelly_fraction
     |

ai_trading/risk/engine.py:1150:5: PLR0911 Too many return statements (7 > 6)
     |
1150 | def calculate_position_size(*args, **kwargs) -> int:
     |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
1151 |     """
1152 |     Calculate optimal position size using Kelly criterion and risk management.
     |

ai_trading/risk/engine.py:1217:21: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
     |
1215 |     engine = RiskEngine()
1216 | 
1217 |     if len(args) == 2 and not kwargs:
     |                     ^ PLR2004
1218 |         cash, price = args
1219 |         # Validate inputs
     |

ai_trading/risk/engine.py:1232:21: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
     |
1230 |         return engine.position_size(dummy, cash, price)
1231 | 
1232 |     if len(args) >= 3:
     |                     ^ PLR2004
1233 |         signal, cash, price = args[:3]
     |

ai_trading/risk/engine.py:1246:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
     |
1244 |             return 0
1245 | 
1246 |         api = args[3] if len(args) > 3 else kwargs.get("api")
     |                                      ^ PLR2004
1247 |         return engine.position_size(signal, cash, price, api)
     |

ai_trading/risk/engine.py:1334:12: PLW0603 Using the global statement to update `CURRENT_TRADES` is discouraged
     |
1332 | def register_trade(size: int) -> dict | None:
1333 |     """Register a trade and increment the count if allowed."""
1334 |     global CURRENT_TRADES
     |            ^^^^^^^^^^^^^^ PLW0603
1335 |     if not can_trade() or size <= 0:
1336 |         return None
     |

ai_trading/risk/kelly.py:69:33: F821 Undefined name `_DEFAULT_CONFIG`
   |
67 |         """
68 |         # Use provided config or default
69 |         self.config = config or _DEFAULT_CONFIG
   |                                 ^^^^^^^^^^^^^^^ F821
70 | 
71 |         # Support backward compatibility: use passed parameters if provided, otherwise use config
   |

ai_trading/risk/kelly.py:141:16: BLE001 Do not catch blind exception: `Exception`
    |
139 |             return kelly_fraction
140 | 
141 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
142 |             logger.error(f"Error calculating Kelly fraction: {e}")
143 |             return 0.0
    |

ai_trading/risk/kelly.py:195:16: BLE001 Do not catch blind exception: `Exception`
    |
193 |             return kelly_fraction, stats
194 | 
195 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
196 |             logger.error(f"Error calculating Kelly from returns: {e}")
197 |             return 0.0, {"error": str(e)}
    |

ai_trading/risk/kelly.py:248:16: BLE001 Do not catch blind exception: `Exception`
    |
246 |             return adjusted_kelly, confidence_interval
247 | 
248 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
249 |             logger.error(f"Error calculating Kelly with confidence: {e}")
250 |             return 0.0, 0.0
    |

ai_trading/risk/kelly.py:266:33: F821 Undefined name `_DEFAULT_CONFIG`
    |
264 |         self.kelly_criterion = KellyCriterion()
265 |         # Use centralized config values instead of undefined KELLY_PARAMETERS
266 |         self.lookback_periods = _DEFAULT_CONFIG.lookback_periods
    |                                 ^^^^^^^^^^^^^^^ F821
267 |         self.rebalance_frequency = _DEFAULT_CONFIG.rebalance_frequency
    |

ai_trading/risk/kelly.py:267:36: F821 Undefined name `_DEFAULT_CONFIG`
    |
265 |         # Use centralized config values instead of undefined KELLY_PARAMETERS
266 |         self.lookback_periods = _DEFAULT_CONFIG.lookback_periods
267 |         self.rebalance_frequency = _DEFAULT_CONFIG.rebalance_frequency
    |                                    ^^^^^^^^^^^^^^^ F821
268 | 
269 |         # Store historical calculations
    |

ai_trading/risk/kelly.py:315:16: BLE001 Do not catch blind exception: `Exception`
    |
313 |             return portfolio_kelly
314 | 
315 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
316 |             logger.error(f"Error calculating portfolio Kelly: {e}")
317 |             return {}
    |

ai_trading/risk/kelly.py:337:29: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
335 |             # Volatility adjustment
336 |             volatility = market_conditions.get("volatility", 0.2)
337 |             if volatility > 0.3:  # High volatility
    |                             ^^^ PLR2004
338 |                 adjusted_kelly *= 0.5  # Reduce position size
339 |                 logger.debug(f"High volatility adjustment: {volatility:.3f}")
    |

ai_trading/risk/kelly.py:340:31: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
338 |                 adjusted_kelly *= 0.5  # Reduce position size
339 |                 logger.debug(f"High volatility adjustment: {volatility:.3f}")
340 |             elif volatility < 0.1:  # Low volatility
    |                               ^^^ PLR2004
341 |                 adjusted_kelly *= 1.2  # Slightly increase position size
342 |                 logger.debug(f"Low volatility adjustment: {volatility:.3f}")
    |

ai_trading/risk/kelly.py:346:35: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
344 |             # Drawdown adjustment
345 |             current_drawdown = market_conditions.get("drawdown", 0.0)
346 |             if current_drawdown > 0.1:  # Significant drawdown
    |                                   ^^^ PLR2004
347 |                 drawdown_factor = 1 - (current_drawdown * 2)  # Reduce by 2x drawdown
348 |                 adjusted_kelly *= max(0.1, drawdown_factor)
    |

ai_trading/risk/kelly.py:367:16: BLE001 Do not catch blind exception: `Exception`
    |
365 |             return adjusted_kelly
366 | 
367 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
368 |             logger.error(f"Error adjusting Kelly fraction: {e}")
369 |             return base_kelly * 0.5  # Conservative fallback
    |

ai_trading/risk/kelly.py:422:16: BLE001 Do not catch blind exception: `Exception`
    |
420 |             return adjusted_kelly
421 | 
422 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
423 |             logger.error(f"Error calculating Kelly with correlation: {e}")
424 |             return self.calculate_portfolio_kelly(asset_returns)
    |

ai_trading/risk/kelly.py:444:16: BLE001 Do not catch blind exception: `Exception`
    |
442 |             ]
443 | 
444 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
445 |             logger.error(f"Error recording Kelly calculation: {e}")
    |

ai_trading/risk/manager.py:139:30: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
137 |             assessment["risk_score"] = risk_score
138 |             assessment["approved"] = (
139 |                 risk_score < 70 and len(assessment["warnings"]) == 0
    |                              ^^ PLR2004
140 |             )
    |

ai_trading/risk/manager.py:236:43: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
    |
235 |             # Risk level classification
236 |             if assessment["risk_score"] < 25:
    |                                           ^^ PLR2004
237 |                 assessment["overall_risk_level"] = "Low"
238 |             elif assessment["risk_score"] < 50:
    |

ai_trading/risk/manager.py:238:45: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
236 |             if assessment["risk_score"] < 25:
237 |                 assessment["overall_risk_level"] = "Low"
238 |             elif assessment["risk_score"] < 50:
    |                                             ^^ PLR2004
239 |                 assessment["overall_risk_level"] = "Medium"
240 |             elif assessment["risk_score"] < 75:
    |

ai_trading/risk/manager.py:240:45: PLR2004 Magic value used in comparison, consider replacing `75` with a constant variable
    |
238 |             elif assessment["risk_score"] < 50:
239 |                 assessment["overall_risk_level"] = "Medium"
240 |             elif assessment["risk_score"] < 75:
    |                                             ^^ PLR2004
241 |                 assessment["overall_risk_level"] = "High"
242 |             else:
    |

ai_trading/risk/manager.py:327:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
325 |         """
326 |         try:
327 |             if len(returns) < 30:
    |                               ^^ PLR2004
328 |                 logger.warning(
329 |                     f"Insufficient data for VaR calculation: {len(returns)} returns"
    |

ai_trading/risk/manager.py:361:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
359 |         """
360 |         try:
361 |             if len(returns) < 30:
    |                               ^^ PLR2004
362 |                 return 0.0
    |

ai_trading/risk/manager.py:408:37: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
406 |                     # Ensure same length
407 |                     min_length = min(len(returns1), len(returns2))
408 |                     if min_length < 30:
    |                                     ^^ PLR2004
409 |                         continue
    |

ai_trading/risk/manager.py:430:66: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
428 |         """Calculate correlation coefficient between two return series."""
429 |         try:
430 |             if len(returns1) != len(returns2) or len(returns1) < 2:
    |                                                                  ^ PLR2004
431 |                 return 0.0
    |

ai_trading/risk/metrics.py:43:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
41 |         """
42 |         try:
43 |             if len(returns) < 30:
   |                               ^^ PLR2004
44 |                 logger.warning(f"Insufficient data for VaR: {len(returns)} returns")
45 |                 return 0.0
   |

ai_trading/risk/metrics.py:53:16: BLE001 Do not catch blind exception: `Exception`
   |
51 |             return var
52 | 
53 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
54 |             logger.error(f"Error calculating VaR: {e}")
55 |             return 0.0
   |

ai_trading/risk/metrics.py:71:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
69 |         """
70 |         try:
71 |             if len(returns) < 30:
   |                               ^^ PLR2004
72 |                 return 0.0
   |

ai_trading/risk/metrics.py:85:16: BLE001 Do not catch blind exception: `Exception`
   |
83 |             return es
84 | 
85 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
86 |             logger.error(f"Error calculating Expected Shortfall: {e}")
87 |             return 0.0
   |

ai_trading/risk/metrics.py:94:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
92 |         """Calculate Sharpe ratio."""
93 |         try:
94 |             if len(returns) < 2:
   |                               ^ PLR2004
95 |                 return 0.0
   |

ai_trading/risk/metrics.py:100:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
 98 |             mean_excess = statistics.mean(excess_returns)
 99 | 
100 |             if len(excess_returns) < 2:
    |                                      ^ PLR2004
101 |                 return 0.0
    |

ai_trading/risk/metrics.py:110:16: BLE001 Do not catch blind exception: `Exception`
    |
108 |             return sharpe
109 | 
110 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
111 |             logger.error(f"Error calculating Sharpe ratio: {e}")
112 |             return 0.0
    |

ai_trading/risk/metrics.py:119:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
117 |         """Calculate Sortino ratio."""
118 |         try:
119 |             if len(returns) < 2:
    |                               ^ PLR2004
120 |                 return 0.0
    |

ai_trading/risk/metrics.py:141:16: BLE001 Do not catch blind exception: `Exception`
    |
139 |             return sortino
140 | 
141 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
142 |             logger.error(f"Error calculating Sortino ratio: {e}")
143 |             return 0.0
    |

ai_trading/risk/metrics.py:239:16: BLE001 Do not catch blind exception: `Exception`
    |
237 |             return stats
238 | 
239 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
240 |             logger.error(f"Error calculating drawdowns: {e}")
241 |             return {}
    |

ai_trading/risk/metrics.py:266:16: BLE001 Do not catch blind exception: `Exception`
    |
264 |             return True, drawdown
265 | 
266 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
267 |             logger.error(f"Error checking drawdown status: {e}")
268 |             return False, 0.0
    |

ai_trading/risk/metrics.py:297:16: BLE001 Do not catch blind exception: `Exception`
    |
295 |             return None  # Not recovered yet
296 | 
297 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
298 |             logger.error(f"Error calculating recovery time: {e}")
299 |             return None
    |

ai_trading/risk/position_sizing.py:164:31: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
162 |         """
163 |         try:
164 |             if len(returns) < 10:
    |                               ^^ PLR2004
165 |                 logger.warning(
166 |                     f"Insufficient data for volatility calculation: {len(returns)} returns"
    |

ai_trading/risk/pre_trade_validation.py:145:16: BLE001 Do not catch blind exception: `Exception`
    |
143 |             )
144 | 
145 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
146 |             logger.error(f"Error validating market hours: {e}")
147 |             return ValidationResult(
    |

ai_trading/risk/pre_trade_validation.py:269:45: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
267 |                 score=liquidity_score,
268 |                 recommendations=(
269 |                     [] if liquidity_score > 0.8 else ["Monitor execution quality"]
    |                                             ^^^ PLR2004
270 |                 ),
271 |             )
    |

ai_trading/risk/pre_trade_validation.py:273:16: BLE001 Do not catch blind exception: `Exception`
    |
271 |             )
272 | 
273 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
274 |             logger.error(f"Error validating liquidity for {symbol}: {e}")
275 |             return ValidationResult(
    |

ai_trading/risk/pre_trade_validation.py:436:40: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
434 |                 warnings.append(f"Large position: {position_pct:.1%} of account")
435 | 
436 |             if portfolio_utilization > 0.8:
    |                                        ^^^ PLR2004
437 |                 warnings.append(
438 |                     f"High portfolio utilization: {portfolio_utilization:.1%}"
    |

ai_trading/risk/pre_trade_validation.py:461:16: BLE001 Do not catch blind exception: `Exception`
    |
459 |             )
460 | 
461 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
462 |             logger.error(f"Error validating position risk for {symbol}: {e}")
463 |             return ValidationResult(
    |

ai_trading/risk/pre_trade_validation.py:549:45: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
547 |                 score=portfolio_score,
548 |                 recommendations=(
549 |                     [] if portfolio_score > 0.7 else ["Monitor portfolio risk closely"]
    |                                             ^^^ PLR2004
550 |                 ),
551 |             )
    |

ai_trading/risk/pre_trade_validation.py:553:16: BLE001 Do not catch blind exception: `Exception`
    |
551 |             )
552 | 
553 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
554 |             logger.error(f"Error validating portfolio risk: {e}")
555 |             return ValidationResult(
    |

ai_trading/risk/pre_trade_validation.py:801:16: BLE001 Do not catch blind exception: `Exception`
    |
799 |             return final_result
800 | 
801 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
802 |             logger.error(f"Error in pre-trade validation: {e}")
803 |             return PreTradeCheckResult(
    |

ai_trading/risk/pre_trade_validation.py:832:16: BLE001 Do not catch blind exception: `Exception`
    |
830 |             )
831 | 
832 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
833 |             return ValidationResult(
834 |                 category=ValidationCategory.SYSTEM_HEALTH,
    |

ai_trading/rl_trading/__init__.py:12:8: BLE001 Do not catch blind exception: `Exception`
   |
10 |     from stable_baselines3 import PPO
11 |     from stable_baselines3.common.vec_env import DummyVecEnv
12 | except Exception:  # pragma: no cover - optional dependency
   |        ^^^^^^^^^ BLE001
13 |     PPO = None  # type: ignore
14 |     DummyVecEnv = None  # type: ignore
   |

ai_trading/rl_trading/__init__.py:82:16: BLE001 Do not catch blind exception: `Exception`
   |
80 |             side = {0: "hold", 1: "buy", 2: "sell"}.get(int(action), "hold")
81 |             return TradeSignal(symbol="RL", side=side, confidence=1.0, strategy="rl")
82 |         except Exception as exc:
   |                ^^^^^^^^^ BLE001
83 |             logger.error("RL prediction failed: %s", exc)
84 |             return None
   |

ai_trading/rl_trading/env.py:15:8: BLE001 Do not catch blind exception: `Exception`
   |
13 |     # Use the base Env class when gymnasium is available
14 |     EnvBase = gym.Env
15 | except Exception:  # pragma: no cover - optional dependency
   |        ^^^^^^^^^ BLE001
16 |     gym = None
   |

ai_trading/rl_trading/env.py:202:24: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
200 |                 self.position += 1
201 |                 self.cash -= exec_price * (1.0 + self.transaction_cost)
202 |         elif action == 2 and self.position > 0:  # Sell
    |                        ^ PLR2004
203 |             exec_price = price * (1 - self.half_spread - self.slippage)
204 |             self.position -= 1
    |

ai_trading/rl_trading/env.py:233:30: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
    |
231 |         trade_size = target_position - self.position
232 | 
233 |         if abs(trade_size) > 1e-6:  # Only trade if meaningful change
    |                              ^^^^ PLR2004
234 |             if trade_size > 0:  # Buying
235 |                 exec_price = price * (1 + self.half_spread + self.slippage)
    |

ai_trading/rl_trading/env.py:312:41: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
310 |         self._returns_history.append(returns)
311 | 
312 |         if len(self._returns_history) > 5:
    |                                         ^ PLR2004
313 |             rolling_variance = np.var(self._returns_history)
314 |             variance_penalty = self.reward_config.variance_penalty * rolling_variance
    |

ai_trading/rl_trading/env.py:319:41: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
318 |         # Sharpe ratio bonus
319 |         if len(self._returns_history) > 10:
    |                                         ^^ PLR2004
320 |             returns_array = np.array(self._returns_history)
321 |             sharpe_ratio = np.mean(returns_array) / (np.std(returns_array) + 1e-8)
    |

ai_trading/rl_trading/env.py:355:67: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
    |
353 |         )
354 |         self._episode_stats["turnover"] += trade_size
355 |         self._episode_stats["actions_taken"] += 1 if trade_size > 1e-6 else 0
    |                                                                   ^^^^ PLR2004
356 | 
357 |         # Calculate Sharpe ratio for episode
    |

ai_trading/rl_trading/inference.py:240:16: BLE001 Do not catch blind exception: `Exception`
    |
238 |             return signal
239 | 
240 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
241 |             self.logger.error(f"RL prediction failed: {e}")
242 |             return None
    |

ai_trading/rl_trading/tests/smoke_parity.py:148:12: BLE001 Do not catch blind exception: `Exception`
    |
146 |         logger.info(f"Skipping RL tests due to missing dependencies: {e}")
147 |         return True
148 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
149 |         logger.info(f"RL parity test failed: {e}")
150 |         return False
    |

ai_trading/rl_trading/tests/smoke_parity.py:201:12: BLE001 Do not catch blind exception: `Exception`
    |
199 |         return True
200 | 
201 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
202 |         logger.info(f"Reward normalization test failed: {e}")
203 |         return False
    |

ai_trading/rl_trading/train.py:262:45: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
260 |             """Calculate approximate Sharpe ratio from recent evaluations."""
261 |             try:
262 |                 if len(self.eval_results) < 2:
    |                                             ^ PLR2004
263 |                     return 0.0
    |

ai_trading/runtime/http_wrapped.py:28:16: BLE001 Do not catch blind exception: `Exception`
   |
26 |                 return json.loads(resp)
27 |             return resp
28 |         except Exception as exc:  # intentionally broad at boundary
   |                ^^^^^^^^^ BLE001
29 |             last_exc = exc
30 |             logger.debug("http retry %s/%s after %s", attempt, attempts, exc)
   |

ai_trading/safety/__init__.py:12:5: PLC0414 Import alias does not rename original package
   |
11 | from .monitoring import (
12 |     AlertSeverity as AlertSeverity,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
13 | )
14 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:15:5: PLC0414 Import alias does not rename original package
   |
13 | )
14 | from .monitoring import (
15 |     KillSwitch as KillSwitch,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
16 | )
17 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:18:5: PLC0414 Import alias does not rename original package
   |
16 | )
17 | from .monitoring import (
18 |     PerformanceMonitor as PerformanceMonitor,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
19 | )
20 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:21:5: PLC0414 Import alias does not rename original package
   |
19 | )
20 | from .monitoring import (
21 |     SafetyMonitor as SafetyMonitor,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
22 | )
23 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:24:5: PLC0414 Import alias does not rename original package
   |
22 | )
23 | from .monitoring import (
24 |     TradingState as TradingState,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
25 | )
26 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:27:5: PLC0414 Import alias does not rename original package
   |
25 | )
26 | from .monitoring import (
27 |     console_alert_callback as console_alert_callback,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
28 | )
29 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:30:5: PLC0414 Import alias does not rename original package
   |
28 | )
29 | from .monitoring import (
30 |     emergency_cancel_all_orders as emergency_cancel_all_orders,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
31 | )
32 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:33:5: PLC0414 Import alias does not rename original package
   |
31 | )
32 | from .monitoring import (
33 |     emergency_close_all_positions as emergency_close_all_positions,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
34 | )
35 | from .monitoring import (
   |
   = help: Remove import alias

ai_trading/safety/__init__.py:36:5: PLC0414 Import alias does not rename original package
   |
34 | )
35 | from .monitoring import (
36 |     file_alert_callback as file_alert_callback,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
37 | )
   |
   = help: Remove import alias

ai_trading/safety/monitoring.py:134:20: BLE001 Do not catch blind exception: `Exception`
    |
132 |             try:
133 |                 action(reason)
134 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
135 |                 logger.error(f"Error executing emergency action: {e}")
    |

ai_trading/safety/monitoring.py:296:74: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
294 |                 # Reset per-minute counters
295 |                 current_time = datetime.now(UTC)
296 |                 if (current_time - minute_reset_time).total_seconds() >= 60:
    |                                                                          ^^ PLR2004
297 |                     self.metrics["orders_this_minute"] = 0
298 |                     minute_reset_time = current_time
    |

ai_trading/safety/monitoring.py:317:20: BLE001 Do not catch blind exception: `Exception`
    |
315 |                 time.sleep(1)
316 | 
317 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
318 |                 logger.error(f"Error in monitoring loop: {e}")
319 |                 time.sleep(5)  # Back off on error
    |

ai_trading/safety/monitoring.py:344:20: BLE001 Do not catch blind exception: `Exception`
    |
342 |             try:
343 |                 callback(alert)
344 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
345 |                 logger.error(f"Error in alert callback: {e}")
    |

ai_trading/safety/monitoring.py:411:20: BLE001 Do not catch blind exception: `Exception`
    |
409 |                 time.sleep(1)
410 | 
411 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
412 |                 logger.error(f"Error in kill switch monitor: {e}")
413 |                 time.sleep(5)
    |

ai_trading/safety/monitoring.py:424:20: BLE001 Do not catch blind exception: `Exception`
    |
422 |             try:
423 |                 os.remove(self.kill_file_path)
424 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
425 |                 logger.error(f"Could not remove kill file: {e}")
426 |             return True
    |

ai_trading/safety/monitoring.py:460:49: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
459 |         # Keep only recent data
460 |         if len(self.metrics["order_latency"]) > 1000:
    |                                                 ^^^^ PLR2004
461 |             self.metrics["order_latency"] = self.metrics["order_latency"][-500:]
    |

ai_trading/safety/monitoring.py:484:42: E741 Ambiguous variable name: `l`
    |
483 |         # Calculate statistics
484 |         latencies = [l["latency_ms"] for l in self.metrics["order_latency"]]
    |                                          ^ E741
485 |         avg_latency = sum(latencies) / len(latencies) if latencies else 0
486 |         max_latency = max(latencies) if latencies else 0
    |

ai_trading/safety/monitoring.py:521:26: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
520 |         # Deduct for high latency
521 |         if avg_latency > 100:
    |                          ^^^ PLR2004
522 |             score -= 20
523 |         elif avg_latency > 50:
    |

ai_trading/safety/monitoring.py:523:28: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
521 |         if avg_latency > 100:
522 |             score -= 20
523 |         elif avg_latency > 50:
    |                            ^^ PLR2004
524 |             score -= 10
    |

ai_trading/safety/monitoring.py:529:29: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
527 |         if total_orders > 0:
528 |             error_rate = total_errors / total_orders
529 |             if error_rate > 0.05:  # 5% error rate
    |                             ^^^^ PLR2004
530 |                 score -= 30
531 |             elif error_rate > 0.01:  # 1% error rate
    |

ai_trading/safety/monitoring.py:531:31: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
529 |             if error_rate > 0.05:  # 5% error rate
530 |                 score -= 30
531 |             elif error_rate > 0.01:  # 1% error rate
    |                               ^^^^ PLR2004
532 |                 score -= 15
    |

ai_trading/safety/monitoring.py:534:21: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
532 |                 score -= 15
533 | 
534 |         if score >= 90:
    |                     ^^ PLR2004
535 |             return "A"
536 |         elif score >= 80:
    |

ai_trading/safety/monitoring.py:536:23: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
    |
534 |         if score >= 90:
535 |             return "A"
536 |         elif score >= 80:
    |                       ^^ PLR2004
537 |             return "B"
538 |         elif score >= 70:
    |

ai_trading/safety/monitoring.py:538:23: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
536 |         elif score >= 80:
537 |             return "B"
538 |         elif score >= 70:
    |                       ^^ PLR2004
539 |             return "C"
540 |         elif score >= 60:
    |

ai_trading/safety/monitoring.py:540:23: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
538 |         elif score >= 70:
539 |             return "C"
540 |         elif score >= 60:
    |                       ^^ PLR2004
541 |             return "D"
542 |         else:
    |

ai_trading/safety/monitoring.py:560:12: BLE001 Do not catch blind exception: `Exception`
    |
558 |         with open("trading_alerts.log", "a") as f:
559 |             f.write(f"{json.dumps(alert)}\n")
560 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
561 |         logger.error(f"Failed to write alert to file: {e}")
    |

ai_trading/scheduler/aligned_clock.py:15:8: BLE001 Do not catch blind exception: `Exception`
   |
13 | try:
14 |     import pandas_market_calendars as mcal  # optional
15 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
16 |     mcal = None
   |

ai_trading/scheduler/aligned_clock.py:27:12: BLE001 Do not catch blind exception: `Exception`
   |
25 |     try:
26 |         return mcal.get_calendar(cal_name)
27 |     except Exception as exc:  # pragma: no cover - best effort
   |            ^^^^^^^^^ BLE001
28 |         logger.warning(f"Failed to load {cal_name} calendar: {exc}")
29 |         return None
   |

ai_trading/scheduler/aligned_clock.py:83:20: BLE001 Do not catch blind exception: `Exception`
   |
81 |                 exchange_tz = self.calendar.tz
82 |                 return utc_now.astimezone(exchange_tz)
83 |             except Exception as e:
   |                    ^^^^^^^^^ BLE001
84 |                 self.logger.warning(
85 |                     f"Failed to get exchange time: {e.__class__.__name__}: {e}"
   |

ai_trading/scheduler/aligned_clock.py:116:32: PLR2004 Magic value used in comparison, consider replacing `1440` with a constant variable
    |
114 |         interval_minutes = self._parse_timeframe_minutes(timeframe)
115 | 
116 |         if interval_minutes >= 1440:  # Daily or longer
    |                                ^^^^ PLR2004
117 |             # Next market close
118 |             next_close = current_time.replace(
    |

ai_trading/scheduler/aligned_clock.py:158:20: BLE001 Do not catch blind exception: `Exception`
    |
156 |                         )
157 |                         next_close = next_close.replace(tzinfo=next_close.tzinfo)
158 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
159 |                 self.logger.warning(
160 |                     f"Calendar check failed: {e.__class__.__name__}: {e}"
    |

ai_trading/scheduler/aligned_clock.py:274:39: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
272 |         if not self.calendar:
273 |             # Fallback - assume market hours 9:30 AM - 4:00 PM EST weekdays
274 |             if timestamp.weekday() >= 5:  # Weekend
    |                                       ^ PLR2004
275 |                 return False
    |

ai_trading/scheduler/aligned_clock.py:300:16: BLE001 Do not catch blind exception: `Exception`
    |
298 |             return market_open <= timestamp <= market_close
299 | 
300 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
301 |             self.logger.warning(
302 |                 f"Market hours check failed: {e.__class__.__name__}: {e}"
    |

ai_trading/scheduler/aligned_clock.py:344:12: PLW0603 Using the global statement to update `_global_clock` is discouraged
    |
342 | def get_aligned_clock() -> AlignedClock:
343 |     """Get or create global aligned clock instance."""
344 |     global _global_clock
    |            ^^^^^^^^^^^^^ PLW0603
345 |     if _global_clock is None:
346 |         _global_clock = AlignedClock()
    |

ai_trading/scripts/self_check.py:26:12: BLE001 Do not catch blind exception: `Exception`
   |
24 |             "end": end,
25 |         }
26 |     except Exception:
   |            ^^^^^^^^^ BLE001
27 |         raise SystemExit(1)
   |

ai_trading/security.py:29:8: BLE001 Do not catch blind exception: `Exception`
   |
27 |     from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
28 |     _CRYPTOGRAPHY_AVAILABLE = True
29 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
30 |     _CRYPTOGRAPHY_AVAILABLE = False
31 |     class Fernet:  # type: ignore[override]
   |

ai_trading/security.py:146:16: BLE001 Do not catch blind exception: `Exception`
    |
144 |             key = base64.urlsafe_b64encode(kdf.derive(master_key_bytes))
145 |             return Fernet(key)
146 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
147 |             self.logger.error(f"Failed to initialize encryption: {e}")
148 |             return None
    |

ai_trading/security.py:180:16: BLE001 Do not catch blind exception: `Exception`
    |
178 |             encrypted = self._fernet.encrypt(value.encode())
179 |             return base64.urlsafe_b64encode(encrypted).decode()
180 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
181 |             self.logger.error(f"Encryption failed: {e}")
182 |             return value
    |

ai_trading/security.py:193:16: BLE001 Do not catch blind exception: `Exception`
    |
191 |             decrypted = self._fernet.decrypt(encrypted_bytes)
192 |             return decrypted.decode()
193 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
194 |             self.logger.error(f"Decryption failed: {e}")
195 |             return encrypted_value
    |

ai_trading/security.py:240:38: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
238 |     def _is_encrypted(self, value: str) -> bool:
239 |         """Check if a value appears to be encrypted."""
240 |         if not value or len(value) < 20:
    |                                      ^^ PLR2004
241 |             return False
    |

ai_trading/security.py:247:16: BLE001 Do not catch blind exception: `Exception`
    |
245 |             base64.urlsafe_b64decode(value.encode())
246 |             return True
247 |         except Exception:
    |                ^^^^^^^^^ BLE001
248 |             # Any decoding error means it's not a valid token
249 |             return False
    |

ai_trading/security.py:264:38: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
262 |     def _mask_string(self, value: str) -> str:
263 |         """Mask sensitive string values."""
264 |         if not value or len(value) < 4:
    |                                      ^ PLR2004
265 |             return "***"
    |

ai_trading/security.py:275:25: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
274 |         # Check for long alphanumeric strings (likely keys)
275 |         if len(value) > 20 and value.replace("-", "").replace("_", "").isalnum():
    |                         ^^ PLR2004
276 |             return f"{value[:4]}***{value[-4:]}"
    |

ai_trading/security.py:423:34: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
421 |     def validate_api_key(self, service: str, key: str) -> bool:
422 |         """Validate API key format and basic checks."""
423 |         if not key or len(key) < 10:
    |                                  ^^ PLR2004
424 |             return False
    |

ai_trading/security.py:428:43: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
426 |         # Service-specific validation
427 |         validation_rules = {
428 |             "alpaca": lambda k: len(k) >= 20 and k.replace("-", "").isalnum(),
    |                                           ^^ PLR2004
429 |             "news": lambda k: len(k) >= 32,
430 |             "finnhub": lambda k: len(k) >= 20,
    |

ai_trading/security.py:429:41: PLR2004 Magic value used in comparison, consider replacing `32` with a constant variable
    |
427 |         validation_rules = {
428 |             "alpaca": lambda k: len(k) >= 20 and k.replace("-", "").isalnum(),
429 |             "news": lambda k: len(k) >= 32,
    |                                         ^^ PLR2004
430 |             "finnhub": lambda k: len(k) >= 20,
431 |         }
    |

ai_trading/security.py:430:44: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
428 |             "alpaca": lambda k: len(k) >= 20 and k.replace("-", "").isalnum(),
429 |             "news": lambda k: len(k) >= 32,
430 |             "finnhub": lambda k: len(k) >= 20,
    |                                            ^^ PLR2004
431 |         }
    |

ai_trading/security.py:438:28: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
437 |         # Generic validation
438 |         return len(key) >= 20 and any(c.isalnum() for c in key)
    |                            ^^ PLR2004
439 | 
440 |     def mask_sensitive_data(self, payload: dict) -> dict:
    |

ai_trading/security.py:454:58: F821 Undefined name `timedelta`
    |
452 |                     e
453 |                     for e in self._security_events
454 |                     if e.timestamp > datetime.now(UTC) - timedelta(hours=24)
    |                                                          ^^^^^^^^^ F821
455 |                 ]
456 |             ),
    |

ai_trading/security.py:464:43: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
462 |         if not _CRYPTOGRAPHY_AVAILABLE:
463 |             critical_issues.append("Encryption library not available")
464 |         if self._failed_access_attempts > 10:
    |                                           ^^ PLR2004
465 |             critical_issues.append("High number of failed access attempts")
    |

ai_trading/security.py:499:16: BLE001 Do not catch blind exception: `Exception`
    |
498 |             return True
499 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
500 |             self.safe_logger.error(f"Failed to rotate encryption key: {e}")
501 |             return False
    |

ai_trading/security.py:514:12: PLW0603 Using the global statement to update `_security_manager` is discouraged
    |
512 | def get_security_manager() -> SecurityManager:
513 |     """Get or create global security manager instance."""
514 |     global _security_manager
    |            ^^^^^^^^^^^^^^^^^ PLW0603
515 |     if _security_manager is None:
516 |         _security_manager = SecurityManager()
    |

ai_trading/settings.py:18:8: BLE001 Do not catch blind exception: `Exception`
   |
16 | try:  # AI-AGENT-REF: tolerate pydantic internals missing
17 |     from pydantic.fields import FieldInfo
18 | except Exception:
   |        ^^^^^^^^^ BLE001
19 |     FieldInfo = object
   |

ai_trading/settings.py:285:12: BLE001 Do not catch blind exception: `Exception`
    |
283 |     try:
284 |         return int(val)
285 |     except Exception:  # AI-AGENT-REF: tolerate FieldInfo during early imports
    |            ^^^^^^^^^ BLE001
286 |         return 60
    |

ai_trading/settings.py:401:12: PLW0603 Using the global statement to update `DEFAULT_CONFIG` is discouraged
    |
399 | def ensure_default_config():
400 |     """Lazily initialize TradingConfig for backward compatibility."""
401 |     global DEFAULT_CONFIG, _DEFAULT_CONFIG
    |            ^^^^^^^^^^^^^^ PLW0603
402 |     if DEFAULT_CONFIG is None:
403 |         from ai_trading.config.management import TradingConfig
    |

ai_trading/settings.py:401:28: PLW0603 Using the global statement to update `_DEFAULT_CONFIG` is discouraged
    |
399 | def ensure_default_config():
400 |     """Lazily initialize TradingConfig for backward compatibility."""
401 |     global DEFAULT_CONFIG, _DEFAULT_CONFIG
    |                            ^^^^^^^^^^^^^^^ PLW0603
402 |     if DEFAULT_CONFIG is None:
403 |         from ai_trading.config.management import TradingConfig
    |

ai_trading/strategies/__init__.py:9:8: BLE001 Do not catch blind exception: `Exception`
   |
 7 | try:  # AI-AGENT-REF: lazy meta-learning import
 8 |     from .meta_learning import MetaLearning
 9 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
10 |     MetaLearning = None  # type: ignore
11 | from .base import StrategySignal as TradeSignal
   |

ai_trading/strategies/backtest.py:235:16: BLE001 Do not catch blind exception: `Exception`
    |
233 |             return results
234 | 
235 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
236 |             logger.error(f"Error running backtest: {e}")
237 |             return {"error": str(e)}
    |

ai_trading/strategies/backtest.py:310:34: F821 Undefined name `np`
    |
308 |                 volatility = abs(high_price - low_price) / close_price
309 |                 slippage_pct = (
310 |                     volatility * np.sqrt(position_size / max(volume, 1)) * 0.1
    |                                  ^^ F821
311 |                 )
312 |                 slippage_amount = min(0.01, slippage_pct)  # Cap at 1%
    |

ai_trading/strategies/backtest.py:331:20: F821 Undefined name `np`
    |
330 |                 # Simulate partial fill
331 |                 if np.random.random() > fill_prob:
    |                    ^^ F821
332 |                     actual_quantity = int(position_size * np.random.uniform(0.3, 0.9))
    |

ai_trading/strategies/backtest.py:332:59: F821 Undefined name `np`
    |
330 |                 # Simulate partial fill
331 |                 if np.random.random() > fill_prob:
332 |                     actual_quantity = int(position_size * np.random.uniform(0.3, 0.9))
    |                                                           ^^ F821
333 | 
334 |             # Step 5: Calculate latency effects
    |

ai_trading/strategies/backtest.py:338:32: F821 Undefined name `np`
    |
336 |             if self.microstructure_available and trade_timestamp:
337 |                 # Simulate latency impact (simplified)
338 |                 latency_cost = np.random.normal(0, 0.0001)  # Small random cost
    |                                ^^ F821
339 |                 execution_price *= 1 + latency_cost
    |

ai_trading/strategies/backtest.py:357:25: F821 Undefined name `np`
    |
355 |                 # This is simplified - real implementation would track positions
356 |                 exit_price = execution_price * (
357 |                     1 + np.random.normal(0, 0.02)
    |                         ^^ F821
358 |                 )  # Random exit
359 |                 gross_pnl = actual_quantity * (exit_price - execution_price)
    |

ai_trading/strategies/backtest.py:362:53: F821 Undefined name `np`
    |
360 |             else:
361 |                 # Short position
362 |                 exit_price = execution_price * (1 + np.random.normal(0, 0.02))
    |                                                     ^^ F821
363 |                 gross_pnl = actual_quantity * (execution_price - exit_price)
    |

ai_trading/strategies/backtest.py:406:16: BLE001 Do not catch blind exception: `Exception`
    |
404 |             }
405 | 
406 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
407 |             logger.error(f"Error simulating trade: {e}")
408 |             return {
    |

ai_trading/strategies/backtest.py:436:16: BLE001 Do not catch blind exception: `Exception`
    |
434 |             return max_dd
435 | 
436 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
437 |             logger.error(f"Error calculating max drawdown: {e}")
438 |             return 0.0
    |

ai_trading/strategies/backtest.py:474:16: BLE001 Do not catch blind exception: `Exception`
    |
472 |             return analysis
473 | 
474 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
475 |             logger.error(f"Error analyzing performance: {e}")
476 |             return {"error": str(e)}
    |

ai_trading/strategies/backtest.py:593:28: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
591 |         logging.info(f"Total cost drag: {cost_drag_bps:.1f} bps")
592 | 
593 |         if cost_drag_bps < 5.0:
    |                            ^^^ PLR2004
594 |             raise AssertionError(f"Cost drag ({cost_drag_bps:.1f} bps) seems too low")
    |

ai_trading/strategies/backtest.py:602:12: BLE001 Do not catch blind exception: `Exception`
    |
600 |         return True
601 | 
602 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
603 |         logging.error(f"✗ Backtest smoke test failed: {e}")
604 |         return False
    |

ai_trading/strategies/backtester.py:20:1: E402 Module level import not at top of file
   |
18 |   risk_engine_instance = get_risk_engine()
19 |   
20 | / from ai_trading import (
21 | |     config,
22 | |     signals,  # noqa: F401
23 | | )
   | |_^ E402
24 |   from ai_trading.core import bot_engine
25 |   from ai_trading.logging import get_logger
   |

ai_trading/strategies/backtester.py:24:1: E402 Module level import not at top of file
   |
22 |     signals,  # noqa: F401
23 | )
24 | from ai_trading.core import bot_engine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
25 | from ai_trading.logging import get_logger
   |

ai_trading/strategies/backtester.py:25:1: E402 Module level import not at top of file
   |
23 | )
24 | from ai_trading.core import bot_engine
25 | from ai_trading.logging import get_logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
26 | 
27 | logger = get_logger(__name__)
   |

ai_trading/strategies/backtester.py:194:20: BLE001 Do not catch blind exception: `Exception`
    |
192 |             try:
193 |                 bot_engine.apply_fill(fill)
194 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
195 |                 logger.debug("Failed to apply fill in backtester: %s", e)
196 |         qty = fill.order.qty if fill.order.side.lower() == "buy" else -fill.order.qty
    |

ai_trading/strategies/backtester.py:233:28: BLE001 Do not catch blind exception: `Exception`
    |
231 |                     try:
232 |                         bot_engine.update_market_data(sym, df.loc[ts])
233 |                     except Exception as e:
    |                            ^^^^^^^^^ BLE001
234 |                         logger.debug("Failed to update market data for %s: %s", sym, e)
235 |             orders = []
    |

ai_trading/strategies/backtester.py:239:24: BLE001 Do not catch blind exception: `Exception`
    |
237 |                 try:
238 |                     orders = bot_engine.next_cycle()
239 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
240 |                     logger.debug("Failed to execute next_cycle: %s", e)
241 |                     orders = []
    |

ai_trading/strategies/base.py:193:36: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
192 |             # Risk validation
193 |             if signal.risk_score > 0.8:  # High risk threshold
    |                                    ^^^ PLR2004
194 |                 logger.warning(f"High risk signal for {signal.symbol}: {signal.risk_score}")
195 |                 return False
    |

ai_trading/strategies/base.py:198:36: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
197 |             # Confidence validation
198 |             if signal.confidence < 0.3:  # Low confidence threshold
    |                                    ^^^ PLR2004
199 |                 logger.debug(f"Low confidence signal for {signal.symbol}: {signal.confidence}")
200 |                 return False
    |

ai_trading/strategies/base.py:204:16: BLE001 Do not catch blind exception: `Exception`
    |
202 |             return True
203 | 
204 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
205 |             logger.error(f"Error validating signal: {e}")
206 |             return False
    |

ai_trading/strategies/base.py:213:16: BLE001 Do not catch blind exception: `Exception`
    |
211 |             self.parameters.update(new_parameters)
212 |             logger.info(f"Strategy {self.name} parameters updated: {new_parameters}")
213 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
214 |             logger.error(f"Error updating strategy parameters: {e}")
    |

ai_trading/strategies/base.py:256:16: BLE001 Do not catch blind exception: `Exception`
    |
254 |                 self.max_drawdown = min(self.max_drawdown, return_pct)
255 | 
256 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
257 |             logger.error(f"Error updating performance: {e}")
    |

ai_trading/strategies/base.py:329:16: BLE001 Do not catch blind exception: `Exception`
    |
327 |             return True
328 | 
329 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
330 |             logger.error(f"Error registering strategy: {e}")
331 |             return False
    |

ai_trading/strategies/base.py:356:16: BLE001 Do not catch blind exception: `Exception`
    |
354 |             return True
355 | 
356 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
357 |             logger.error(f"Error unregistering strategy: {e}")
358 |             return False
    |

ai_trading/strategies/base.py:382:16: BLE001 Do not catch blind exception: `Exception`
    |
380 |             return True
381 | 
382 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
383 |             logger.error(f"Error activating strategy {strategy_id}: {e}")
384 |             return False
    |

ai_trading/strategies/base.py:406:16: BLE001 Do not catch blind exception: `Exception`
    |
404 |                 return False
405 | 
406 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
407 |             logger.error(f"Error deactivating strategy {strategy_id}: {e}")
408 |             return False
    |

ai_trading/strategies/base.py:443:20: BLE001 Do not catch blind exception: `Exception`
    |
441 |                         strategy.signals_generated += 1
442 | 
443 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
444 |                 logger.error(f"Error generating signals from strategy {strategy.name}: {e}")
    |

ai_trading/strategies/imports.py:25:1: E402 Module level import not at top of file
   |
24 | # TA library for optimized technical analysis - hard dependency
25 | import ta
   | ^^^^^^^^^ E402
26 | 
27 | TA_AVAILABLE = True
   |

ai_trading/strategies/metalearning.py:18:1: E402 Module level import not at top of file
   |
16 | # AI-AGENT-REF: Use centralized logger as per AGENTS.md
17 | # AI-AGENT-REF: Import dependencies - sklearn is a hard dependency
18 | import numpy as np
   | ^^^^^^^^^^^^^^^^^^ E402
19 | 
20 | from ai_trading.logging import logger
   |

ai_trading/strategies/metalearning.py:20:1: E402 Module level import not at top of file
   |
18 | import numpy as np
19 | 
20 | from ai_trading.logging import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
21 | 
22 | NUMPY_AVAILABLE = True
   |

ai_trading/strategies/metalearning.py:29:1: E402 Module level import not at top of file
   |
27 | # AI-AGENT-REF: Import data fetcher for historical data
28 | # Machine learning imports - sklearn is a hard dependency
29 | from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
30 | from sklearn.metrics import accuracy_score
31 | from sklearn.model_selection import train_test_split
   |

ai_trading/strategies/metalearning.py:30:1: E402 Module level import not at top of file
   |
28 | # Machine learning imports - sklearn is a hard dependency
29 | from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier
30 | from sklearn.metrics import accuracy_score
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
31 | from sklearn.model_selection import train_test_split
32 | from sklearn.preprocessing import StandardScaler
   |

ai_trading/strategies/metalearning.py:31:1: E402 Module level import not at top of file
   |
29 | from sklearn.ensemble import GradientBoostingClassifier, RandomForestClassifier
30 | from sklearn.metrics import accuracy_score
31 | from sklearn.model_selection import train_test_split
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
32 | from sklearn.preprocessing import StandardScaler
   |

ai_trading/strategies/metalearning.py:32:1: E402 Module level import not at top of file
   |
30 | from sklearn.metrics import accuracy_score
31 | from sklearn.model_selection import train_test_split
32 | from sklearn.preprocessing import StandardScaler
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 | 
34 | from ai_trading.data_fetcher import get_minute_df  # type: ignore
   |

ai_trading/strategies/metalearning.py:34:1: E402 Module level import not at top of file
   |
32 | from sklearn.preprocessing import StandardScaler
33 | 
34 | from ai_trading.data_fetcher import get_minute_df  # type: ignore
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
35 | 
36 | # AI-AGENT-REF: Import base strategy framework
   |

ai_trading/strategies/metalearning.py:37:1: E402 Module level import not at top of file
   |
36 | # AI-AGENT-REF: Import base strategy framework
37 | from ..core.enums import OrderSide, RiskLevel
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
38 | from .base import BaseStrategy, StrategySignal
   |

ai_trading/strategies/metalearning.py:38:1: E402 Module level import not at top of file
   |
36 | # AI-AGENT-REF: Import base strategy framework
37 | from ..core.enums import OrderSide, RiskLevel
38 | from .base import BaseStrategy, StrategySignal
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
39 | 
40 | ML_AVAILABLE = True
   |

ai_trading/strategies/metalearning.py:94:9: PLR0911 Too many return statements (8 > 6)
   |
92 |         logger.info(f"MetaLearning strategy initialized with risk level {risk_level}")
93 | 
94 |     def execute_strategy(self, data=None, symbol: str = None) -> dict:
   |         ^^^^^^^^^^^^^^^^ PLR0911
95 |         """
96 |         Main execution method called by bot_engine.
   |

ai_trading/strategies/metalearning.py:272:9: PLR0911 Too many return statements (7 > 6)
    |
270 |             return 0
271 | 
272 |     def train_model(self, data) -> bool:
    |         ^^^^^^^^^^^ PLR0911
273 |         """
274 |         Train ML models on historical data.
    |

ai_trading/strategies/metalearning.py:325:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
324 |             # Ensure minimum class diversity for ML training
325 |             if len(unique_classes) < 2:
    |                                      ^ PLR2004
326 |                 logger.error(
327 |                     f"Insufficient class diversity for ML training: only {len(unique_classes)} class(es)"
    |

ai_trading/strategies/metalearning.py:334:34: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
332 |             min_class_size = min(class_counts.values)
333 |             if (
334 |                 min_class_size < 3
    |                                  ^ PLR2004
335 |             ):  # Need at least 3 samples per class for train/test split
336 |                 logger.warning(
    |

ai_trading/strategies/metalearning.py:414:9: PLR0911 Too many return statements (8 > 6)
    |
412 |             return True  # Return True to allow fallback operation
413 | 
414 |     def predict_price_movement(self, data) -> dict | None:
    |         ^^^^^^^^^^^^^^^^^^^^^^ PLR0911
415 |         """
416 |         Generate ML-based price movement predictions.
    |

ai_trading/strategies/metalearning.py:473:60: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
471 |             if not NUMPY_AVAILABLE:
472 |                 # Fallback for when numpy is not available
473 |                 predicted_class = 0 if ensemble_proba[0] > 0.5 else 1
    |                                                            ^^^ PLR2004
474 |                 confidence = max(ensemble_proba)
475 |             else:
    |

ai_trading/strategies/metalearning.py:480:29: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
479 |             # Map prediction to direction - handle variable number of classes
480 |             if n_classes == 2:
    |                             ^ PLR2004
481 |                 # Binary classification: 0=sell/hold, 1=buy
482 |                 direction_map = {0: "sell", 1: "buy"}
    |

ai_trading/strategies/metalearning.py:488:31: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
486 |                     "buy": float(ensemble_proba[1]),
487 |                 }
488 |             elif n_classes >= 3:
    |                               ^ PLR2004
489 |                 # Multi-class: 0=sell, 1=hold, 2=buy
490 |                 direction_map = {0: "sell", 1: "hold", 2: "buy"}
    |

ai_trading/strategies/metalearning.py:494:78: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
492 |                     "sell": float(ensemble_proba[0]),
493 |                     "hold": float(ensemble_proba[1]),
494 |                     "buy": float(ensemble_proba[2]) if len(ensemble_proba) > 2 else 0.0,
    |                                                                              ^ PLR2004
495 |                 }
496 |             else:
    |

ai_trading/strategies/metalearning.py:601:59: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
599 |             # AI-AGENT-REF: Enhanced technical indicators for better signal diversity
600 |             # Add RSI-based signals
601 |             features["rsi_oversold"] = (features["rsi"] < 30).astype(int)
    |                                                           ^^ PLR2004
602 |             features["rsi_overbought"] = (features["rsi"] > 70).astype(int)
603 |             features["rsi_momentum"] = features["rsi"].diff()
    |

ai_trading/strategies/metalearning.py:602:61: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
600 |             # Add RSI-based signals
601 |             features["rsi_oversold"] = (features["rsi"] < 30).astype(int)
602 |             features["rsi_overbought"] = (features["rsi"] > 70).astype(int)
    |                                                             ^^ PLR2004
603 |             features["rsi_momentum"] = features["rsi"].diff()
    |

ai_trading/strategies/metalearning.py:754:38: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
753 |             # Ensure we have at least 2 classes for ML training
754 |             if len(unique_classes) < 2:
    |                                      ^ PLR2004
755 |                 logger.warning(
756 |                     "Only 1 class detected after labeling - using fallback strategy"
    |

ai_trading/strategies/metalearning.py:774:43: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
772 |                     .index
773 |                 )
774 |                 if len(sorted_indices) >= 6:  # Need minimum samples
    |                                           ^ PLR2004
775 |                     # Bottom third = sell
776 |                     fallback_labels.loc[sorted_indices[:third]] = 0
    |

ai_trading/strategies/metalearning.py:912:22: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
910 |             # RSI signal
911 |             rsi = latest_features.get("rsi", 50)
912 |             if rsi < 30:  # Oversold
    |                      ^^ PLR2004
913 |                 signals.append("buy")
914 |                 confidences.append(min(0.8, (30 - rsi) / 30))
    |

ai_trading/strategies/metalearning.py:915:24: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
913 |                 signals.append("buy")
914 |                 confidences.append(min(0.8, (30 - rsi) / 30))
915 |             elif rsi > 70:  # Overbought
    |                        ^^ PLR2004
916 |                 signals.append("sell")
917 |                 confidences.append(min(0.8, (rsi - 70) / 30))
    |

ai_trading/strategies/metalearning.py:951:29: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
949 |             # Momentum analysis
950 |             momentum_5 = latest_features.get("momentum_5", 0)
951 |             if momentum_5 > 0.01:  # 1% positive momentum
    |                             ^^^^ PLR2004
952 |                 signals.append("buy")
953 |                 confidences.append(min(0.7, momentum_5 * 20))
    |

ai_trading/strategies/metalearning.py:954:31: PLR2004 Magic value used in comparison, consider replacing `-0.01` with a constant variable
    |
952 |                 signals.append("buy")
953 |                 confidences.append(min(0.7, momentum_5 * 20))
954 |             elif momentum_5 < -0.01:  # 1% negative momentum
    |                               ^^^^^ PLR2004
955 |                 signals.append("sell")
956 |                 confidences.append(min(0.7, abs(momentum_5) * 20))
    |

ai_trading/strategies/metalearning.py:1039:33: PLR2004 Magic value used in comparison, consider replacing `0.005` with a constant variable
     |
1038 |             # Determine direction based on recent momentum
1039 |             if recent_returns > 0.005:  # 0.5% positive momentum
     |                                 ^^^^^ PLR2004
1040 |                 direction = "buy"
1041 |                 confidence = min(0.7, abs(recent_returns) * 100)
     |

ai_trading/strategies/metalearning.py:1042:35: PLR2004 Magic value used in comparison, consider replacing `-0.005` with a constant variable
     |
1040 |                 direction = "buy"
1041 |                 confidence = min(0.7, abs(recent_returns) * 100)
1042 |             elif recent_returns < -0.005:  # 0.5% negative momentum
     |                                   ^^^^^^ PLR2004
1043 |                 direction = "sell"
1044 |                 confidence = min(0.7, abs(recent_returns) * 100)
     |

ai_trading/strategies/moving_average_crossover.py:26:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
25 |     def _latest_cross(self, short: pd.Series, long: pd.Series) -> str | None:
26 |         if len(short) < 2 or len(long) < 2:
   |                         ^ PLR2004
27 |             return None
28 |         s_prev, s_now = short.iloc[-2], short.iloc[-1]
   |

ai_trading/strategies/moving_average_crossover.py:26:42: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
25 |     def _latest_cross(self, short: pd.Series, long: pd.Series) -> str | None:
26 |         if len(short) < 2 or len(long) < 2:
   |                                          ^ PLR2004
27 |             return None
28 |         s_prev, s_now = short.iloc[-2], short.iloc[-1]
   |

ai_trading/strategies/multi_timeframe.py:257:28: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
255 |             signals = []
256 | 
257 |             if len(data) < 20:
    |                            ^^ PLR2004
258 |                 logger.warning(
259 |                     f"Insufficient data for {symbol} {timeframe.value}: {len(data)} bars"
    |

ai_trading/strategies/multi_timeframe.py:346:53: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
344 |                 ema_strength = (
345 |                     SignalStrength.STRONG
346 |                     if (ema_12 - ema_26) / ema_26 > 0.01
    |                                                     ^^^^ PLR2004
347 |                     else SignalStrength.WEAK
348 |                 )
    |

ai_trading/strategies/multi_timeframe.py:353:53: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
351 |                 ema_strength = (
352 |                     SignalStrength.STRONG
353 |                     if (ema_26 - ema_12) / ema_26 > 0.01
    |                                                     ^^^^ PLR2004
354 |                     else SignalStrength.WEAK
355 |                 )
    |

ai_trading/strategies/multi_timeframe.py:397:29: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
396 |             # RSI signals
397 |             if latest_rsi > 70:
    |                             ^^ PLR2004
398 |                 direction = SignalDirection.BEARISH
399 |                 strength = (
    |

ai_trading/strategies/multi_timeframe.py:401:37: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
    |
399 |                 strength = (
400 |                     SignalStrength.VERY_STRONG
401 |                     if latest_rsi > 80
    |                                     ^^ PLR2004
402 |                     else SignalStrength.STRONG
403 |                 )
    |

ai_trading/strategies/multi_timeframe.py:405:31: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
403 |                 )
404 |                 confidence = min(0.9, (latest_rsi - 70) / 20 + 0.5)
405 |             elif latest_rsi < 30:
    |                               ^^ PLR2004
406 |                 direction = SignalDirection.BULLISH
407 |                 strength = (
    |

ai_trading/strategies/multi_timeframe.py:409:37: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
407 |                 strength = (
408 |                     SignalStrength.VERY_STRONG
409 |                     if latest_rsi < 20
    |                                     ^^ PLR2004
410 |                     else SignalStrength.STRONG
411 |                 )
    |

ai_trading/strategies/multi_timeframe.py:520:30: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
518 |             bb_position = (latest_price - bb_lower) / (bb_upper - bb_lower)
519 | 
520 |             if bb_position > 0.8:
    |                              ^^^ PLR2004
521 |                 direction = SignalDirection.BEARISH
522 |                 strength = (
    |

ai_trading/strategies/multi_timeframe.py:523:60: PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
    |
521 |                 direction = SignalDirection.BEARISH
522 |                 strength = (
523 |                     SignalStrength.STRONG if bb_position > 0.95 else SignalStrength.WEAK
    |                                                            ^^^^ PLR2004
524 |                 )
525 |                 confidence = min(0.8, bb_position)
    |

ai_trading/strategies/multi_timeframe.py:526:32: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
524 |                 )
525 |                 confidence = min(0.8, bb_position)
526 |             elif bb_position < 0.2:
    |                                ^^^ PLR2004
527 |                 direction = SignalDirection.BULLISH
528 |                 strength = (
    |

ai_trading/strategies/multi_timeframe.py:529:60: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
527 |                 direction = SignalDirection.BULLISH
528 |                 strength = (
529 |                     SignalStrength.STRONG if bb_position < 0.05 else SignalStrength.WEAK
    |                                                            ^^^^ PLR2004
530 |                 )
531 |                 confidence = min(0.8, 1 - bb_position)
    |

ai_trading/strategies/multi_timeframe.py:580:31: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
579 |             # Volume confirmation signals
580 |             if volume_ratio > 1.5:
    |                               ^^^ PLR2004
581 |                 # High volume - confirms price movement
582 |                 price_change = (data["close"].iloc[-1] - data["close"].iloc[-2]) / data[
    |

ai_trading/strategies/multi_timeframe.py:585:35: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
583 |                     "close"
584 |                 ].iloc[-2]
585 |                 if price_change > 0.01:
    |                                   ^^^^ PLR2004
586 |                     direction = SignalDirection.BULLISH
587 |                 elif price_change < -0.01:
    |

ai_trading/strategies/multi_timeframe.py:587:37: PLR2004 Magic value used in comparison, consider replacing `-0.01` with a constant variable
    |
585 |                 if price_change > 0.01:
586 |                     direction = SignalDirection.BULLISH
587 |                 elif price_change < -0.01:
    |                                     ^^^^^ PLR2004
588 |                     direction = SignalDirection.BEARISH
589 |                 else:
    |

ai_trading/strategies/multi_timeframe.py:593:61: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
592 |                 strength = (
593 |                     SignalStrength.STRONG if volume_ratio > 2.0 else SignalStrength.WEAK
    |                                                             ^^^ PLR2004
594 |                 )
595 |                 confidence = min(0.7, volume_ratio / 3.0)
    |

ai_trading/strategies/multi_timeframe.py:744:36: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
743 |             # Alignment strength
744 |             if overall_alignment > 0.8:
    |                                    ^^^ PLR2004
745 |                 alignment_strength = "very_strong"
746 |             elif overall_alignment > 0.6:
    |

ai_trading/strategies/multi_timeframe.py:746:38: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
744 |             if overall_alignment > 0.8:
745 |                 alignment_strength = "very_strong"
746 |             elif overall_alignment > 0.6:
    |                                      ^^^ PLR2004
747 |                 alignment_strength = "strong"
748 |             elif overall_alignment > 0.4:
    |

ai_trading/strategies/multi_timeframe.py:748:38: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
746 |             elif overall_alignment > 0.6:
747 |                 alignment_strength = "strong"
748 |             elif overall_alignment > 0.4:
    |                                      ^^^ PLR2004
749 |                 alignment_strength = "moderate"
750 |             else:
    |

ai_trading/strategies/multi_timeframe.py:773:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
771 |         """Calculate alignment score for a specific indicator across timeframes."""
772 |         try:
773 |             if len(tf_signals) < 2:
    |                                  ^ PLR2004
774 |                 return 1.0  # Perfect alignment if only one timeframe
    |

ai_trading/strategies/multi_timeframe.py:816:32: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
815 |             # Action determination
816 |             if overall_score > 2.0 and alignment > 0.6:
    |                                ^^^ PLR2004
817 |                 recommendation["action"] = "BUY"
818 |                 recommendation["confidence"] = min(
    |

ai_trading/strategies/multi_timeframe.py:816:52: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
815 |             # Action determination
816 |             if overall_score > 2.0 and alignment > 0.6:
    |                                                    ^^^ PLR2004
817 |                 recommendation["action"] = "BUY"
818 |                 recommendation["confidence"] = min(
    |

ai_trading/strategies/multi_timeframe.py:825:34: PLR2004 Magic value used in comparison, consider replacing `-2.0` with a constant variable
    |
823 |                 )
824 | 
825 |             elif overall_score < -2.0 and alignment > 0.6:
    |                                  ^^^^ PLR2004
826 |                 recommendation["action"] = "SELL"
827 |                 recommendation["confidence"] = min(
    |

ai_trading/strategies/multi_timeframe.py:825:55: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
823 |                 )
824 | 
825 |             elif overall_score < -2.0 and alignment > 0.6:
    |                                                       ^^^ PLR2004
826 |                 recommendation["action"] = "SELL"
827 |                 recommendation["confidence"] = min(
    |

ai_trading/strategies/multi_timeframe.py:850:28: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
849 |             # Risk level assessment
850 |             if alignment < 0.4:
    |                            ^^^ PLR2004
851 |                 recommendation["risk_level"] = "high"
852 |                 recommendation["warnings"].append("Low signal alignment increases risk")
    |

ai_trading/strategies/multi_timeframe.py:855:35: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
853 |                 recommendation["position_size_multiplier"] = 0.5
854 | 
855 |             elif avg_confidence < 0.5:
    |                                   ^^^ PLR2004
856 |                 recommendation["risk_level"] = "medium_high"
857 |                 recommendation["warnings"].append("Low average confidence")
    |

ai_trading/strategies/multi_timeframe.py:893:51: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
892 |             # Keep only last 100 entries
893 |             if len(self.signal_history[symbol]) > 100:
    |                                                   ^^^ PLR2004
894 |                 self.signal_history[symbol] = self.signal_history[symbol][-100:]
    |

ai_trading/strategies/multi_timeframe.py:906:55: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
904 |             if (
905 |                 symbol not in self.signal_history
906 |                 or len(self.signal_history[symbol]) < 2
    |                                                       ^ PLR2004
907 |             ):
908 |                 return {"error": "Insufficient history"}
    |

ai_trading/strategies/multi_timeframe.py:928:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
926 |                     scores.append(avg_score)
927 | 
928 |             if len(scores) < 2:
    |                              ^ PLR2004
929 |                 return {"error": "Insufficient score data"}
    |

ai_trading/strategies/performance_allocator.py:38:12: BLE001 Do not catch blind exception: `Exception`
   |
36 |             if 0.0 <= v <= 1.0:
37 |                 return v
38 |     except Exception:
   |            ^^^^^^^^^ BLE001
39 |         pass
40 |     s = get_settings()
   |

ai_trading/strategies/performance_allocator.py:50:16: BLE001 Do not catch blind exception: `Exception`
   |
48 |                 if 0.0 <= x <= 1.0:
49 |                     return x
50 |         except Exception:
   |                ^^^^^^^^^ BLE001
51 |             continue
52 |     return 0.60
   |

ai_trading/strategies/performance_allocator.py:153:24: BLE001 Do not catch blind exception: `Exception`
    |
151 |                 try:
152 |                     c = float(getattr(s_, "confidence", 0.0))
153 |                 except Exception:
    |                        ^^^^^^^^^ BLE001
154 |                     c = 0.0
155 |                 if c >= th:
    |

ai_trading/strategies/performance_allocator.py:160:32: BLE001 Do not catch blind exception: `Exception`
    |
158 |                         try:
159 |                             base = float(getattr(s_, "weight", 1.0))
160 |                         except Exception:
    |                                ^^^^^^^^^ BLE001
161 |                             base = 1.0
162 |                         s_.weight = base * m
    |

ai_trading/strategies/performance_allocator.py:230:16: BLE001 Do not catch blind exception: `Exception`
    |
228 |             logger.warning("Failed to record trade result for strategy %s: %s", strategy_name, e,
229 |                           extra={"component": "performance_allocator", "strategy": strategy_name, "error_type": "trade_record"})
230 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
231 |             logger.error("Unexpected error recording trade for strategy %s: %s", strategy_name, e,
232 |                         extra={"component": "performance_allocator", "strategy": strategy_name, "error_type": "unexpected"})
    |

ai_trading/strategies/performance_allocator.py:281:16: BLE001 Do not catch blind exception: `Exception`
    |
279 |             return allocations
280 | 
281 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
282 |             logger.error("Strategy allocation calculation failed: %s", e,
283 |                         extra={"component": "performance_allocator", "error_type": "allocation"})
    |

ai_trading/strategies/performance_allocator.py:304:37: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
302 |             recent_trades = [t for t in trades if t['timestamp'] >= cutoff_date]
303 | 
304 |             if len(recent_trades) < 3:  # Need minimum recent activity
    |                                     ^ PLR2004
305 |                 return 0.3  # Below average for inactive strategies
    |

ai_trading/strategies/performance_allocator.py:354:16: BLE001 Do not catch blind exception: `Exception`
    |
352 |             logger.warning("Performance calculation failed for strategy %s: %s", strategy_name, e)
353 |             return 0.3  # Below average for calculation errors
354 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
355 |             logger.error("Unexpected error calculating performance for strategy %s: %s", strategy_name, e)
356 |             return 0.3
    |

ai_trading/strategies/performance_allocator.py:467:16: BLE001 Do not catch blind exception: `Exception`
    |
465 |             return report
466 | 
467 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
468 |             logger.error("Performance report generation failed for strategy %s: %s", strategy_name, e)
469 |             return {
    |

ai_trading/strategies/performance_allocator.py:480:38: PLR2004 Magic value used in comparison, consider replacing `24` with a constant variable
    |
478 |             hours_since_update = (datetime.now(UTC) - self.last_update).total_seconds() / 3600
479 | 
480 |             if hours_since_update >= 24:  # Daily rebalancing
    |                                      ^^ PLR2004
481 |                 return True
    |

ai_trading/strategies/performance_allocator.py:484:49: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
483 |             # Check for significant performance divergence
484 |             if len(self.strategy_allocations) < 2:
    |                                                 ^ PLR2004
485 |                 return False
    |

ai_trading/strategies/performance_allocator.py:503:16: BLE001 Do not catch blind exception: `Exception`
    |
501 |             return rank_changes >= significant_change_threshold
502 | 
503 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
504 |             logger.warning("Rebalance decision failed: %s", e)
505 |             return False  # Conservative - don't rebalance on errors
    |

ai_trading/strategies/regime_detection.py:110:35: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
108 |         """
109 |         try:
110 |             if len(market_data) < 50:
    |                                   ^^ PLR2004
111 |                 logger.warning(
112 |                     f"Insufficient data for regime detection: {len(market_data)} bars"
    |

ai_trading/strategies/regime_detection.py:176:33: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
174 |             returns_1m = (
175 |                 (data["close"].iloc[-1] / data["close"].iloc[-21] - 1)
176 |                 if len(data) >= 21
    |                                 ^^ PLR2004
177 |                 else 0
178 |             )
    |

ai_trading/strategies/regime_detection.py:181:33: PLR2004 Magic value used in comparison, consider replacing `63` with a constant variable
    |
179 |             returns_3m = (
180 |                 (data["close"].iloc[-1] / data["close"].iloc[-63] - 1)
181 |                 if len(data) >= 63
    |                                 ^^ PLR2004
182 |                 else 0
183 |             )
    |

ai_trading/strategies/regime_detection.py:186:33: PLR2004 Magic value used in comparison, consider replacing `126` with a constant variable
    |
184 |             returns_6m = (
185 |                 (data["close"].iloc[-1] / data["close"].iloc[-126] - 1)
186 |                 if len(data) >= 126
    |                                 ^^^ PLR2004
187 |                 else 0
188 |             )
    |

ai_trading/strategies/regime_detection.py:191:33: PLR2004 Magic value used in comparison, consider replacing `252` with a constant variable
    |
189 |             returns_12m = (
190 |                 (data["close"].iloc[-1] / data["close"].iloc[-252] - 1)
191 |                 if len(data) >= 252
    |                                 ^^^ PLR2004
192 |                 else 0
193 |             )
    |

ai_trading/strategies/regime_detection.py:254:79: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
252 |             # Different volatility measures
253 |             vol_10d = (
254 |                 data["returns"].tail(10).std() * np.sqrt(252) if len(data) >= 10 else 0
    |                                                                               ^^ PLR2004
255 |             )
256 |             vol_30d = (
    |

ai_trading/strategies/regime_detection.py:257:79: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
255 |             )
256 |             vol_30d = (
257 |                 data["returns"].tail(30).std() * np.sqrt(252) if len(data) >= 30 else 0
    |                                                                               ^^ PLR2004
258 |             )
259 |             vol_60d = (
    |

ai_trading/strategies/regime_detection.py:260:79: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
258 |             )
259 |             vol_60d = (
260 |                 data["returns"].tail(60).std() * np.sqrt(252) if len(data) >= 60 else 0
    |                                                                               ^^ PLR2004
261 |             )
262 |             vol_252d = (
    |

ai_trading/strategies/regime_detection.py:264:33: PLR2004 Magic value used in comparison, consider replacing `252` with a constant variable
    |
262 |             vol_252d = (
263 |                 data["returns"].tail(252).std() * np.sqrt(252)
264 |                 if len(data) >= 252
    |                                 ^^^ PLR2004
265 |                 else 0
266 |             )
    |

ai_trading/strategies/regime_detection.py:276:80: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
    |
274 |             )
275 |             atr = (
276 |                 data["true_range"].rolling(14).mean().iloc[-1] if len(data) >= 14 else 0
    |                                                                                ^^ PLR2004
277 |             )
    |

ai_trading/strategies/regime_detection.py:300:74: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
298 |             returns_squared = data["returns"] ** 2
299 |             vol_clustering = (
300 |                 returns_squared.tail(20).autocorr(lag=1) if len(data) >= 21 else 0
    |                                                                          ^^ PLR2004
301 |             )
    |

ai_trading/strategies/regime_detection.py:349:30: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
348 |             # Momentum classification
349 |             if current_rsi > 70 and current_macd > current_signal:
    |                              ^^ PLR2004
350 |                 momentum_state = "overbought_bullish"
351 |             elif current_rsi < 30 and current_macd < current_signal:
    |

ai_trading/strategies/regime_detection.py:351:32: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
349 |             if current_rsi > 70 and current_macd > current_signal:
350 |                 momentum_state = "overbought_bullish"
351 |             elif current_rsi < 30 and current_macd < current_signal:
    |                                ^^ PLR2004
352 |                 momentum_state = "oversold_bearish"
353 |             elif current_rsi > 50 and current_macd > current_signal:
    |

ai_trading/strategies/regime_detection.py:353:32: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
351 |             elif current_rsi < 30 and current_macd < current_signal:
352 |                 momentum_state = "oversold_bearish"
353 |             elif current_rsi > 50 and current_macd > current_signal:
    |                                ^^ PLR2004
354 |                 momentum_state = "bullish"
355 |             elif current_rsi < 50 and current_macd < current_signal:
    |

ai_trading/strategies/regime_detection.py:355:32: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
353 |             elif current_rsi > 50 and current_macd > current_signal:
354 |                 momentum_state = "bullish"
355 |             elif current_rsi < 50 and current_macd < current_signal:
    |                                ^^ PLR2004
356 |                 momentum_state = "bearish"
357 |             else:
    |

ai_trading/strategies/regime_detection.py:363:33: PLR2004 Magic value used in comparison, consider replacing `11` with a constant variable
    |
361 |             roc_10 = (
362 |                 (data["close"].iloc[-1] / data["close"].iloc[-11] - 1)
363 |                 if len(data) >= 11
    |                                 ^^ PLR2004
364 |                 else 0
365 |             )
    |

ai_trading/strategies/regime_detection.py:368:33: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
366 |             roc_20 = (
367 |                 (data["close"].iloc[-1] / data["close"].iloc[-21] - 1)
368 |                 if len(data) >= 21
    |                                 ^^ PLR2004
369 |                 else 0
370 |             )
    |

ai_trading/strategies/regime_detection.py:438:29: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
437 |             obv_trend = "neutral"
438 |             if len(data) >= 20:
    |                             ^^ PLR2004
439 |                 obv_20_ago = data["obv"].iloc[-21]
440 |                 obv_current = data["obv"].iloc[-1]
    |

ai_trading/strategies/regime_detection.py:454:42: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
452 |                 "volume_strength": (
453 |                     "high"
454 |                     if volume_ratio_20 > 1.5
    |                                          ^^^ PLR2004
455 |                     else "normal" if volume_ratio_20 > 0.8 else "low"
456 |                 ),
    |

ai_trading/strategies/regime_detection.py:455:56: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
453 |                     "high"
454 |                     if volume_ratio_20 > 1.5
455 |                     else "normal" if volume_ratio_20 > 0.8 else "low"
    |                                                        ^^^ PLR2004
456 |                 ),
457 |             }
    |

ai_trading/strategies/regime_detection.py:494:26: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
    |
492 |                 sentiment_analysis["put_call_ratio"] = pcr
493 | 
494 |                 if pcr > 1.2:
    |                          ^^^ PLR2004
495 |                     sentiment_analysis["sentiment_score"] = "bearish"
496 |                 elif pcr < 0.8:
    |

ai_trading/strategies/regime_detection.py:496:28: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
494 |                 if pcr > 1.2:
495 |                     sentiment_analysis["sentiment_score"] = "bearish"
496 |                 elif pcr < 0.8:
    |                            ^^^ PLR2004
497 |                     sentiment_analysis["sentiment_score"] = "bullish"
498 |                 else:
    |

ai_trading/strategies/regime_detection.py:512:9: PLR0911 Too many return statements (8 > 6)
    |
510 |             return {"sentiment_score": "neutral"}
511 | 
512 |     def _determine_primary_regime(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
513 |         self, trend_analysis: dict, volatility_analysis: dict, momentum_analysis: dict
514 |     ) -> MarketRegime:
    |

ai_trading/strategies/regime_detection.py:524:76: PLR2004 Magic value used in comparison, consider replacing `-0.15` with a constant variable
    |
523 |             # Crisis detection (extreme volatility + significant losses)
524 |             if vol_regime == VolatilityRegime.EXTREME_VOL and returns_6m < -0.15:
    |                                                                            ^^^^^ PLR2004
525 |                 return MarketRegime.CRISIS
    |

ai_trading/strategies/regime_detection.py:551:34: PLR2004 Magic value used in comparison, consider replacing `-0.05` with a constant variable
    |
549 |                 trend_direction == "bullish"
550 |                 and momentum_state == "bullish"
551 |                 and returns_6m > -0.05
    |                                  ^^^^^ PLR2004
552 |                 and returns_6m < 0.10
553 |             ):
    |

ai_trading/strategies/regime_detection.py:552:34: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
550 |                 and momentum_state == "bullish"
551 |                 and returns_6m > -0.05
552 |                 and returns_6m < 0.10
    |                                  ^^^^ PLR2004
553 |             ):
554 |                 return MarketRegime.RECOVERY
    |

ai_trading/strategies/regime_detection.py:664:43: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
662 |         """Analyze probability of regime transitions."""
663 |         try:
664 |             if len(self.regime_history) < 10:
    |                                           ^^ PLR2004
665 |                 return {"transition_probability": 0.1, "next_likely_regime": "unknown"}
    |

ai_trading/strategies/regime_detection.py:675:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
673 |             # If many regime changes recently, higher transition probability
674 |             regime_changes = len(unique_regimes)
675 |             if regime_changes > 3:
    |                                 ^ PLR2004
676 |                 transition_prob = 0.4  # High probability of change
677 |             elif regime_changes > 2:
    |

ai_trading/strategies/regime_detection.py:677:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
675 |             if regime_changes > 3:
676 |                 transition_prob = 0.4  # High probability of change
677 |             elif regime_changes > 2:
    |                                   ^ PLR2004
678 |                 transition_prob = 0.2  # Medium probability
679 |             else:
    |

ai_trading/strategies/regime_detection.py:695:33: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
693 |             elif current_regime == MarketRegime.SIDEWAYS:
694 |                 # Could go either way - check momentum
695 |                 if len(data) >= 20:
    |                                 ^^ PLR2004
696 |                     recent_returns = (
697 |                         data["close"].iloc[-1] / data["close"].iloc[-21] - 1
    |

ai_trading/strategies/regime_detection.py:699:41: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
697 |                         data["close"].iloc[-1] / data["close"].iloc[-21] - 1
698 |                     )
699 |                     if recent_returns > 0.05:
    |                                         ^^^^ PLR2004
700 |                         next_likely_regime = MarketRegime.BULL_MARKET
701 |                     elif recent_returns < -0.05:
    |

ai_trading/strategies/regime_detection.py:701:43: PLR2004 Magic value used in comparison, consider replacing `-0.05` with a constant variable
    |
699 |                     if recent_returns > 0.05:
700 |                         next_likely_regime = MarketRegime.BULL_MARKET
701 |                     elif recent_returns < -0.05:
    |                                           ^^^^^ PLR2004
702 |                         next_likely_regime = MarketRegime.BEAR_MARKET
    |

ai_trading/strategies/regime_detection.py:729:34: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
728 |             # 1-month return score
729 |             if abs(returns_1m) > 0.05:
    |                                  ^^^^ PLR2004
730 |                 return_scores.append(2)
731 |             elif abs(returns_1m) > 0.02:
    |

ai_trading/strategies/regime_detection.py:731:36: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
    |
729 |             if abs(returns_1m) > 0.05:
730 |                 return_scores.append(2)
731 |             elif abs(returns_1m) > 0.02:
    |                                    ^^^^ PLR2004
732 |                 return_scores.append(1)
733 |             else:
    |

ai_trading/strategies/regime_detection.py:737:34: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
736 |             # 3-month return score
737 |             if abs(returns_3m) > 0.10:
    |                                  ^^^^ PLR2004
738 |                 return_scores.append(2)
739 |             elif abs(returns_3m) > 0.05:
    |

ai_trading/strategies/regime_detection.py:739:36: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
737 |             if abs(returns_3m) > 0.10:
738 |                 return_scores.append(2)
739 |             elif abs(returns_3m) > 0.05:
    |                                    ^^^^ PLR2004
740 |                 return_scores.append(1)
741 |             else:
    |

ai_trading/strategies/regime_detection.py:745:34: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
    |
744 |             # 6-month return score
745 |             if abs(returns_6m) > 0.15:
    |                                  ^^^^ PLR2004
746 |                 return_scores.append(2)
747 |             elif abs(returns_6m) > 0.08:
    |

ai_trading/strategies/regime_detection.py:747:36: PLR2004 Magic value used in comparison, consider replacing `0.08` with a constant variable
    |
745 |             if abs(returns_6m) > 0.15:
746 |                 return_scores.append(2)
747 |             elif abs(returns_6m) > 0.08:
    |                                    ^^^^ PLR2004
748 |                 return_scores.append(1)
749 |             else:
    |

ai_trading/strategies/regime_detection.py:753:38: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
752 |             # Moving average position scores
753 |             if abs(price_vs_sma50) > 0.05:
    |                                      ^^^^ PLR2004
754 |                 return_scores.append(1)
755 |             if abs(price_vs_sma200) > 0.10:
    |

ai_trading/strategies/regime_detection.py:755:39: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
753 |             if abs(price_vs_sma50) > 0.05:
754 |                 return_scores.append(1)
755 |             if abs(price_vs_sma200) > 0.10:
    |                                       ^^^^ PLR2004
756 |                 return_scores.append(1)
    |

ai_trading/strategies/regime_detection.py:761:31: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
759 |             total_score = sum(return_scores)
760 | 
761 |             if total_score >= 6:
    |                               ^ PLR2004
762 |                 return TrendStrength.VERY_STRONG
763 |             elif total_score >= 4:
    |

ai_trading/strategies/regime_detection.py:763:33: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
761 |             if total_score >= 6:
762 |                 return TrendStrength.VERY_STRONG
763 |             elif total_score >= 4:
    |                                 ^ PLR2004
764 |                 return TrendStrength.STRONG
765 |             elif total_score >= 2:
    |

ai_trading/strategies/regime_detection.py:765:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
763 |             elif total_score >= 4:
764 |                 return TrendStrength.STRONG
765 |             elif total_score >= 2:
    |                                 ^ PLR2004
766 |                 return TrendStrength.MODERATE
767 |             elif total_score >= 1:
    |

ai_trading/strategies/regime_detection.py:776:9: PLR0911 Too many return statements (8 > 6)
    |
774 |             return TrendStrength.WEAK
775 | 
776 |     def _calculate_volatility_percentile(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
777 |         self, current_vol: float, historical_vol: float
778 |     ) -> float:
    |

ai_trading/strategies/regime_detection.py:787:28: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
785 |             vol_ratio = current_vol / historical_vol
786 | 
787 |             if vol_ratio > 2.0:
    |                            ^^^ PLR2004
788 |                 return 0.95
789 |             elif vol_ratio > 1.5:
    |

ai_trading/strategies/regime_detection.py:789:30: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
787 |             if vol_ratio > 2.0:
788 |                 return 0.95
789 |             elif vol_ratio > 1.5:
    |                              ^^^ PLR2004
790 |                 return 0.85
791 |             elif vol_ratio > 1.2:
    |

ai_trading/strategies/regime_detection.py:791:30: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
    |
789 |             elif vol_ratio > 1.5:
790 |                 return 0.85
791 |             elif vol_ratio > 1.2:
    |                              ^^^ PLR2004
792 |                 return 0.70
793 |             elif vol_ratio > 0.8:
    |

ai_trading/strategies/regime_detection.py:793:30: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
791 |             elif vol_ratio > 1.2:
792 |                 return 0.70
793 |             elif vol_ratio > 0.8:
    |                              ^^^ PLR2004
794 |                 return 0.50
795 |             elif vol_ratio > 0.6:
    |

ai_trading/strategies/regime_detection.py:795:30: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
793 |             elif vol_ratio > 0.8:
794 |                 return 0.50
795 |             elif vol_ratio > 0.6:
    |                              ^^^ PLR2004
796 |                 return 0.30
797 |             else:
    |

ai_trading/strategies/regime_detection.py:810:22: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
809 |             # RSI contribution
810 |             if rsi > 70 or rsi < 30:
    |                      ^^ PLR2004
811 |                 strength_score += 2
812 |             elif rsi > 60 or rsi < 40:
    |

ai_trading/strategies/regime_detection.py:810:34: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
809 |             # RSI contribution
810 |             if rsi > 70 or rsi < 30:
    |                                  ^^ PLR2004
811 |                 strength_score += 2
812 |             elif rsi > 60 or rsi < 40:
    |

ai_trading/strategies/regime_detection.py:812:24: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
810 |             if rsi > 70 or rsi < 30:
811 |                 strength_score += 2
812 |             elif rsi > 60 or rsi < 40:
    |                        ^^ PLR2004
813 |                 strength_score += 1
    |

ai_trading/strategies/regime_detection.py:812:36: PLR2004 Magic value used in comparison, consider replacing `40` with a constant variable
    |
810 |             if rsi > 70 or rsi < 30:
811 |                 strength_score += 2
812 |             elif rsi > 60 or rsi < 40:
    |                                    ^^ PLR2004
813 |                 strength_score += 1
    |

ai_trading/strategies/regime_detection.py:816:28: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
815 |             # MACD contribution
816 |             if abs(macd) > 0.05:  # Arbitrary threshold
    |                            ^^^^ PLR2004
817 |                 strength_score += 2
818 |             elif abs(macd) > 0.02:
    |

ai_trading/strategies/regime_detection.py:818:30: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
    |
816 |             if abs(macd) > 0.05:  # Arbitrary threshold
817 |                 strength_score += 2
818 |             elif abs(macd) > 0.02:
    |                              ^^^^ PLR2004
819 |                 strength_score += 1
    |

ai_trading/strategies/regime_detection.py:822:27: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
821 |             # Rate of change contribution
822 |             if abs(roc) > 0.05:
    |                           ^^^^ PLR2004
823 |                 strength_score += 2
824 |             elif abs(roc) > 0.02:
    |

ai_trading/strategies/regime_detection.py:824:29: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
    |
822 |             if abs(roc) > 0.05:
823 |                 strength_score += 2
824 |             elif abs(roc) > 0.02:
    |                             ^^^^ PLR2004
825 |                 strength_score += 1
    |

ai_trading/strategies/regime_detection.py:827:34: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
825 |                 strength_score += 1
826 | 
827 |             if strength_score >= 5:
    |                                  ^ PLR2004
828 |                 return "very_strong"
829 |             elif strength_score >= 3:
    |

ai_trading/strategies/regime_detection.py:829:36: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
827 |             if strength_score >= 5:
828 |                 return "very_strong"
829 |             elif strength_score >= 3:
    |                                    ^ PLR2004
830 |                 return "strong"
831 |             elif strength_score >= 2:
    |

ai_trading/strategies/regime_detection.py:831:36: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
829 |             elif strength_score >= 3:
830 |                 return "strong"
831 |             elif strength_score >= 2:
    |                                    ^ PLR2004
832 |                 return "moderate"
833 |             else:
    |

ai_trading/strategies/regime_detection.py:846:43: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
845 |             # Keep only last 100 entries
846 |             if len(self.regime_history) > 100:
    |                                           ^^^ PLR2004
847 |                 self.regime_history = self.regime_history[-100:]
    |

ai_trading/strategies/regime_detection.py:984:41: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
983 |             # Adjust based on confidence
984 |             if self.regime_confidence < 0.6:
    |                                         ^^^ PLR2004
985 |                 recommendations["position_size_multiplier"] *= 0.8
986 |                 recommendations["risk_level"] = "high"
    |

ai_trading/strategies/regime_detector.py:22:1: E402 Module level import not at top of file
   |
20 | NUMPY_AVAILABLE = True
21 | 
22 | from ai_trading.risk.adaptive_sizing import MarketRegime, VolatilityRegime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 | 
24 | ENHANCED_REGIMES_AVAILABLE = True
   |

ai_trading/strategies/regime_detector.py:213:16: BLE001 Do not catch blind exception: `Exception`
    |
211 |             return regime, metrics
212 | 
213 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
214 |             logger.error(f"Error detecting market regime: {e}")
215 |             return self._fallback_regime_detection()
    |

ai_trading/strategies/regime_detector.py:274:16: BLE001 Do not catch blind exception: `Exception`
    |
272 |             return adjusted_thresholds
273 | 
274 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
275 |             logger.error(f"Error calculating dynamic thresholds: {e}")
276 |             # Return conservative defaults
    |

ai_trading/strategies/regime_detector.py:284:31: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
282 |         """Calculate trend strength and direction from returns."""
283 |         try:
284 |             if len(returns) < 10:
    |                               ^^ PLR2004
285 |                 return 0.0, TrendDirection.SIDEWAYS
    |

ai_trading/strategies/regime_detector.py:332:16: BLE001 Do not catch blind exception: `Exception`
    |
330 |             return trend_strength, direction
331 | 
332 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
333 |             logger.error(f"Error calculating trend metrics: {e}")
334 |             return 0.0, TrendDirection.SIDEWAYS
    |

ai_trading/strategies/regime_detector.py:379:16: BLE001 Do not catch blind exception: `Exception`
    |
377 |             return percentile, regime
378 | 
379 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
380 |             logger.error(f"Error calculating volatility regime: {e}")
381 |             return 0.5, VolatilityRegime.NORMAL
    |

ai_trading/strategies/regime_detector.py:386:31: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
384 |         """Calculate price momentum indicator."""
385 |         try:
386 |             if len(returns) < 21:  # Need at least 1 month
    |                               ^^ PLR2004
387 |                 return 0.0
    |

ai_trading/strategies/regime_detector.py:390:67: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
389 |             # Short-term momentum (last 5 days)
390 |             short_momentum = sum(returns[-5:]) if len(returns) >= 5 else 0
    |                                                                   ^ PLR2004
391 | 
392 |             # Medium-term momentum (last 21 days)
    |

ai_trading/strategies/regime_detector.py:393:69: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
392 |             # Medium-term momentum (last 21 days)
393 |             medium_momentum = sum(returns[-21:]) if len(returns) >= 21 else 0
    |                                                                     ^^ PLR2004
394 | 
395 |             # Weighted momentum score
    |

ai_trading/strategies/regime_detector.py:405:16: BLE001 Do not catch blind exception: `Exception`
    |
403 |             return momentum
404 | 
405 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
406 |             logger.error(f"Error calculating momentum: {e}")
407 |             return 0.0
    |

ai_trading/strategies/regime_detector.py:430:16: BLE001 Do not catch blind exception: `Exception`
    |
428 |             return min(1.0, max(0.0, avg_correlation))
429 | 
430 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
431 |             logger.error(f"Error calculating correlation environment: {e}")
432 |             return 0.3
    |

ai_trading/strategies/regime_detector.py:446:16: BLE001 Do not catch blind exception: `Exception`
    |
444 |             return None
445 | 
446 |         except Exception:
    |                ^^^^^^^^^ BLE001
447 |             return None
    |

ai_trading/strategies/regime_detector.py:461:33: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
460 |             # Higher confidence for strong trends or extreme volatility
461 |             if trend_strength > 0.7 or volatility_level > 0.8 or volatility_level < 0.2:
    |                                 ^^^ PLR2004
462 |                 confidence *= 1.2
    |

ai_trading/strategies/regime_detector.py:461:59: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
460 |             # Higher confidence for strong trends or extreme volatility
461 |             if trend_strength > 0.7 or volatility_level > 0.8 or volatility_level < 0.2:
    |                                                           ^^^ PLR2004
462 |                 confidence *= 1.2
    |

ai_trading/strategies/regime_detector.py:461:85: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
460 |             # Higher confidence for strong trends or extreme volatility
461 |             if trend_strength > 0.7 or volatility_level > 0.8 or volatility_level < 0.2:
    |                                                                                     ^^^ PLR2004
462 |                 confidence *= 1.2
    |

ai_trading/strategies/regime_detector.py:465:16: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
464 |             # Lower confidence for moderate/unclear conditions
465 |             if 0.3 < trend_strength < 0.7 and 0.3 < volatility_level < 0.7:
    |                ^^^ PLR2004
466 |                 confidence *= 0.8
    |

ai_trading/strategies/regime_detector.py:465:39: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
464 |             # Lower confidence for moderate/unclear conditions
465 |             if 0.3 < trend_strength < 0.7 and 0.3 < volatility_level < 0.7:
    |                                       ^^^ PLR2004
466 |                 confidence *= 0.8
    |

ai_trading/strategies/regime_detector.py:465:47: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
464 |             # Lower confidence for moderate/unclear conditions
465 |             if 0.3 < trend_strength < 0.7 and 0.3 < volatility_level < 0.7:
    |                                               ^^^ PLR2004
466 |                 confidence *= 0.8
    |

ai_trading/strategies/regime_detector.py:465:72: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
464 |             # Lower confidence for moderate/unclear conditions
465 |             if 0.3 < trend_strength < 0.7 and 0.3 < volatility_level < 0.7:
    |                                                                        ^^^ PLR2004
466 |                 confidence *= 0.8
    |

ai_trading/strategies/regime_detector.py:470:16: BLE001 Do not catch blind exception: `Exception`
    |
468 |             return max(0.0, min(1.0, confidence))
469 | 
470 |         except Exception:
    |                ^^^^^^^^^ BLE001
471 |             return 0.5
    |

ai_trading/strategies/regime_detector.py:473:9: PLR0911 Too many return statements (8 > 6)
    |
471 |             return 0.5
472 | 
473 |     def _classify_market_regime(self, metrics: RegimeMetrics) -> MarketRegime:
    |         ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
474 |         """Classify overall market regime from metrics."""
475 |         try:
    |

ai_trading/strategies/regime_detector.py:480:40: PLR2004 Magic value used in comparison, consider replacing `-0.5` with a constant variable
    |
478 |                 metrics.volatility_regime
479 |                 in [VolatilityRegime.EXTREMELY_HIGH, VolatilityRegime.HIGH]
480 |                 and metrics.momentum < -0.5
    |                                        ^^^^ PLR2004
481 |             ):
482 |                 return MarketRegime.CRISIS
    |

ai_trading/strategies/regime_detector.py:493:41: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
492 |             # Trending regimes
493 |             if metrics.trend_strength > 0.6:
    |                                         ^^^ PLR2004
494 |                 if metrics.trend_direction in [
495 |                     TrendDirection.STRONG_UPTREND,
    |

ai_trading/strategies/regime_detector.py:507:42: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
505 |             # Sideways/ranging market
506 |             if (
507 |                 metrics.trend_strength < 0.3
    |                                          ^^^ PLR2004
508 |                 and metrics.volatility_regime == VolatilityRegime.NORMAL
509 |             ):
    |

ai_trading/strategies/regime_detector.py:515:16: BLE001 Do not catch blind exception: `Exception`
    |
513 |             return MarketRegime.NORMAL
514 | 
515 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
516 |             logger.error(f"Error classifying market regime: {e}")
517 |             return MarketRegime.NORMAL
    |

ai_trading/strategies/signals.py:23:1: E402 Module level import not at top of file
   |
21 | sklearn_available = True
22 | 
23 | from .base import StrategySignal
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/strategies/signals.py:456:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
455 |             # Calculate turnover penalty
456 |             if len(recent_signals) > 3:  # If trading too frequently
    |                                      ^ PLR2004
457 |                 penalty_factor = 1.0 - (
458 |                     self.turnover_penalty * (len(recent_signals) - 3)
    |

ai_trading/strategies/signals.py:560:25: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
558 |             X, y = self._prepare_training_data()
559 | 
560 |             if len(X) < 5:  # Need minimum samples
    |                         ^ PLR2004
561 |                 return
    |

ai_trading/strategies/signals.py:619:45: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
618 |             # Keep recent history only
619 |             if len(self.ensemble_history) > 1000:
    |                                             ^^^^ PLR2004
620 |                 self.ensemble_history = self.ensemble_history[-500:]
    |

ai_trading/strategies/signals.py:649:65: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
648 |             # Keep recent history only
649 |             if len(self.signal_metrics[signal_id]["returns"]) > 100:
    |                                                                 ^^^ PLR2004
650 |                 self.signal_metrics[signal_id]["returns"] = self.signal_metrics[
651 |                     signal_id
    |

ai_trading/strategies/signals.py:656:31: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
654 |             # Update metrics
655 |             returns = self.signal_metrics[signal_id]["returns"]
656 |             if len(returns) > 5:
    |                               ^ PLR2004
657 |                 # Sharpe ratio
658 |                 if np.std(returns) > 0:
    |

ai_trading/strategies/signals.py:700:63: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
699 |                     # Keep reasonable history size
700 |                     if len(self.signal_performance_history) > 500:
    |                                                               ^^^ PLR2004
701 |                         self.signal_performance_history = (
702 |                             self.signal_performance_history[-250:]
    |

ai_trading/strategies/signals.py:731:45: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
730 |             # Calculate recent turnover
731 |             if len(self.ensemble_history) > 10:
    |                                             ^^ PLR2004
732 |                 recent_symbols = set()
733 |                 for entry in self.ensemble_history[-10:]:
    |

ai_trading/telemetry/metrics_logger.py:32:12: BLE001 Do not catch blind exception: `Exception`
   |
30 |     try:
31 |         path.parent.mkdir(parents=True, exist_ok=True)
32 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
33 |         logger.warning("Could not create parent dir for %s: %s", path, e)
   |

ai_trading/telemetry/metrics_logger.py:61:16: BLE001 Do not catch blind exception: `Exception`
   |
59 |         try:
60 |             row["max_drawdown"] = compute_max_drawdown(equity_curve)
61 |         except Exception:
   |                ^^^^^^^^^ BLE001
62 |             row["max_drawdown"] = ""
63 |     _write_csv_row(filename, row)
   |

ai_trading/thirdparty/__init__.py:3:15: PLC0414 Import alias does not rename original package
  |
1 | """Third-party compatibility shims used in tests."""
2 | 
3 | from . import lightgbm_compat as lightgbm_compat
  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
4 | 
5 | __all__ = ["lightgbm_compat"]
  |
  = help: Remove import alias

ai_trading/tools/fetch_sample_universe.py:36:42: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
34 |     logger.info("HTTP_POOL_STATS", extra=http.pool_stats())
35 |     for (resp, err), sym in zip(results, symbols, strict=False):  # AI-AGENT-REF: Stage 2.1
36 |         if err or not resp or resp[1] != 200:
   |                                          ^^^ PLR2004
37 |             logger.error("fetch failed for %s", sym)
38 |             failures += 1
   |

ai_trading/trade_logic.py:14:8: BLE001 Do not catch blind exception: `Exception`
   |
12 |         drawdown_adjusted_kelly_alt as drawdown_adjusted_kelly,
13 |     )
14 | except Exception:  # pragma: no cover - fallback for older installs
   |        ^^^^^^^^^ BLE001
15 |     from ai_trading.capital_scaling import (
16 |         drawdown_adjusted_kelly,
   |

ai_trading/trade_logic.py:36:52: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
34 |     # Protect against insufficient history
35 |     try:
36 |         if price_data is None or len(price_data) < 2:
   |                                                    ^ PLR2004
37 |             log.debug("Insufficient price data for trade entry")
38 |             return False
   |

ai_trading/trade_logic.py:41:12: BLE001 Do not catch blind exception: `Exception`
   |
39 |         last_price, prev_price = float(price_data[-1]), float(price_data[-2])
40 |         recent_gain = (last_price - prev_price) / max(prev_price, 1e-9)
41 |     except Exception:
   |            ^^^^^^^^^ BLE001
42 |         # if indexing fails return False
43 |         log.warning("Failed to calculate recent gain from price data")
   |

ai_trading/trade_logic.py:57:32: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
   |
55 |         return False
56 | 
57 |     result = signal_strength > 0.7 and recent_gain > 0.001 and max_risk < 0.05
   |                                ^^^ PLR2004
58 |     log.debug(
59 |         "Trade entry evaluation: signal=%.3f, gain=%.4f, risk=%.3f, result=%s",
   |

ai_trading/trade_logic.py:57:54: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
   |
55 |         return False
56 | 
57 |     result = signal_strength > 0.7 and recent_gain > 0.001 and max_risk < 0.05
   |                                                      ^^^^^ PLR2004
58 |     log.debug(
59 |         "Trade entry evaluation: signal=%.3f, gain=%.4f, risk=%.3f, result=%s",
   |

ai_trading/trade_logic.py:57:75: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
55 |         return False
56 | 
57 |     result = signal_strength > 0.7 and recent_gain > 0.001 and max_risk < 0.05
   |                                                                           ^^^^ PLR2004
58 |     log.debug(
59 |         "Trade entry evaluation: signal=%.3f, gain=%.4f, risk=%.3f, result=%s",
   |

ai_trading/trade_logic.py:102:12: BLE001 Do not catch blind exception: `Exception`
    |
100 |             val = float(data)
101 |         return float(val or 1e-3)
102 |     except Exception as exc:
    |            ^^^^^^^^^ BLE001
103 |         logger.warning("extract_price failed: %s", exc)
104 |         return 1e-3
    |

ai_trading/trade_logic.py:184:16: BLE001 Do not catch blind exception: `Exception`
    |
182 |             if sig is not None:
183 |                 signals[sym] = sig
184 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
185 |             ctx.logger.warning("Entry eval failed for %s: %s", sym, exc)
186 |     return signals
    |

ai_trading/trade_logic.py:218:16: BLE001 Do not catch blind exception: `Exception`
    |
216 |             if sig:
217 |                 exits[sym] = sig
218 |         except Exception as exc:
    |                ^^^^^^^^^ BLE001
219 |             ctx.logger.warning("Exit eval failed for %s: %s", sym, exc)
220 |     return exits
    |

ai_trading/training/train_ml.py:25:8: BLE001 Do not catch blind exception: `Exception`
   |
23 |     lgb = importlib.import_module("lightgbm")
24 |     lgb_available = True
25 | except Exception:  # pragma: no cover - optional dependency
   |        ^^^^^^^^^ BLE001
26 |     from ai_trading.thirdparty import lightgbm_compat as lgb
27 |     lgb_available = False
   |

ai_trading/training/train_ml.py:33:1: E402 Module level import not at top of file
   |
31 | xgb_available = True
32 | 
33 | from sklearn.linear_model import Ridge
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
34 | from sklearn.metrics import (
35 |     mean_squared_error,
   |

ai_trading/training/train_ml.py:34:1: E402 Module level import not at top of file
   |
33 |   from sklearn.linear_model import Ridge
34 | / from sklearn.metrics import (
35 | |     mean_squared_error,
36 | | )
   | |_^ E402
37 |   
38 |   sklearn_available = True
   |

ai_trading/training/train_ml.py:40:1: E402 Module level import not at top of file
   |
38 | sklearn_available = True
39 | 
40 | import optuna
   | ^^^^^^^^^^^^^ E402
41 | 
42 | optuna_available = True
   |

ai_trading/training/train_ml.py:44:1: E402 Module level import not at top of file
   |
42 | optuna_available = True
43 | 
44 | from ..data.splits import PurgedGroupTimeSeriesSplit
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

ai_trading/training/train_ml.py:217:16: BLE001 Do not catch blind exception: `Exception`
    |
215 |             return study.best_params
216 | 
217 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
218 |             logger.error(f"Error in hyperparameter optimization: {e}")
219 |             return self._get_default_params()
    |

ai_trading/training/train_ml.py:316:40: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
314 |         try:
315 |             # Convert predictions to returns if needed
316 |             if np.all(np.abs(y_pred) < 10):  # Assume these are returns
    |                                        ^^ PLR2004
317 |                 pred_returns = y_pred
318 |                 true_returns = y_true.values
    |

ai_trading/training/train_ml.py:339:16: BLE001 Do not catch blind exception: `Exception`
    |
337 |             return score
338 | 
339 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
340 |             logger.error(f"Error calculating score: {e}")
341 |             return 0.0
    |

ai_trading/training/train_ml.py:401:16: BLE001 Do not catch blind exception: `Exception`
    |
399 |             return cv_results
400 | 
401 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
402 |             logger.error(f"Error in CV evaluation: {e}")
403 |             return {"mean_score": 0.0, "std_score": 0.0, "fold_scores": []}
    |

ai_trading/util/optional_imports.py:11:12: BLE001 Do not catch blind exception: `Exception`
   |
 9 |         m = import_module(module_name)
10 |         return m, True, None
11 |     except Exception as e:  # intentionally broad to capture env issues
   |            ^^^^^^^^^ BLE001
12 |         return None, False, e
   |

ai_trading/utils/__init__.py:43:8: BLE001 Do not catch blind exception: `Exception`
   |
41 | try:  # pragma: no cover
42 |     from . import time as utils_time  # type: ignore
43 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
44 |     utils_time = None  # type: ignore
   |

ai_trading/utils/__init__.py:53:8: BLE001 Do not catch blind exception: `Exception`
   |
51 | try:  # pragma: no cover
52 |     from . import process_manager  # type: ignore
53 | except Exception:  # pragma: no cover
   |        ^^^^^^^^^ BLE001
54 |     process_manager = None  # type: ignore
   |

ai_trading/utils/__init__.py:119:12: BLE001 Do not catch blind exception: `Exception`
    |
117 |     try:
118 |         val = float(df["close"].dropna().iloc[-1])
119 |     except Exception:
    |            ^^^^^^^^^ BLE001
120 |         return 0.0
121 |     return val
    |

ai_trading/utils/base.py:287:19: DTZ011 `datetime.date.today()` used
    |
285 |             from ai_trading.data_fetcher import get_daily_df  # type: ignore
286 | 
287 |             end = dt.date.today()
    |                   ^^^^^^^^^^^^^^^ DTZ011
288 |             start = end - dt.timedelta(days=5)
289 |             df = get_daily_df(symbol, start, end)
    |
    = help: Use `datetime.datetime.now(tz=...).date()` instead

ai_trading/utils/base.py:302:12: PLW0603 Using the global statement to update `_LAST_MARKET_HOURS_LOG` is discouraged
    |
300 | def _log_market_hours(message: str) -> None:
301 |     """Emit market hours message only on state change or hourly."""
302 |     global _LAST_MARKET_HOURS_LOG, _LAST_MARKET_STATE
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
303 |     now = time.time()
304 |     state = "OPEN" if "OPEN" in message else "CLOSED"
    |

ai_trading/utils/base.py:302:36: PLW0603 Using the global statement to update `_LAST_MARKET_STATE` is discouraged
    |
300 | def _log_market_hours(message: str) -> None:
301 |     """Emit market hours message only on state change or hourly."""
302 |     global _LAST_MARKET_HOURS_LOG, _LAST_MARKET_STATE
    |                                    ^^^^^^^^^^^^^^^^^^ PLW0603
303 |     now = time.time()
304 |     state = "OPEN" if "OPEN" in message else "CLOSED"
    |

ai_trading/utils/base.py:305:71: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
303 |     now = time.time()
304 |     state = "OPEN" if "OPEN" in message else "CLOSED"
305 |     if state != _LAST_MARKET_STATE or now - _LAST_MARKET_HOURS_LOG >= 3600:
    |                                                                       ^^^^ PLR2004
306 |         if get_verbose_logging():
307 |             logger.info(message)
    |

ai_trading/utils/base.py:316:12: PLW0603 Using the global statement to update `_LAST_HEALTH_ROW_LOG` is discouraged
    |
314 | def log_health_row_check(rows: int, passed: bool) -> None:
315 |     """Log HEALTH_ROWS status changes or once every 10 seconds."""
316 |     global _LAST_HEALTH_ROW_LOG, _LAST_HEALTH_ROWS_COUNT, _LAST_HEALTH_STATUS
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
317 |     now = time.monotonic()
318 |     if (
    |

ai_trading/utils/base.py:316:34: PLW0603 Using the global statement to update `_LAST_HEALTH_ROWS_COUNT` is discouraged
    |
314 | def log_health_row_check(rows: int, passed: bool) -> None:
315 |     """Log HEALTH_ROWS status changes or once every 10 seconds."""
316 |     global _LAST_HEALTH_ROW_LOG, _LAST_HEALTH_ROWS_COUNT, _LAST_HEALTH_STATUS
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^ PLW0603
317 |     now = time.monotonic()
318 |     if (
    |

ai_trading/utils/base.py:316:59: PLW0603 Using the global statement to update `_LAST_HEALTH_STATUS` is discouraged
    |
314 | def log_health_row_check(rows: int, passed: bool) -> None:
315 |     """Log HEALTH_ROWS status changes or once every 10 seconds."""
316 |     global _LAST_HEALTH_ROW_LOG, _LAST_HEALTH_ROWS_COUNT, _LAST_HEALTH_STATUS
    |                                                           ^^^^^^^^^^^^^^^^^^^ PLW0603
317 |     now = time.monotonic()
318 |     if (
    |

ai_trading/utils/base.py:322:42: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
320 |         or rows != _LAST_HEALTH_ROWS_COUNT
321 |         or passed != _LAST_HEALTH_STATUS
322 |         or now - _LAST_HEALTH_ROW_LOG >= 10
    |                                          ^^ PLR2004
323 |     ):
324 |         level = logger.info if get_verbose_logging() or not passed else logger.debug
    |

ai_trading/utils/base.py:334:12: PLW0603 Using the global statement to update `_last_health_log` is discouraged
    |
332 | def health_rows_passed(rows):
333 |     """Log HEALTH_ROWS_PASSED with throttling."""
334 |     global _last_health_log
    |            ^^^^^^^^^^^^^^^^ PLW0603
335 |     now = time.monotonic()
336 |     if _last_health_log == 0.0 or now - _last_health_log >= HEALTH_THROTTLE:
    |

ai_trading/utils/base.py:364:50: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
362 |         if sched.empty:
363 |             # Provide more detailed information about why schedule is empty
364 |             is_weekend = check_time.weekday() >= 5
    |                                                  ^ PLR2004
365 |             is_future = check_time.date() > dt.date.today()
    |

ai_trading/utils/base.py:365:45: DTZ011 `datetime.date.today()` used
    |
363 |             # Provide more detailed information about why schedule is empty
364 |             is_weekend = check_time.weekday() >= 5
365 |             is_future = check_time.date() > dt.date.today()
    |                                             ^^^^^^^^^^^^^^^ DTZ011
366 | 
367 |             if is_weekend:
    |
    = help: Use `datetime.datetime.now(tz=...).date()` instead

ai_trading/utils/base.py:387:32: PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
    |
385 |         market_open = sched.iloc[0]["market_open"].tz_convert(EASTERN_TZ).time()
386 |         market_close = sched.iloc[0]["market_close"].tz_convert(EASTERN_TZ).time()
387 |         if check_time.month == 7 and check_time.day == 3:
    |                                ^ PLR2004
388 |             july4 = date(check_time.year, 7, 4)
389 |             market_close = dt_time(13, 0) if july4.weekday() >= 5 else MARKET_CLOSE_TIME
    |

ai_trading/utils/base.py:387:56: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
385 |         market_open = sched.iloc[0]["market_open"].tz_convert(EASTERN_TZ).time()
386 |         market_close = sched.iloc[0]["market_close"].tz_convert(EASTERN_TZ).time()
387 |         if check_time.month == 7 and check_time.day == 3:
    |                                                        ^ PLR2004
388 |             july4 = date(check_time.year, 7, 4)
389 |             market_close = dt_time(13, 0) if july4.weekday() >= 5 else MARKET_CLOSE_TIME
    |

ai_trading/utils/base.py:389:65: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
387 |         if check_time.month == 7 and check_time.day == 3:
388 |             july4 = date(check_time.year, 7, 4)
389 |             market_close = dt_time(13, 0) if july4.weekday() >= 5 else MARKET_CLOSE_TIME
    |                                                                 ^ PLR2004
390 |         _log_market_hours(
391 |             "Detected Market Hours today: OPEN from {} to {}".format(
    |

ai_trading/utils/base.py:401:32: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
399 |         # Fallback to simple weekday/time check when calendar unavailable
400 |         now_et = (now or dt.datetime.now(dt.UTC)).astimezone(EASTERN_TZ)
401 |         if now_et.weekday() >= 5:
    |                                ^ PLR2004
402 |             _log_market_hours("Detected Market Hours today: CLOSED")
403 |             return False
    |

ai_trading/utils/base.py:436:37: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
434 |     try:
435 |         et_time = timestamp.astimezone(ZoneInfo("America/New_York"))
436 |         return et_time.weekday() >= 5  # Saturday=5, Sunday=6
    |                                     ^ PLR2004
437 |     except COMMON_EXC:  # AI-AGENT-REF: narrow
438 |         # Fallback to UTC weekday
    |

ai_trading/utils/base.py:439:39: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
437 |     except COMMON_EXC:  # AI-AGENT-REF: narrow
438 |         # Fallback to UTC weekday
439 |         return timestamp.weekday() >= 5
    |                                       ^ PLR2004
    |

ai_trading/utils/base.py:574:32: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
573 |     df = fetch_minute_df_safe(symbol)
574 |     if df is None or len(df) < 21:
    |                                ^^ PLR2004
575 |         return 1.0
576 |     last_vol = df["volume"].iloc[-1]
    |

ai_trading/utils/base.py:644:62: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
643 |     # if someone passed (symbol, Timestamp), extract the Timestamp
644 |     if HAS_PANDAS and isinstance(arr, tuple) and len(arr) == 2 and isinstance(arr[1], pd.Timestamp):
    |                                                              ^ PLR2004
645 |         arr = arr[1]
646 |     elif HAS_PANDAS and (
    |

ai_trading/utils/base.py:649:59: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
647 |         isinstance(arr, list | Index | Series) and len(arr) > 0 and isinstance(arr[0], tuple)
648 |     ):
649 |         arr = [x[1] if isinstance(x, tuple) and len(x) == 2 else x for x in arr]
    |                                                           ^ PLR2004
650 | 
651 |     # If pandas is not available, return the array as-is for now
    |

ai_trading/utils/base.py:842:5: F811 Redefinition of unused `get_ohlcv_columns` from line 48
    |
842 | def get_ohlcv_columns(df):  # AI-AGENT-REF: coexist with typed variant
    |     ^^^^^^^^^^^^^^^^^ F811
843 |     """Return the names of the OHLCV columns if present."""
    |
    = help: Remove definition: `get_ohlcv_columns`

ai_trading/utils/datetime.py:36:24: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
34 | def to_date_only(val: datetime | date | str) -> str:
35 |     if isinstance(val, str):
36 |         if len(val) == 10 and val.count("-") == 2:
   |                        ^^ PLR2004
37 |             return val
38 |         dt_obj = ensure_datetime(val)
   |

ai_trading/utils/datetime.py:36:49: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
34 | def to_date_only(val: datetime | date | str) -> str:
35 |     if isinstance(val, str):
36 |         if len(val) == 10 and val.count("-") == 2:
   |                                                 ^ PLR2004
37 |             return val
38 |         dt_obj = ensure_datetime(val)
   |

ai_trading/utils/determinism.py:19:1: E402 Module level import not at top of file
   |
17 | logger = logging.getLogger(__name__)
18 | 
19 | import numpy as np
   | ^^^^^^^^^^^^^^^^^^ E402
20 | 
21 | logger = logging.getLogger(__name__)
   |

ai_trading/utils/determinism.py:35:8: F821 Undefined name `HAS_NUMPY`
   |
34 |     # NumPy (if available)
35 |     if HAS_NUMPY:
   |        ^^^^^^^^^ F821
36 |         np.random.seed(seed)
   |

ai_trading/utils/determinism.py:45:12: BLE001 Do not catch blind exception: `Exception`
   |
43 |         import importlib
44 |         lgb = importlib.import_module("lightgbm")
45 |     except Exception:  # pragma: no cover - optional dep
   |            ^^^^^^^^^ BLE001
46 |         from ai_trading.thirdparty import lightgbm_compat as lgb  # noqa: F401
47 |     # Set environment variables for additional determinism
   |

ai_trading/utils/determinism.py:82:12: BLE001 Do not catch blind exception: `Exception`
   |
80 |         return hashlib.sha256(content).hexdigest()[:16]  # First 16 chars
81 | 
82 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
83 |         logger.warning(f"Failed to hash data: {e}")
84 |         return "unknown"
   |

ai_trading/utils/determinism.py:107:62: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
105 |             shape_info = feature_data.shape
106 |             sample_data = (
107 |                 feature_data.head(10) if len(feature_data) > 10 else feature_data
    |                                                              ^^ PLR2004
108 |             )
    |

ai_trading/utils/determinism.py:122:12: BLE001 Do not catch blind exception: `Exception`
    |
120 |         return hash_data(hash_content)
121 | 
122 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
123 |         logger.warning(f"Failed to hash features: {e}")
124 |         return "feature_hash_error"
    |

ai_trading/utils/determinism.py:210:20: BLE001 Do not catch blind exception: `Exception`
    |
208 |                 self._is_locked = self._spec.get("locked", False)
209 | 
210 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
211 |                 self.logger.error(f"Failed to load specification: {e}")
212 |                 self._spec = {}
    |

ai_trading/utils/determinism.py:226:16: BLE001 Do not catch blind exception: `Exception`
    |
224 |             self.logger.info(f"Saved model specification to {self.spec_file}")
225 | 
226 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
227 |             self.logger.error(f"Failed to save specification: {e}")
    |

ai_trading/utils/determinism.py:412:12: PLW0603 Using the global statement to update `_global_spec` is discouraged
    |
410 | def get_model_spec() -> ModelSpecification:
411 |     """Get or create global model specification instance."""
412 |     global _global_spec
    |            ^^^^^^^^^^^^ PLW0603
413 |     if _global_spec is None:
414 |         _global_spec = ModelSpecification()
    |

ai_trading/utils/device.py:11:12: BLE001 Do not catch blind exception: `Exception`
   |
 9 |     try:
10 |         import torch  # type: ignore
11 |     except Exception:
   |            ^^^^^^^^^ BLE001
12 |         _log.info(
13 |             "ML_DEVICE_SELECTED", extra={"device": "cpu", "reason": "torch_unavailable"}
   |

ai_trading/utils/device.py:39:12: BLE001 Do not catch blind exception: `Exception`
   |
38 |         tv.append(Tensor)
39 |     except Exception:
   |            ^^^^^^^^^ BLE001
40 |         return batch
41 |     return {
   |

ai_trading/utils/http.py:65:12: PLW0603 Using the global statement to update `_session` is discouraged
   |
64 | def _get_session() -> requests.Session:
65 |     global _session
   |            ^^^^^^^^ PLW0603
66 |     if _session is None:
67 |         with _session_lock:
   |

ai_trading/utils/imports.py:16:12: BLE001 Do not catch blind exception: `Exception`
   |
14 |         mod = importlib.import_module(module_name)
15 |         return getattr(mod, cls_name, None)
16 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
17 |         _log.error("Failed to import %s (%s): %s", module_name, cls_name, e)
18 |         return None
   |

ai_trading/utils/optdeps.py:12:12: BLE001 Do not catch blind exception: `Exception`
   |
10 |     try:
11 |         return _ils.find_spec(name) is not None
12 |     except Exception:
   |            ^^^^^^^^^ BLE001
13 |         return False
   |

ai_trading/utils/optdeps.py:20:12: BLE001 Do not catch blind exception: `Exception`
   |
18 |     try:
19 |         return __import__(name)
20 |     except Exception:
   |            ^^^^^^^^^ BLE001
21 |         return None
   |

ai_trading/utils/performance.py:215:24: BLE001 Do not catch blind exception: `Exception`
    |
213 |                     result = future.result()
214 |                     results[chunk_index] = result
215 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
216 |                     self.logger.error(f"Parallel task failed: {e}")
217 |                     results[chunk_index] = None
    |

ai_trading/utils/performance.py:264:24: BLE001 Do not catch blind exception: `Exception`
    |
262 |                             chunk_results[f"{indicator_name}_{col}"] = result[col]
263 | 
264 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
265 |                     logger.warning(
266 |                         f"Failed to calculate {config.get('name', 'unknown')}: {e}"
    |

ai_trading/utils/performance.py:413:12: BLE001 Do not catch blind exception: `Exception`
    |
411 |     try:
412 |         import psutil  # type: ignore
413 |     except Exception:
    |            ^^^^^^^^^ BLE001
414 |         psutil = None  # type: ignore  # AI-AGENT-REF: degrade if psutil missing
    |

ai_trading/utils/performance.py:469:12: PLW0603 Using the global statement to update `_global_processor` is discouraged
    |
467 | def get_parallel_processor() -> ParallelProcessor:
468 |     """Get or create global parallel processor."""
469 |     global _global_processor
    |            ^^^^^^^^^^^^^^^^^ PLW0603
470 |     if _global_processor is None:
471 |         _global_processor = ParallelProcessor()
    |

ai_trading/utils/performance.py:477:12: PLW0603 Using the global statement to update `_global_cache` is discouraged
    |
475 | def get_performance_cache() -> PerformanceCache:
476 |     """Get or create global performance cache."""
477 |     global _global_cache
    |            ^^^^^^^^^^^^^ PLW0603
478 |     if _global_cache is None:
479 |         _global_cache = PerformanceCache()
    |

ai_trading/utils/prof.py:16:16: BLE001 Do not catch blind exception: `Exception`
   |
14 |         try:
15 |             logger.info("STAGE_TIMING", extra={"stage": stage_name, "elapsed_ms": dt_ms, **extra})
16 |         except Exception:
   |                ^^^^^^^^^ BLE001
17 |             pass
   |

ai_trading/utils/workers.py:15:12: BLE001 Do not catch blind exception: `Exception`
   |
13 |         v = os.getenv(name)
14 |         return int(v) if v is not None else default
15 |     except Exception:
   |            ^^^^^^^^^ BLE001
16 |         return default
   |

ai_trading/validation/validate_env.py:21:21: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
   |
19 |     @classmethod
20 |     def _api_key(cls, v: str) -> str:
21 |         if len(v) < 16:
   |                     ^^ PLR2004
22 |             raise ValueError("ALPACA_API_KEY appears too short")
23 |         return v
   |

ai_trading/validation/validate_env.py:28:21: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
   |
26 |     @classmethod
27 |     def _secret_key(cls, v: str) -> str:
28 |         if len(v) < 16:
   |                     ^^ PLR2004
29 |             raise ValueError("ALPACA_SECRET_KEY appears too short")
30 |         return v
   |

scripts/INTEGRATION_GUIDE.py:143:23: F821 Undefined name `get_current_position`
    |
142 |         # Update position snapshot for unrealized PnL tracking
143 |         current_qty = get_current_position(symbol)  # Your existing position tracking
    |                       ^^^^^^^^^^^^^^^^^^^^ F821
144 |         current_market_price = get_current_market_price(symbol)  # Your price feed
    |

scripts/INTEGRATION_GUIDE.py:144:32: F821 Undefined name `get_current_market_price`
    |
142 |         # Update position snapshot for unrealized PnL tracking
143 |         current_qty = get_current_position(symbol)  # Your existing position tracking
144 |         current_market_price = get_current_market_price(symbol)  # Your price feed
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^ F821
145 | 
146 |         update_position_for_pnl(
    |

scripts/INTEGRATION_GUIDE.py:178:27: PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
    |
176 |         exec_stats = get_execution_statistics()
177 |         success_rate = exec_stats.get('success_rate', 0)
178 |         if success_rate < 0.95:  # Alert if success rate drops below 95%
    |                           ^^^^ PLR2004
179 |             logging.info(f"⚠️ Low execution success rate: {success_rate:.1%}")
    |

scripts/INTEGRATION_GUIDE.py:183:44: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
181 |         # Check for unusual PnL patterns
182 |         pnl_summary = get_portfolio_pnl_summary()
183 |         if abs(pnl_summary['total_pnl']) > 1000:  # Alert for large PnL changes
    |                                            ^^^^ PLR2004
184 |             logging.info(str(f"📊 Large PnL movement: ${pnl_summary['total_pnl']:+.2f}"))
    |

scripts/INTEGRATION_GUIDE.py:204:35: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
202 |         recent_failures = [e for e in failed_executions if was_recent(e.get('timestamp'))]
203 | 
204 |         if len(recent_failures) > 3:  # Alert if more than 3 failures recently
    |                                   ^ PLR2004
205 |             logging.info(f"🚨 ALERT: {len(recent_failures)} failed executions recently")
206 |             for failure in recent_failures:
    |

scripts/INTEGRATION_GUIDE.py:260:20: BLE001 Do not catch blind exception: `Exception`
    |
258 |                 self.run_health_checks()
259 | 
260 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
261 |                 logging.info(f"Trading cycle error: {e}")
262 |                 # Your existing error handling
    |

scripts/INTEGRATION_GUIDE.py:318:40: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
316 |             # Check execution health
317 |             stats = get_execution_statistics()
318 |             if stats['success_rate'] < 0.9:
    |                                        ^^^ PLR2004
319 |                 logging.info(str(f"Low success rate: {stats['success_rate']:.1%}"))
    |

scripts/algorithm_optimizer.py:160:34: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
158 |         """Detect current market regime and conditions."""
159 |         try:
160 |             if len(price_data) < 20:
    |                                  ^^ PLR2004
161 |                 # Default regime for insufficient data
162 |                 return MarketConditions(
    |

scripts/algorithm_optimizer.py:194:64: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
192 |             # Volume analysis
193 |             volume_profile = 1.0
194 |             if volume_data is not None and len(volume_data) >= 20:
    |                                                                ^^ PLR2004
195 |                 avg_volume = volume_data['volume'].rolling(20).mean().iloc[-1]
196 |                 current_volume = volume_data['volume'].iloc[-1]
    |

scripts/algorithm_optimizer.py:201:64: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
199 |             # Market correlation (simplified)
200 |             correlation_to_market = 0.5
201 |             if market_data is not None and len(market_data) >= 20:
    |                                                                ^^ PLR2004
202 |                 market_returns = market_data['close'].pct_change().dropna()
203 |                 if len(market_returns) >= len(returns):
    |

scripts/algorithm_optimizer.py:228:16: BLE001 Do not catch blind exception: `Exception`
    |
226 |             return conditions
227 | 
228 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
229 |             self.logger.error(f"Error detecting market regime: {e}")
230 |             # Return default conditions on error
    |

scripts/algorithm_optimizer.py:246:25: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
244 |         """Classify market regime based on indicators."""
245 |         # High volatility threshold
246 |         if volatility > 0.3:
    |                         ^^^ PLR2004
247 |             return MarketRegime.VOLATILE
    |

scripts/algorithm_optimizer.py:250:25: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
249 |         # Low volatility threshold
250 |         if volatility < 0.1:
    |                         ^^^ PLR2004
251 |             return MarketRegime.LOW_VOLATILITY
    |

scripts/algorithm_optimizer.py:257:32: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
255 |             # Check if trending up or down
256 |             recent_return = returns.tail(5).mean()
257 |             if recent_return > 0.01:
    |                                ^^^^ PLR2004
258 |                 return MarketRegime.BULL_MARKET
259 |             elif recent_return < -0.01:
    |

scripts/algorithm_optimizer.py:259:34: PLR2004 Magic value used in comparison, consider replacing `-0.01` with a constant variable
    |
257 |             if recent_return > 0.01:
258 |                 return MarketRegime.BULL_MARKET
259 |             elif recent_return < -0.01:
    |                                  ^^^^^ PLR2004
260 |                 return MarketRegime.BEAR_MARKET
261 |             else:
    |

scripts/algorithm_optimizer.py:272:23: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
271 |         # EST trading hours (simplified)
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
    |                       ^ PLR2004
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |

scripts/algorithm_optimizer.py:272:41: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
271 |         # EST trading hours (simplified)
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
    |                                         ^ PLR2004
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |

scripts/algorithm_optimizer.py:272:60: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
271 |         # EST trading hours (simplified)
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
    |                                                            ^^ PLR2004
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |

scripts/algorithm_optimizer.py:274:26: PLR2004 Magic value used in comparison, consider replacing `9` with a constant variable
    |
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |                          ^ PLR2004
275 |             return TradingPhase.MARKET_OPEN
276 |         elif now.hour < 15:
    |

scripts/algorithm_optimizer.py:274:44: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |                                            ^^ PLR2004
275 |             return TradingPhase.MARKET_OPEN
276 |         elif now.hour < 15:
    |

scripts/algorithm_optimizer.py:274:64: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
272 |         if now.hour < 9 or (now.hour == 9 and now.minute < 30):
273 |             return TradingPhase.PRE_MARKET
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
    |                                                                ^^ PLR2004
275 |             return TradingPhase.MARKET_OPEN
276 |         elif now.hour < 15:
    |

scripts/algorithm_optimizer.py:276:25: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
274 |         elif now.hour == 9 or (now.hour == 10 and now.minute < 30):
275 |             return TradingPhase.MARKET_OPEN
276 |         elif now.hour < 15:
    |                         ^^ PLR2004
277 |             return TradingPhase.MID_DAY
278 |         elif now.hour < 16:
    |

scripts/algorithm_optimizer.py:278:25: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
    |
276 |         elif now.hour < 15:
277 |             return TradingPhase.MID_DAY
278 |         elif now.hour < 16:
    |                         ^^ PLR2004
279 |             return TradingPhase.LATE_DAY
280 |         else:
    |

scripts/algorithm_optimizer.py:326:16: BLE001 Do not catch blind exception: `Exception`
    |
324 |             return optimized
325 | 
326 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
327 |             self.logger.error(f"Error optimizing parameters: {e}")
328 |             return self.current_parameters
    |

scripts/algorithm_optimizer.py:387:25: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
386 |         # Adjust lookback periods
387 |         if volatility > 0.3:
    |                         ^^^ PLR2004
388 |             params.volatility_lookback = 10  # Shorter lookback in high vol
389 |         elif volatility < 0.15:
    |

scripts/algorithm_optimizer.py:389:27: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
    |
387 |         if volatility > 0.3:
388 |             params.volatility_lookback = 10  # Shorter lookback in high vol
389 |         elif volatility < 0.15:
    |                           ^^^^ PLR2004
390 |             params.volatility_lookback = 30  # Longer lookback in low vol
    |

scripts/algorithm_optimizer.py:417:31: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
415 |                               performance: list[float]) -> OptimizedParameters:
416 |         """Adjust parameters based on recent performance."""
417 |         if len(performance) < 5:
    |                               ^ PLR2004
418 |             return params
    |

scripts/algorithm_optimizer.py:425:23: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
424 |         # Performance-based adjustments
425 |         if win_rate < 0.4:  # Poor win rate
    |                       ^^^ PLR2004
426 |             # More conservative
427 |             params.position_size_multiplier *= 0.8
    |

scripts/algorithm_optimizer.py:430:25: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
428 |             params.stop_loss_multiplier *= 0.9
429 | 
430 |         elif win_rate > 0.7:  # Good win rate
    |                         ^^^ PLR2004
431 |             # More aggressive
432 |             params.position_size_multiplier *= 1.1
    |

scripts/algorithm_optimizer.py:435:25: PLR2004 Magic value used in comparison, consider replacing `-0.02` with a constant variable
    |
433 |             params.take_profit_multiplier *= 1.1
434 | 
435 |         if avg_return < -0.02:  # Losing streak
    |                         ^^^^^ PLR2004
436 |             # Very conservative
437 |             params.position_size_multiplier *= 0.7
    |

scripts/algorithm_optimizer.py:514:20: BLE001 Do not catch blind exception: `Exception`
    |
512 |                 return final_shares
513 | 
514 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
515 |                 self.logger.error(f"Error calculating position size: {e}")
516 |                 return 0
    |

scripts/algorithm_optimizer.py:527:42: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
525 |                     symbol_performance.append(record.get('return', 0.0))
526 | 
527 |             if len(symbol_performance) < 10:  # Need minimum sample size
    |                                          ^^ PLR2004
528 |                 return 0.02  # Default conservative fraction
    |

scripts/algorithm_optimizer.py:561:16: BLE001 Do not catch blind exception: `Exception`
    |
559 |             return kelly_fraction
560 | 
561 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
562 |             self.logger.error(f"Error calculating Kelly fraction: {e}")
563 |             return 0.02  # Conservative default
    |

scripts/algorithm_optimizer.py:565:31: F821 Undefined name `account_value`
    |
563 |             return 0.02  # Conservative default
564 |             # Default to minimum position
565 |             return max(1, int(account_value * 0.001 / price))
    |                               ^^^^^^^^^^^^^ F821
566 | 
567 |     def _get_regime_multiplier(self, regime: MarketRegime) -> float:
    |

scripts/algorithm_optimizer.py:565:55: F821 Undefined name `price`
    |
563 |             return 0.02  # Conservative default
564 |             # Default to minimum position
565 |             return max(1, int(account_value * 0.001 / price))
    |                                                       ^^^^^ F821
566 | 
567 |     def _get_regime_multiplier(self, regime: MarketRegime) -> float:
    |

scripts/algorithm_optimizer.py:617:16: BLE001 Do not catch blind exception: `Exception`
    |
615 |             return round(stop_price, 2)
616 | 
617 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
618 |             self.logger.error(f"Error calculating stop loss: {e}")
619 |             # Default stop loss
    |

scripts/algorithm_optimizer.py:641:16: BLE001 Do not catch blind exception: `Exception`
    |
639 |             return round(take_profit_price, 2)
640 | 
641 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
642 |             self.logger.error(f"Error calculating take profit: {e}")
643 |             # Default take profit
    |

scripts/algorithm_optimizer.py:666:33: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
664 |             )
665 |             assert test_size > 0, "Position size must be positive"
666 |             assert test_size <= 100, "Position size should be reasonable for test account"
    |                                 ^^^ PLR2004
667 |             validation_results['tests_passed'] += 1
668 |             validation_results['tests_run'].append('position_sizing')
    |

scripts/algorithm_optimizer.py:669:16: BLE001 Do not catch blind exception: `Exception`
    |
667 |             validation_results['tests_passed'] += 1
668 |             validation_results['tests_run'].append('position_sizing')
669 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
670 |             validation_results['tests_failed'] += 1
671 |             validation_results['issues_found'].append(f"Position sizing error: {e}")
    |

scripts/algorithm_optimizer.py:676:20: PLR2004 Magic value used in comparison, consider replacing `90.0` with a constant variable
    |
674 |         try:
675 |             stop = self.calculate_stop_loss(100.0, 'BUY', 0.02, 2.0)
676 |             assert 90.0 <= stop <= 99.0, f"Stop loss {stop} should be reasonable"
    |                    ^^^^ PLR2004
677 |             validation_results['tests_passed'] += 1
678 |             validation_results['tests_run'].append('stop_loss_calculation')
    |

scripts/algorithm_optimizer.py:676:36: PLR2004 Magic value used in comparison, consider replacing `99.0` with a constant variable
    |
674 |         try:
675 |             stop = self.calculate_stop_loss(100.0, 'BUY', 0.02, 2.0)
676 |             assert 90.0 <= stop <= 99.0, f"Stop loss {stop} should be reasonable"
    |                                    ^^^^ PLR2004
677 |             validation_results['tests_passed'] += 1
678 |             validation_results['tests_run'].append('stop_loss_calculation')
    |

scripts/algorithm_optimizer.py:679:16: BLE001 Do not catch blind exception: `Exception`
    |
677 |             validation_results['tests_passed'] += 1
678 |             validation_results['tests_run'].append('stop_loss_calculation')
679 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
680 |             validation_results['tests_failed'] += 1
681 |             validation_results['issues_found'].append(f"Stop loss calculation error: {e}")
    |

scripts/algorithm_optimizer.py:686:29: PLR2004 Magic value used in comparison, consider replacing `100.0` with a constant variable
    |
684 |         try:
685 |             profit = self.calculate_take_profit(100.0, 'BUY', 98.0, 2.0)
686 |             assert profit > 100.0, f"Take profit {profit} should be above entry"
    |                             ^^^^^ PLR2004
687 |             validation_results['tests_passed'] += 1
688 |             validation_results['tests_run'].append('take_profit_calculation')
    |

scripts/algorithm_optimizer.py:689:16: BLE001 Do not catch blind exception: `Exception`
    |
687 |             validation_results['tests_passed'] += 1
688 |             validation_results['tests_run'].append('take_profit_calculation')
689 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
690 |             validation_results['tests_failed'] += 1
691 |             validation_results['issues_found'].append(f"Take profit calculation error: {e}")
    |

scripts/algorithm_optimizer.py:702:16: BLE001 Do not catch blind exception: `Exception`
    |
700 |             validation_results['tests_passed'] += 1
701 |             validation_results['tests_run'].append('parameter_optimization')
702 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
703 |             validation_results['tests_failed'] += 1
704 |             validation_results['issues_found'].append(f"Parameter optimization error: {e}")
    |

scripts/algorithm_optimizer.py:735:12: PLW0603 Using the global statement to update `_algorithm_optimizer` is discouraged
    |
733 | def get_algorithm_optimizer() -> AlgorithmOptimizer:
734 |     """Get global algorithm optimizer instance."""
735 |     global _algorithm_optimizer
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
736 |     if _algorithm_optimizer is None:
737 |         _algorithm_optimizer = AlgorithmOptimizer()
    |

scripts/algorithm_optimizer.py:743:12: PLW0603 Using the global statement to update `_algorithm_optimizer` is discouraged
    |
741 | def initialize_algorithm_optimizer() -> AlgorithmOptimizer:
742 |     """Initialize algorithm optimizer."""
743 |     global _algorithm_optimizer
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
744 |     _algorithm_optimizer = AlgorithmOptimizer()
745 |     return _algorithm_optimizer
    |

scripts/audit.py:9:8: BLE001 Do not catch blind exception: `Exception`
   |
 7 |     from ai_trading.validation.validate_env import Settings
 8 |     settings = Settings()
 9 | except Exception:
   |        ^^^^^^^^^ BLE001
10 |     settings = None
   |

scripts/audit.py:52:5: PLR0911 Too many return statements (8 > 6)
   |
52 | def log_trade(symbol, qty, side, fill_price, timestamp, extra_info=None, exposure=None):
   |     ^^^^^^^^^ PLR0911
53 |     """Persist a trade event to ``TRADE_LOG_FILE`` and log a summary."""
54 |     global _disable_trade_log
   |

scripts/audit.py:54:12: PLW0603 Using the global statement to update `_disable_trade_log` is discouraged
   |
52 | def log_trade(symbol, qty, side, fill_price, timestamp, extra_info=None, exposure=None):
53 |     """Persist a trade event to ``TRADE_LOG_FILE`` and log a summary."""
54 |     global _disable_trade_log
   |            ^^^^^^^^^^^^^^^^^^ PLW0603
55 | 
56 |     # AI-AGENT-REF: Robust parameter validation with auto-correction for common mistakes
   |

scripts/audit.py:54:12: PLW0603 Using the global statement to update `_disable_trade_log` is discouraged
   |
52 | def log_trade(symbol, qty, side, fill_price, timestamp, extra_info=None, exposure=None):
53 |     """Persist a trade event to ``TRADE_LOG_FILE`` and log a summary."""
54 |     global _disable_trade_log
   |            ^^^^^^^^^^^^^^^^^^ PLW0603
55 | 
56 |     # AI-AGENT-REF: Robust parameter validation with auto-correction for common mistakes
   |

scripts/audit.py:54:12: PLW0603 Using the global statement to update `_disable_trade_log` is discouraged
   |
52 | def log_trade(symbol, qty, side, fill_price, timestamp, extra_info=None, exposure=None):
53 |     """Persist a trade event to ``TRADE_LOG_FILE`` and log a summary."""
54 |     global _disable_trade_log
   |            ^^^^^^^^^^^^^^^^^^ PLW0603
55 | 
56 |     # AI-AGENT-REF: Robust parameter validation with auto-correction for common mistakes
   |

scripts/audit.py:215:24: BLE001 Do not catch blind exception: `Exception`
    |
213 |                     logger.info("Trade log successfully written after permission repair")
214 |                     return  # Success, don't disable logging
215 |                 except Exception as retry_exc:
    |                        ^^^^^^^^^ BLE001
216 |                     logger.error("Trade log retry failed after permission repair: %s", retry_exc)
217 |             else:
    |

scripts/audit.py:220:16: BLE001 Do not catch blind exception: `Exception`
    |
218 |                 logger.warning("Failed to repair file permissions automatically")
219 | 
220 |         except Exception as repair_exc:
    |                ^^^^^^^^^ BLE001
221 |             logger.warning("Permission repair attempt failed: %s", repair_exc)
    |

scripts/audit.py:226:12: BLE001 Do not catch blind exception: `Exception`
    |
224 |             _disable_trade_log = True
225 |             logger.warning("Trade log disabled due to permission error")
226 |     except Exception as exc:  # pragma: no cover - other I/O errors
    |            ^^^^^^^^^ BLE001
227 |         logger.error("Failed to record trade: %s", exc)
    |

scripts/audit.py:239:12: BLE001 Do not catch blind exception: `Exception`
    |
237 |         with open(fname, "w", encoding="utf-8") as f:
238 |             json.dump(details, f, indent=2, default=str)
239 |     except Exception as exc:  # pragma: no cover - best effort
    |            ^^^^^^^^^ BLE001
240 |         logger.warning("Failed JSON audit log %s: %s", fname, exc)
    |

scripts/backtest_framework.py:57:49: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
   |
56 |         assert total_pnl > 0, f"Negative total PnL: {total_pnl}"
57 |         assert win_rate / max(1, trade_count) > 0.4
   |                                                 ^^^ PLR2004
58 | 
59 |     def test_volatility_calculation(self):
   |

scripts/backtest_framework.py:64:16: PLR2004 Magic value used in comparison, consider replacing `0.009` with a constant variable
   |
62 |         vol = self.risk_engine.compute_volatility(returns)
63 | 
64 |         assert 0.009 <= vol["volatility"] <= 0.011
   |                ^^^^^ PLR2004
65 | 
66 |         returns_with_outliers = returns.copy()
   |

scripts/backtest_framework.py:64:46: PLR2004 Magic value used in comparison, consider replacing `0.011` with a constant variable
   |
62 |         vol = self.risk_engine.compute_volatility(returns)
63 | 
64 |         assert 0.009 <= vol["volatility"] <= 0.011
   |                                              ^^^^^ PLR2004
65 | 
66 |         returns_with_outliers = returns.copy()
   |

scripts/backtest_framework.py:108:16: BLE001 Do not catch blind exception: `Exception`
    |
106 |         try:
107 |             self.cleanup()
108 |         except Exception:
    |                ^^^^^^^^^ BLE001
109 |             pass
    |

scripts/check_feed.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Small diagnostic to verify market data fetch."""
 2 |   
 3 | / from types import SimpleNamespace
 4 | | 
 5 | | import pandas as pd
 6 | | import pytz  # noqa: F401
 7 | | 
 8 | | from ai_trading.core.runtime import build_runtime
 9 | | from ai_trading.data.bars import safe_get_stock_bars
10 | | 
11 | | if __name__ == "__main__":  # pragma: no cover - manual use
   | |_^ I001
12 |       rt = build_runtime(SimpleNamespace())
13 |       # AI-AGENT-REF: use timezone-aware UTC now for diagnostics
   |
   = help: Organize imports

scripts/circuit_breaker.py:293:12: BLE001 Do not catch blind exception: `Exception`
    |
291 |             signal.alarm(0)  # Disable alarm
292 | 
293 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
294 |         logger.warning(f"Health check for {name} failed: {e}")
295 |         return False
    |

scripts/config_server.py:10:1: E402 Module level import not at top of file
   |
 8 | # Map old names if needed
 9 | set_runtime_config = getattr(config, "set_runtime_config", None)
10 | from flask import Flask, jsonify, request
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
11 | 
12 | app = Flask(__name__)
   |

scripts/config_server.py:16:5: PLR0911 Too many return statements (7 > 6)
   |
15 | @app.route("/update_config", methods=["POST"])
16 | def update_config():
   |     ^^^^^^^^^^^^^ PLR0911
17 |     try:
18 |         data = request.get_json()
   |

scripts/config_server.py:25:17: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
23 |         ml_thr = float(data.get("ml_confidence_threshold", 0.5))
24 | 
25 |         if not (0.1 <= volume_thr <= 10.0):
   |                 ^^^ PLR2004
26 |             return jsonify({"error": "volume_spike_threshold must be between 0.1 and 10.0"}), 400
27 |         if not (0.0 <= ml_thr <= 1.0):
   |

scripts/config_server.py:25:38: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
   |
23 |         ml_thr = float(data.get("ml_confidence_threshold", 0.5))
24 | 
25 |         if not (0.1 <= volume_thr <= 10.0):
   |                                      ^^^^ PLR2004
26 |             return jsonify({"error": "volume_spike_threshold must be between 0.1 and 10.0"}), 400
27 |         if not (0.0 <= ml_thr <= 1.0):
   |

scripts/critical_fixes_validation.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import sys
11 | import unittest
   |

scripts/critical_fixes_validation.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
   | ^^^^^^^^^^ E402
11 | import unittest
   |

scripts/critical_fixes_validation.py:11:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
11 | import unittest
   | ^^^^^^^^^^^^^^^ E402
12 | 
13 | # Set testing environment
   |

scripts/critical_fixes_validation.py:26:27: F821 Undefined name `bot_engine`
   |
24 |         """Set up test environment."""
25 |         # Import modules after setting TESTING flag
26 |         self.bot_engine = bot_engine
   |                           ^^^^^^^^^^ F821
27 | 
28 |     def test_p0_quantity_calculation_fix(self):
   |

scripts/critical_fixes_validation.py:53:16: BLE001 Do not catch blind exception: `Exception`
   |
51 |             logging.info("  ✓ Quantity calculation uses actual order filled_qty")
52 |             logging.info("  ✓ Fixed discrepancy between calculated vs actual quantities")
53 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
54 |             self.fail(f"Quantity fix failed: {e}")
   |

scripts/debug_cli.py:18:1: E402 Module level import not at top of file
   |
16 | """
17 | 
18 | import argparse
   | ^^^^^^^^^^^^^^^ E402
19 | import os
20 | import sys
   |

scripts/debug_cli.py:19:1: E402 Module level import not at top of file
   |
18 | import argparse
19 | import os
   | ^^^^^^^^^ E402
20 | import sys
21 | from datetime import datetime
   |

scripts/debug_cli.py:20:1: E402 Module level import not at top of file
   |
18 | import argparse
19 | import os
20 | import sys
   | ^^^^^^^^^^ E402
21 | from datetime import datetime
   |

scripts/debug_cli.py:21:1: E402 Module level import not at top of file
   |
19 | import os
20 | import sys
21 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
22 | 
23 | # Set required environment variables for CLI usage
   |

scripts/debug_cli.py:55:41: PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   |
54 |         # Overall health indicator
55 |         if exec_stats['success_rate'] > 0.95 and recon_stats['current_discrepancies'] == 0:
   |                                         ^^^^ PLR2004
56 |             logging.info("🟢 System Status: HEALTHY")
57 |         elif exec_stats['success_rate'] > 0.8:
   |

scripts/debug_cli.py:57:43: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
   |
55 |         if exec_stats['success_rate'] > 0.95 and recon_stats['current_discrepancies'] == 0:
56 |             logging.info("🟢 System Status: HEALTHY")
57 |         elif exec_stats['success_rate'] > 0.8:
   |                                           ^^^ PLR2004
58 |             logging.info("🟡 System Status: CAUTION")
59 |         else:
   |

scripts/debug_cli.py:62:12: BLE001 Do not catch blind exception: `Exception`
   |
60 |             logging.info("🔴 System Status: ISSUES DETECTED")
61 | 
62 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
63 |         logging.info(f"❌ Error getting status: {e}")
   |

scripts/debug_cli.py:111:12: BLE001 Do not catch blind exception: `Exception`
    |
109 |             logging.info("No recent executions found.")
110 | 
111 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
112 |         logging.info(f"❌ Error getting executions: {e}")
    |

scripts/debug_cli.py:154:12: BLE001 Do not catch blind exception: `Exception`
    |
152 |             logging.info("\n✅ No discrepancies found - positions are in sync")
153 | 
154 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
155 |         logging.info(f"❌ Error checking positions: {e}")
    |

scripts/debug_cli.py:226:12: BLE001 Do not catch blind exception: `Exception`
    |
224 |                         logging.info(f"  {source}: ${amount:+.2f}")
225 | 
226 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
227 |         logging.info(f"❌ Error getting PnL data: {e}")
    |

scripts/debug_cli.py:276:17: PLR1704 Redefining argument with the local name `correlation_id`
    |
274 |                     all_ids.add(exec_data['correlation_id'])
275 | 
276 |             for correlation_id in sorted(all_ids):
    |                 ^^^^^^^^^^^^^^ PLR1704
277 |                 logging.info(f"  {correlation_id}")
    |

scripts/debug_cli.py:279:12: BLE001 Do not catch blind exception: `Exception`
    |
277 |                 logging.info(f"  {correlation_id}")
278 | 
279 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
280 |         logging.info(f"❌ Error tracing execution: {e}")
    |

scripts/debug_cli.py:301:41: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
299 |         exec_stats = get_execution_statistics()
300 | 
301 |         if exec_stats['success_rate'] < 0.9:
    |                                         ^^^ PLR2004
302 |             issues.append(f"Low execution success rate: {exec_stats['success_rate']:.1%}")
    |

scripts/debug_cli.py:304:42: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
302 |             issues.append(f"Low execution success rate: {exec_stats['success_rate']:.1%}")
303 | 
304 |         if exec_stats['active_orders'] > 10:
    |                                          ^^ PLR2004
305 |             issues.append(f"High number of active orders: {exec_stats['active_orders']}")
    |

scripts/debug_cli.py:338:12: BLE001 Do not catch blind exception: `Exception`
    |
336 |         logging.info(f"  PnL events tracked: {pnl_stats.get('total_events', 0)}")
337 | 
338 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
339 |         logging.info(f"❌ Error running health check: {e}")
    |

scripts/debug_cli.py:397:12: BLE001 Do not catch blind exception: `Exception`
    |
395 |     except KeyboardInterrupt:
396 |         logging.info("\n👋 Goodbye!")
397 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
398 |         logging.info(f"\n❌ Unexpected error: {e}")
399 |         sys.exit(1)
    |

scripts/debug_drawdown.py:6:1: E402 Module level import not at top of file
  |
4 | """Debug the drawdown circuit breaker status variable issue."""
5 | 
6 | import os
  | ^^^^^^^^^ E402
7 | import sys
8 | import traceback
  |

scripts/debug_drawdown.py:7:1: E402 Module level import not at top of file
  |
6 | import os
7 | import sys
  | ^^^^^^^^^^ E402
8 | import traceback
  |

scripts/debug_drawdown.py:8:1: E402 Module level import not at top of file
   |
 6 | import os
 7 | import sys
 8 | import traceback
   | ^^^^^^^^^^^^^^^^ E402
 9 | 
10 | # Set testing environment
   |

scripts/debug_drawdown.py:49:12: BLE001 Do not catch blind exception: `Exception`
   |
47 |         return True
48 | 
49 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
50 |         logging.info(f"❌ Error in drawdown test: {e}")
51 |         logging.info(f"Traceback: {traceback.format_exc()}")
   |

scripts/debug_drawdown.py:73:20: BLE001 Do not catch blind exception: `Exception`
   |
71 |                 status = breaker.get_status()
72 |                 logging.info(str(f"Update {i+1}: equity=${equity:.2f}, result={result}, state={status['state']}"))
73 |             except Exception as e:
   |                    ^^^^^^^^^ BLE001
74 |                 logging.info(f"❌ Error on update {i+1}: {e}")
75 |                 logging.info(f"Traceback: {traceback.format_exc()}")
   |

scripts/debug_drawdown.py:81:12: BLE001 Do not catch blind exception: `Exception`
   |
79 |         return True
80 | 
81 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
82 |         logging.info(f"❌ Error in status variable test: {e}")
83 |         logging.info(f"Traceback: {traceback.format_exc()}")
   |

scripts/demo_centralized_imports.py:13:1: E402 Module level import not at top of file
   |
11 | """
12 | 
13 | import os
   | ^^^^^^^^^ E402
14 | import sys
   |

scripts/demo_centralized_imports.py:14:1: E402 Module level import not at top of file
   |
13 | import os
14 | import sys
   | ^^^^^^^^^^ E402
15 | 
16 | # Add the current directory to the path for demo
   |

scripts/demo_drawdown_protection.py:12:1: E402 Module level import not at top of file
   |
10 | """
11 | 
12 | import os
   | ^^^^^^^^^ E402
13 | 
14 | os.environ["TESTING"] = "1"
   |

scripts/demo_drawdown_protection.py:16:1: E402 Module level import not at top of file
   |
14 | os.environ["TESTING"] = "1"
15 | 
16 | from ai_trading.config import management as config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
17 | from ai_trading.config.management import TradingConfig
18 | from ai_trading.risk.circuit_breakers import DrawdownCircuitBreaker
   |

scripts/demo_drawdown_protection.py:17:1: E402 Module level import not at top of file
   |
16 | from ai_trading.config import management as config
17 | from ai_trading.config.management import TradingConfig
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
18 | from ai_trading.risk.circuit_breakers import DrawdownCircuitBreaker
   |

scripts/demo_drawdown_protection.py:18:1: E402 Module level import not at top of file
   |
16 | from ai_trading.config import management as config
17 | from ai_trading.config.management import TradingConfig
18 | from ai_trading.risk.circuit_breakers import DrawdownCircuitBreaker
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
19 | 
20 | CONFIG = TradingConfig()
   |

scripts/demo_enhanced_debugging.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import time
11 | from datetime import UTC, datetime
   |

scripts/demo_enhanced_debugging.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import time
   | ^^^^^^^^^^^ E402
11 | from datetime import UTC, datetime
   |

scripts/demo_enhanced_debugging.py:11:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import time
11 | from datetime import UTC, datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
12 | 
13 | # Set environment variables for demo
   |

scripts/demo_enhanced_debugging.py:401:12: BLE001 Do not catch blind exception: `Exception`
    |
399 |         logging.info("4. Debug: Use correlation IDs to trace specific order issues")
400 | 
401 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
402 |         logging.info(f"\nDemonstration failed: {e}")
403 |         import traceback
    |

scripts/demo_grid_search.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import tempfile
   | ^^^^^^^^^^^^^^^ E402
10 | 
11 | from ai_trading.backtesting.grid_runner import grid_search, persist_artifacts
   |

scripts/demo_grid_search.py:11:1: E402 Module level import not at top of file
   |
 9 | import tempfile
10 | 
11 | from ai_trading.backtesting.grid_runner import grid_search, persist_artifacts
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/demo_no_trade_bands.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | 
11 | os.environ['ALPACA_API_KEY'] = 'demo'
   |

scripts/demo_no_trade_bands.py:17:1: E402 Module level import not at top of file
   |
15 | os.environ['FLASK_PORT'] = '5000'
16 | 
17 | from ai_trading.rebalancer import apply_no_trade_bands
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/demo_no_trade_bands.py:76:55: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
74 |             final_delta_bps = (final - current) * 10000
75 | 
76 |             trade_avoided = abs(original_delta_bps) > 0.1 and abs(final_delta_bps) < 0.1
   |                                                       ^^^ PLR2004
77 |             trade_executed = abs(final_delta_bps) > 0.1
   |

scripts/demo_no_trade_bands.py:76:86: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
74 |             final_delta_bps = (final - current) * 10000
75 | 
76 |             trade_avoided = abs(original_delta_bps) > 0.1 and abs(final_delta_bps) < 0.1
   |                                                                                      ^^^ PLR2004
77 |             trade_executed = abs(final_delta_bps) > 0.1
   |

scripts/demo_no_trade_bands.py:77:53: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
76 |             trade_avoided = abs(original_delta_bps) > 0.1 and abs(final_delta_bps) < 0.1
77 |             trade_executed = abs(final_delta_bps) > 0.1
   |                                                     ^^^ PLR2004
78 | 
79 |             if trade_executed:
   |

scripts/demo_position_holding.py:13:1: E402 Module level import not at top of file
   |
11 | """
12 | 
13 | import os
   | ^^^^^^^^^ E402
14 | from datetime import UTC, datetime
   |

scripts/demo_position_holding.py:14:1: E402 Module level import not at top of file
   |
13 | import os
14 | from datetime import UTC, datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
15 | 
16 | # Set required environment variables for demo
   |

scripts/demo_position_holding.py:205:12: BLE001 Do not catch blind exception: `Exception`
    |
203 |         logging.info("\nReady for deployment! 🎉")
204 | 
205 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
206 |         logging.info(f"❌ Demo failed: {e}")
207 |         import traceback
    |

scripts/demo_short_selling_implementation.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import sys
11 | import time
   |

scripts/demo_short_selling_implementation.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
   | ^^^^^^^^^^ E402
11 | import time
12 | from unittest.mock import Mock, patch
   |

scripts/demo_short_selling_implementation.py:11:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
11 | import time
   | ^^^^^^^^^^^ E402
12 | from unittest.mock import Mock, patch
   |

scripts/demo_short_selling_implementation.py:12:1: E402 Module level import not at top of file
   |
10 | import sys
11 | import time
12 | from unittest.mock import Mock, patch
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
13 | 
14 | # Set minimal environment variables
   |

scripts/demo_short_selling_implementation.py:63:32: BLE001 Do not catch blind exception: `Exception`
   |
61 |                         try:
62 |                             result = engine.execute_order("AAPL", 10, "sell_short")
63 |                         except Exception:
   |                                ^^^^^^^^^ BLE001
64 |                             pass  # Expected to stop at liquidity check
65 |                         logging.info("✓ sell_short order bypassed position checks and reached validation")
   |

scripts/demo_short_selling_implementation.py:83:12: BLE001 Do not catch blind exception: `Exception`
   |
81 |         logging.info("✓ Short selling implementation working correctly!")
82 | 
83 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
84 |         logging.info(f"✗ Error in short selling demonstration: {e}")
85 |         return False
   |

scripts/demo_short_selling_implementation.py:129:12: BLE001 Do not catch blind exception: `Exception`
    |
127 |         logging.info("✓ Order monitoring implementation working correctly!")
128 | 
129 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
130 |         logging.info(f"✗ Error in order monitoring demonstration: {e}")
131 |         return False
    |

scripts/demo_short_selling_implementation.py:153:12: BLE001 Do not catch blind exception: `Exception`
    |
151 |         logging.info("✓ Meta-learning graceful degradation working correctly!")
152 | 
153 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
154 |         logging.info(f"✗ Error in meta-learning demonstration: {e}")
155 |         return False
    |

scripts/demonstrate_optimization.py:11:1: E402 Module level import not at top of file
   |
 9 | """
10 | 
11 | import os
   | ^^^^^^^^^ E402
12 | import sys
13 | from datetime import datetime
   |

scripts/demonstrate_optimization.py:12:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
   | ^^^^^^^^^^ E402
13 | from datetime import datetime
   |

scripts/demonstrate_optimization.py:13:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
13 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
14 | 
15 | # Add the project root to Python path for imports
   |

scripts/demonstrate_optimization.py:19:1: E402 Module level import not at top of file
   |
18 | # Use the centralized logger as per AGENTS.md
19 | from ai_trading.config.management import TradingConfig
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
20 | from ai_trading.logging import logger
   |

scripts/demonstrate_optimization.py:20:1: E402 Module level import not at top of file
   |
18 | # Use the centralized logger as per AGENTS.md
19 | from ai_trading.config.management import TradingConfig
20 | from ai_trading.logging import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
21 | 
22 | CONFIG = TradingConfig()
   |

scripts/demonstrate_optimization.py:204:12: BLE001 Do not catch blind exception: `Exception`
    |
202 |         return False
203 | 
204 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
205 |         logging.info(f"\n❌ Error during demonstration: {e}")
206 |         logger.error(f"Demonstration error: {e}")
    |

scripts/demonstrate_optimization_simple.py:10:1: E402 Module level import not at top of file
   |
 8 | """
 9 | 
10 | import os
   | ^^^^^^^^^ E402
11 | import sys
12 | from datetime import datetime
   |

scripts/demonstrate_optimization_simple.py:11:1: E402 Module level import not at top of file
   |
10 | import os
11 | import sys
   | ^^^^^^^^^^ E402
12 | from datetime import datetime
   |

scripts/demonstrate_optimization_simple.py:12:1: E402 Module level import not at top of file
   |
10 | import os
11 | import sys
12 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
13 | 
14 | # Add the project root to Python path for imports
   |

scripts/demonstrate_optimization_simple.py:194:12: BLE001 Do not catch blind exception: `Exception`
    |
192 |         return True
193 | 
194 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
195 |         logging.info(f"\n❌ Error during demonstration: {e}")
196 |         return False
    |

scripts/demonstrate_portfolio_optimization.py:11:1: E402 Module level import not at top of file
   |
 9 | """
10 | 
11 | import os
   | ^^^^^^^^^ E402
12 | import sys
   |

scripts/demonstrate_portfolio_optimization.py:12:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
   | ^^^^^^^^^^ E402
13 | 
14 | # Set testing environment
   |

scripts/demonstrate_portfolio_optimization.py:20:1: E402 Module level import not at top of file
   |
18 | sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
19 | 
20 | from portfolio_optimizer import PortfolioDecision, create_portfolio_optimizer
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
21 | from transaction_cost_calculator import create_transaction_cost_calculator
   |

scripts/demonstrate_portfolio_optimization.py:20:1: I001 [*] Import block is un-sorted or un-formatted
   |
18 |   sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
19 |   
20 | / from portfolio_optimizer import PortfolioDecision, create_portfolio_optimizer
21 | | from transaction_cost_calculator import create_transaction_cost_calculator
22 | | 
23 | | from ai_trading.strategies.regime_detector import create_regime_detector
24 | | 
25 | | 
26 | | def demonstrate_portfolio_optimization():
   | |_^ I001
27 |       """Demonstrate the portfolio optimization capabilities."""
28 |       logging.info(str("=" * 80))
   |
   = help: Organize imports

scripts/demonstrate_portfolio_optimization.py:21:1: E402 Module level import not at top of file
   |
20 | from portfolio_optimizer import PortfolioDecision, create_portfolio_optimizer
21 | from transaction_cost_calculator import create_transaction_cost_calculator
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
22 | 
23 | from ai_trading.strategies.regime_detector import create_regime_detector
   |

scripts/demonstrate_portfolio_optimization.py:23:1: E402 Module level import not at top of file
   |
21 | from transaction_cost_calculator import create_transaction_cost_calculator
22 | 
23 | from ai_trading.strategies.regime_detector import create_regime_detector
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/demonstrate_portfolio_optimization.py:204:12: BLE001 Do not catch blind exception: `Exception`
    |
202 |     try:
203 |         demonstrate_portfolio_optimization()
204 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
205 |         logging.info(f"Error in demonstration: {e}")
206 |         import traceback
    |

scripts/download_backtest_data.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |   
 8 | / from __future__ import annotations
 9 | | 
10 | | import os
11 | | from pathlib import Path
12 | | 
13 | | import pandas as pd
14 | | from alpaca_trade_api import TimeFrame
15 | | from dotenv import load_dotenv
16 | | 
17 | | from ai_trading.utils.base import _get_alpaca_rest
18 | | 
19 | | 
20 | | def main() -> None:
   | |_^ I001
21 |       """Fetch bars for each symbol and save to ``data`` directory."""
22 |       load_dotenv(dotenv_path=".env", override=True)
   |
   = help: Organize imports

scripts/download_backtest_data.py:55:16: BLE001 Do not catch blind exception: `Exception`
   |
53 |                 adjustment="raw",
54 |             ).df
55 |         except Exception:  # pragma: no cover - network call
   |                ^^^^^^^^^ BLE001
56 |             continue
   |

scripts/error_handling.py:88:16: BLE001 Do not catch blind exception: `Exception`
   |
86 |         try:
87 |             return func()
88 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
89 |             if attempt < retries:
90 |                 logger.warning(f"API call failed (attempt {attempt + 1}/{retries + 1}): {e}")
   |

scripts/error_handling.py:130:12: BLE001 Do not catch blind exception: `Exception`
    |
128 |         return True
129 | 
130 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
131 |         logger.error("Error validating trade data: %s", e)
132 |         return False
    |

scripts/features.py:2:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 |   # AI-AGENT-REF: guard pandas/numpy imports for test environments
2 | / import logging
3 | | 
4 | | import pandas as pd
5 | | 
6 | | from ai_trading.indicators import atr, ema
7 | | 
8 | | logger = logging.getLogger(__name__)
  | |_^ I001
  |
  = help: Organize imports

scripts/features.py:20:12: BLE001 Do not catch blind exception: `Exception`
   |
18 |         df["ema26"] = ema(close, 26)
19 |         df["macd"] = df["ema12"] - df["ema26"]
20 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
21 |         logger.error("MACD calculation failed: %s", e)
22 |     return df
   |

scripts/final_validation.py:8:1: E402 Module level import not at top of file
   |
 6 | """
 7 | 
 8 | import csv
   | ^^^^^^^^^^ E402
 9 | import os
10 | import sys
   |

scripts/final_validation.py:9:1: E402 Module level import not at top of file
   |
 8 | import csv
 9 | import os
   | ^^^^^^^^^ E402
10 | import sys
   |

scripts/final_validation.py:10:1: E402 Module level import not at top of file
   |
 8 | import csv
 9 | import os
10 | import sys
   | ^^^^^^^^^^ E402
   |

scripts/final_validation.py:40:20: BLE001 Do not catch blind exception: `Exception`
   |
38 |                             if t and t not in tickers:
39 |                                 tickers.append(t)
40 |             except Exception as e:
   |                    ^^^^^^^^^ BLE001
41 |                 logging.info(f"Error reading {path}: {e}")
42 |             return tickers
   |

scripts/final_validation.py:61:28: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
59 |         logging.info(f"⚡ Energy stocks found: {len(energy_found)}/2 ({energy_found})")
60 | 
61 |         if len(tickers) >= 20:
   |                            ^^ PLR2004
62 |             logging.info("✅ Ticker portfolio successfully expanded!")
63 |             return True
   |

scripts/final_validation.py:68:12: BLE001 Do not catch blind exception: `Exception`
   |
66 |             return False
67 | 
68 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
69 |         logging.info(f"❌ Error testing ticker loading: {e}")
70 |         return False
   |

scripts/final_validation.py:100:12: BLE001 Do not catch blind exception: `Exception`
    |
 98 |         return passed == len(checks)
 99 | 
100 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
101 |         logging.info(f"❌ Error checking README: {e}")
102 |         return False
    |

scripts/final_validation.py:117:16: BLE001 Do not catch blind exception: `Exception`
    |
115 |         try:
116 |             results.append(test())
117 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
118 |             logging.info(f"❌ Test {test.__name__} failed: {e}")
119 |             results.append(False)
    |

scripts/final_validation_report.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import sys
   |

scripts/final_validation_report.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
   | ^^^^^^^^^^ E402
   |

scripts/final_validation_report.py:77:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
75 |             fixes_found += 1
76 | 
77 |         if fixes_found == 2:
   |                           ^ PLR2004
78 |             return True
   |

scripts/final_validation_report.py:143:27: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
    |
141 |     logging.info(f"✅ Issues Fixed: {fixes_validated}/4")
142 | 
143 |     if fixes_validated == 4:
    |                           ^ PLR2004
144 |         logging.info("🎉 ALL CRITICAL ISSUES SUCCESSFULLY FIXED!")
145 |         logging.info("\n💡 Expected Benefits:")
    |

scripts/health_check.py:34:60: F401 `production_monitoring.HealthCheckResult` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
32 |         get_production_monitor,
33 |     )
34 |     from production_monitoring import HealthCheckResult as ProdHealthCheckResult
   |                                                            ^^^^^^^^^^^^^^^^^^^^^ F401
35 |     from production_monitoring import HealthStatus as ProdHealthStatus
36 |     PRODUCTION_MONITORING_AVAILABLE = True
   |
   = help: Remove unused import: `production_monitoring.HealthCheckResult`

scripts/health_check.py:35:55: F401 `production_monitoring.HealthStatus` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
33 |     )
34 |     from production_monitoring import HealthCheckResult as ProdHealthCheckResult
35 |     from production_monitoring import HealthStatus as ProdHealthStatus
   |                                                       ^^^^^^^^^^^^^^^^ F401
36 |     PRODUCTION_MONITORING_AVAILABLE = True
37 | except ImportError:
   |
   = help: Remove unused import: `production_monitoring.HealthStatus`

scripts/health_check.py:84:20: BLE001 Do not catch blind exception: `Exception`
   |
82 |                 self.production_monitor = get_production_monitor()
83 |                 logger.info("Production monitoring integration enabled")
84 |             except Exception as e:
   |                    ^^^^^^^^^ BLE001
85 |                 logger.warning(f"Could not initialize production monitoring: {e}")
   |

scripts/health_check.py:194:30: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
193 |             # Determine status based on resource usage
194 |             if cpu_percent > 90 or memory.percent > 90:
    |                              ^^ PLR2004
195 |                 status = HealthStatus.CRITICAL
196 |                 message = f"High resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
    |

scripts/health_check.py:194:53: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
193 |             # Determine status based on resource usage
194 |             if cpu_percent > 90 or memory.percent > 90:
    |                                                     ^^ PLR2004
195 |                 status = HealthStatus.CRITICAL
196 |                 message = f"High resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
    |

scripts/health_check.py:197:32: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
195 |                 status = HealthStatus.CRITICAL
196 |                 message = f"High resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
197 |             elif cpu_percent > 70 or memory.percent > 70:
    |                                ^^ PLR2004
198 |                 status = HealthStatus.WARNING
199 |                 message = f"Moderate resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
    |

scripts/health_check.py:197:55: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
195 |                 status = HealthStatus.CRITICAL
196 |                 message = f"High resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
197 |             elif cpu_percent > 70 or memory.percent > 70:
    |                                                       ^^ PLR2004
198 |                 status = HealthStatus.WARNING
199 |                 message = f"Moderate resource usage: CPU {cpu_percent}%, Memory {memory.percent}%"
    |

scripts/health_check.py:212:16: BLE001 Do not catch blind exception: `Exception`
    |
210 |             )
211 | 
212 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
213 |             return HealthCheckResult(
214 |                 name="system_resources",
    |

scripts/health_check.py:235:48: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
233 |             }
234 | 
235 |             if free_gb < 1.0 or used_percent > 95:
    |                                                ^^ PLR2004
236 |                 status = HealthStatus.CRITICAL
237 |                 message = f"Low disk space: {free_gb:.1f}GB free ({used_percent:.1f}% used)"
    |

scripts/health_check.py:238:28: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
236 |                 status = HealthStatus.CRITICAL
237 |                 message = f"Low disk space: {free_gb:.1f}GB free ({used_percent:.1f}% used)"
238 |             elif free_gb < 5.0 or used_percent > 85:
    |                            ^^^ PLR2004
239 |                 status = HealthStatus.WARNING
240 |                 message = f"Moderate disk usage: {free_gb:.1f}GB free ({used_percent:.1f}% used)"
    |

scripts/health_check.py:238:50: PLR2004 Magic value used in comparison, consider replacing `85` with a constant variable
    |
236 |                 status = HealthStatus.CRITICAL
237 |                 message = f"Low disk space: {free_gb:.1f}GB free ({used_percent:.1f}% used)"
238 |             elif free_gb < 5.0 or used_percent > 85:
    |                                                  ^^ PLR2004
239 |                 status = HealthStatus.WARNING
240 |                 message = f"Moderate disk usage: {free_gb:.1f}GB free ({used_percent:.1f}% used)"
    |

scripts/health_check.py:253:16: BLE001 Do not catch blind exception: `Exception`
    |
251 |             )
252 | 
253 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
254 |             return HealthCheckResult(
255 |                 name="disk_space",
    |

scripts/health_check.py:275:28: PLR2004 Magic value used in comparison, consider replacing `2048` with a constant variable
    |
274 |             # Check for potential memory leaks
275 |             if memory_mb > 2048:  # More than 2GB
    |                            ^^^^ PLR2004
276 |                 status = HealthStatus.CRITICAL
277 |                 message = f"High memory usage: {memory_mb:.1f}MB"
    |

scripts/health_check.py:278:30: PLR2004 Magic value used in comparison, consider replacing `1024` with a constant variable
    |
276 |                 status = HealthStatus.CRITICAL
277 |                 message = f"High memory usage: {memory_mb:.1f}MB"
278 |             elif memory_mb > 1024:  # More than 1GB
    |                              ^^^^ PLR2004
279 |                 status = HealthStatus.WARNING
280 |                 message = f"Moderate memory usage: {memory_mb:.1f}MB"
    |

scripts/health_check.py:293:16: BLE001 Do not catch blind exception: `Exception`
    |
291 |             )
292 | 
293 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
294 |             return HealthCheckResult(
295 |                 name="memory_usage",
    |

scripts/health_check.py:330:38: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
329 |                         # Check for oversized log files
330 |                         if size_mb > 500:  # 500MB limit
    |                                      ^^^ PLR2004
331 |                             issues.append(f"{log_file}: {size_mb:.1f}MB")
    |

scripts/health_check.py:351:16: BLE001 Do not catch blind exception: `Exception`
    |
349 |             )
350 | 
351 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
352 |             return HealthCheckResult(
353 |                 name="log_files",
    |

scripts/health_check.py:395:16: BLE001 Do not catch blind exception: `Exception`
    |
393 |             )
394 | 
395 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
396 |             return HealthCheckResult(
397 |                 name="environment_variables",
    |

scripts/health_check.py:448:12: BLE001 Do not catch blind exception: `Exception`
    |
446 |                     logger.error("Health critical - %s: %s", name, check["message"])
447 | 
448 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
449 |         logger.error("Failed to run health check: %s", e)
    |

scripts/health_check.py:469:41: F401 `ai_trading.core.bot_engine` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
467 |         # Check if trading modules are importable
468 |         try:
469 |             from ai_trading.core import bot_engine
    |                                         ^^^^^^^^^^ F401
470 |             details["bot_engine"] = "OK"
471 |         except ImportError as e:
    |
    = help: Remove unused import: `ai_trading.core.bot_engine`

scripts/health_check.py:476:20: F401 `trade_execution` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
475 |         try:
476 |             import trade_execution
    |                    ^^^^^^^^^^^^^^^ F401
477 |             details["trade_execution"] = "OK"
478 |         except ImportError as e:
    |
    = help: Remove unused import: `trade_execution`

scripts/health_check.py:524:12: BLE001 Do not catch blind exception: `Exception`
    |
522 |         )
523 | 
524 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
525 |         return HealthCheckResult(
526 |             name="trading_system",
    |

scripts/integration_test.py:17:1: I001 [*] Import block is un-sorted or un-formatted
   |
15 |       """Test model registry functionality."""
16 |       try:
17 | /         import numpy as np
18 | |         from sklearn.linear_model import LinearRegression
19 | | 
20 | |         from ai_trading.model_registry import ModelRegistry
21 | | 
   | |_^ I001
22 |           with tempfile.TemporaryDirectory() as tmpdir:
23 |               registry = ModelRegistry(base_path=tmpdir)
   |
   = help: Organize imports

scripts/integration_test.py:38:12: BLE001 Do not catch blind exception: `Exception`
   |
36 |             assert isinstance(loaded, LinearRegression)
37 |             return True
38 |     except Exception:
   |            ^^^^^^^^^ BLE001
39 |         traceback.print_exc()
40 |         return False
   |

scripts/integration_test.py:60:12: BLE001 Do not catch blind exception: `Exception`
   |
59 |         return True
60 |     except Exception:
   |            ^^^^^^^^^ BLE001
61 |         return False
   |

scripts/integration_test.py:78:16: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
76 |         _pred_workers = _pred_env or max(2, min(4, _cpu))
77 | 
78 |         assert 2 <= _exec_workers <= 4
   |                ^ PLR2004
79 |         assert 2 <= _pred_workers <= 4
   |

scripts/integration_test.py:78:38: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
76 |         _pred_workers = _pred_env or max(2, min(4, _cpu))
77 | 
78 |         assert 2 <= _exec_workers <= 4
   |                                      ^ PLR2004
79 |         assert 2 <= _pred_workers <= 4
   |

scripts/integration_test.py:79:16: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
78 |         assert 2 <= _exec_workers <= 4
79 |         assert 2 <= _pred_workers <= 4
   |                ^ PLR2004
80 | 
81 |         # Test environment overrides
   |

scripts/integration_test.py:79:38: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
78 |         assert 2 <= _exec_workers <= 4
79 |         assert 2 <= _pred_workers <= 4
   |                                      ^ PLR2004
80 | 
81 |         # Test environment overrides
   |

scripts/integration_test.py:90:33: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   |
88 |         _pred_workers = _pred_env or max(2, min(4, _cpu))
89 | 
90 |         assert _exec_workers == 6
   |                                 ^ PLR2004
91 |         assert _pred_workers == 3
   |

scripts/integration_test.py:91:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
90 |         assert _exec_workers == 6
91 |         assert _pred_workers == 3
   |                                 ^ PLR2004
92 | 
93 |         return True
   |

scripts/integration_test.py:94:12: BLE001 Do not catch blind exception: `Exception`
   |
93 |         return True
94 |     except Exception:
   |            ^^^^^^^^^ BLE001
95 |         return False
   |

scripts/integration_test.py:132:16: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
    |
130 |         assert cached_ts is not None
131 |         assert isinstance(age, int)
132 |         assert 25 <= age <= 35  # Should be around 30 seconds
    |                ^^ PLR2004
133 | 
134 |         return True
    |

scripts/integration_test.py:132:29: PLR2004 Magic value used in comparison, consider replacing `35` with a constant variable
    |
130 |         assert cached_ts is not None
131 |         assert isinstance(age, int)
132 |         assert 25 <= age <= 35  # Should be around 30 seconds
    |                             ^^ PLR2004
133 | 
134 |         return True
    |

scripts/integration_test.py:135:12: BLE001 Do not catch blind exception: `Exception`
    |
134 |         return True
135 |     except Exception:
    |            ^^^^^^^^^ BLE001
136 |         return False
    |

scripts/integration_test.py:174:12: BLE001 Do not catch blind exception: `Exception`
    |
173 |         return True
174 |     except Exception:
    |            ^^^^^^^^^ BLE001
175 |         return False
    |

scripts/integration_test.py:196:12: BLE001 Do not catch blind exception: `Exception`
    |
195 |         return True
196 |     except Exception:
    |            ^^^^^^^^^ BLE001
197 |         return False
    |

scripts/integration_test.py:212:12: BLE001 Do not catch blind exception: `Exception`
    |
211 |         return True
212 |     except Exception:
    |            ^^^^^^^^^ BLE001
213 |         return False
    |

scripts/integration_test.py:240:16: BLE001 Do not catch blind exception: `Exception`
    |
238 |             else:
239 |                 failed += 1
240 |         except Exception:
    |                ^^^^^^^^^ BLE001
241 |             failed += 1
    |

scripts/memory_optimizer.py:130:41: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
128 |     def detect_memory_leaks(self) -> dict:
129 |         """Detect potential memory leaks by analyzing object growth."""
130 |         if len(self.memory_snapshots) < 2:
    |                                         ^ PLR2004
131 |             return {'status': 'insufficient_data', 'message': 'Need at least 2 snapshots'}
    |

scripts/memory_optimizer.py:143:34: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
141 |             if prev_count > 0:
142 |                 growth_rate = (count - prev_count) / prev_count
143 |                 if growth_rate > 0.5:  # 50% growth threshold
    |                                  ^^^ PLR2004
144 |                     leak_indicators[obj_type] = {
145 |                         'previous_count': prev_count,
    |

scripts/memory_optimizer.py:160:44: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
158 |         }
159 | 
160 |         if leak_indicators or rss_growth > 50:  # 50MB growth threshold
    |                                            ^^ PLR2004
161 |             self.logger.warning(f"Potential memory leak detected: {result}")
    |

scripts/memory_optimizer.py:185:16: BLE001 Do not catch blind exception: `Exception`
    |
183 |             self.logger.info(f"Cleaned up {collected} objects and {len(dead_refs)} dead references")
184 | 
185 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
186 |             self.logger.error(f"Error during circular reference cleanup: {e}")
    |

scripts/memory_optimizer.py:201:16: BLE001 Do not catch blind exception: `Exception`
    |
200 |                 self.logger.info("Pandas memory optimization applied")
201 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
202 |             self.logger.warning(f"Could not optimize pandas memory: {e}")
    |

scripts/memory_optimizer.py:213:49: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
212 |                 # Keep only last 100 snapshots to prevent memory buildup
213 |                 if len(self.memory_snapshots) > 100:
    |                                                 ^^^ PLR2004
214 |                     self.memory_snapshots = self.memory_snapshots[-100:]
    |

scripts/memory_optimizer.py:221:67: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
220 |                     # Force GC if significant growth detected
221 |                     if leak_analysis.get('memory_growth_mb', 0) > 100:
    |                                                                   ^^^ PLR2004
222 |                         self.force_garbage_collection()
223 |                         self.cleanup_circular_references()
    |

scripts/memory_optimizer.py:228:20: BLE001 Do not catch blind exception: `Exception`
    |
226 |                 self.stop_monitoring.wait(30)  # Check every 30 seconds
227 | 
228 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
229 |                 self.logger.error(f"Error in memory monitoring: {e}")
230 |                 self.stop_monitoring.wait(60)  # Wait longer on error
    |

scripts/memory_optimizer.py:266:42: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
265 |         # Add leak detection if we have enough data
266 |         if len(self.memory_snapshots) >= 2:
    |                                          ^ PLR2004
267 |             report['leak_analysis'] = self.detect_memory_leaks()
    |

scripts/memory_optimizer.py:287:41: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
286 |         # Clear old snapshots to free memory
287 |         if len(self.memory_snapshots) > 10:
    |                                         ^^ PLR2004
288 |             self.memory_snapshots = self.memory_snapshots[-10:]
    |

scripts/memory_optimizer.py:291:33: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
290 |         # Clear old GC stats
291 |         if len(self.gc_stats) > 10:
    |                                 ^^ PLR2004
292 |             self.gc_stats = self.gc_stats[-10:]
    |

scripts/memory_optimizer.py:346:35: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
345 |                 # Log if significant memory increase
346 |                 if memory_delta > 10:  # 10MB threshold
    |                                   ^^ PLR2004
347 |                     self.logger.warning(f"Function {func_name} used {memory_delta:.2f}MB of memory")
    |

scripts/memory_optimizer.py:379:12: PLW0603 Using the global statement to update `_memory_optimizer` is discouraged
    |
377 | def get_memory_optimizer() -> MemoryOptimizer:
378 |     """Get global memory optimizer instance."""
379 |     global _memory_optimizer
    |            ^^^^^^^^^^^^^^^^^ PLW0603
380 |     if _memory_optimizer is None:
381 |         _memory_optimizer = MemoryOptimizer()
    |

scripts/ml_model.py:36:1: E402 Module level import not at top of file
   |
36 | from joblib import parallel_backend
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
37 | 
38 | # AI-AGENT-REF: restrict joblib parallelism
   |

scripts/ml_model.py:63:35: F821 Undefined name `pd`
   |
61 |         self.logger = logger
62 | 
63 |     def _validate_inputs(self, X: pd.DataFrame) -> None:
   |                                   ^^ F821
64 |         import pandas as pd
65 |         if not isinstance(X, pd.DataFrame):
   |

scripts/ml_model.py:75:22: F821 Undefined name `pd`
   |
73 |             raise TypeError("All input columns must be numeric")
74 | 
75 |     def fit(self, X: pd.DataFrame, y: Sequence[float] | pd.Series) -> float:
   |                      ^^ F821
76 |         self._validate_inputs(X)
77 |         start = time.time()
   |

scripts/ml_model.py:75:57: F821 Undefined name `pd`
   |
73 |             raise TypeError("All input columns must be numeric")
74 | 
75 |     def fit(self, X: pd.DataFrame, y: Sequence[float] | pd.Series) -> float:
   |                                                         ^^ F821
76 |         self._validate_inputs(X)
77 |         start = time.time()
   |

scripts/ml_model.py:93:26: F821 Undefined name `pd`
   |
91 |             raise
92 | 
93 |     def predict(self, X: pd.DataFrame) -> Any:
   |                          ^^ F821
94 |         self._validate_inputs(X)
95 |         try:
   |

scripts/ml_model.py:140:26: F821 Undefined name `pd`
    |
139 | def train_model(
140 |     X: Sequence[float] | pd.Series | pd.DataFrame,
    |                          ^^ F821
141 |     y: Sequence[float] | pd.Series,
142 |     algorithm: str = "linear",
    |

scripts/ml_model.py:140:38: F821 Undefined name `pd`
    |
139 | def train_model(
140 |     X: Sequence[float] | pd.Series | pd.DataFrame,
    |                                      ^^ F821
141 |     y: Sequence[float] | pd.Series,
142 |     algorithm: str = "linear",
    |

scripts/ml_model.py:141:26: F821 Undefined name `pd`
    |
139 | def train_model(
140 |     X: Sequence[float] | pd.Series | pd.DataFrame,
141 |     y: Sequence[float] | pd.Series,
    |                          ^^ F821
142 |     algorithm: str = "linear",
143 | ) -> BaseEstimator:
    |

scripts/ml_model.py:155:50: F821 Undefined name `pd`
    |
155 | def predict_model(model: Any, X: Sequence[Any] | pd.DataFrame) -> list[float]:
    |                                                  ^^ F821
156 |     """Return predictions from a fitted model.
    |

scripts/monitoring_dashboard.py:189:16: BLE001 Do not catch blind exception: `Exception`
    |
187 |             self.logger.info(f"Starting monitoring dashboard on port {self.port}")
188 |             self.app.run(host='0.0.0.0', port=self.port, debug=debug, threaded=True)
189 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
190 |             self.logger.error(f"Failed to start dashboard: {e}")
    |

scripts/monitoring_dashboard.py:225:20: BLE001 Do not catch blind exception: `Exception`
    |
223 |                 self.check_alert_conditions()
224 | 
225 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
226 |                 self.logger.error(f"Error in monitoring loop: {e}")
    |

scripts/monitoring_dashboard.py:235:71: PLR2004 Magic value used in comparison, consider replacing `86400` with a constant variable
    |
233 |             # Calculate metrics from trade history
234 |             recent_trades = [t for t in self.trade_history
235 |                            if (time.time() - t.get('timestamp', 0)) < 86400]  # Last 24 hours
    |                                                                       ^^^^^ PLR2004
236 | 
237 |             if not recent_trades:
    |

scripts/monitoring_dashboard.py:284:16: BLE001 Do not catch blind exception: `Exception`
    |
282 |             self.trading_metrics.append(metrics)
283 | 
284 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
285 |             self.logger.error(f"Error collecting trading metrics: {e}")
    |

scripts/monitoring_dashboard.py:315:16: BLE001 Do not catch blind exception: `Exception`
    |
313 |             self.performance_kpis.append(kpis)
314 | 
315 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
316 |             self.logger.error(f"Error collecting performance KPIs: {e}")
    |

scripts/monitoring_dashboard.py:325:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
324 |             pnl_values = [t.get('pnl', 0) for t in self.trade_history]
325 |             if len(pnl_values) < 2:
    |                                  ^ PLR2004
326 |                 return
    |

scripts/monitoring_dashboard.py:354:16: BLE001 Do not catch blind exception: `Exception`
    |
352 |             self.risk_metrics.append(risk_metrics)
353 | 
354 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
355 |             self.logger.error(f"Error collecting risk metrics: {e}")
    |

scripts/monitoring_dashboard.py:389:16: BLE001 Do not catch blind exception: `Exception`
    |
387 |                 )
388 | 
389 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
390 |             self.logger.error(f"Error checking alert conditions: {e}")
    |

scripts/monitoring_dashboard.py:415:20: BLE001 Do not catch blind exception: `Exception`
    |
413 |             try:
414 |                 callback(alert)
415 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
416 |                 self.logger.error(f"Error in alert callback: {e}")
    |

scripts/monitoring_dashboard.py:473:26: DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
    |
471 |         daily_pnl = defaultdict(float)
472 |         for trade in trades:
473 |             trade_date = datetime.fromtimestamp(trade['timestamp']).date()
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ006
474 |             daily_pnl[trade_date] += trade['pnl']
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

scripts/monitoring_dashboard.py:502:40: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
501 |         if latest_risk:
502 |             if latest_risk['var_95'] > 1000:  # $1000 daily VaR
    |                                        ^^^^ PLR2004
503 |                 risk_score += 25
504 |                 risk_factors.append("High Value at Risk")
    |

scripts/monitoring_dashboard.py:506:44: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
    |
504 |                 risk_factors.append("High Value at Risk")
505 | 
506 |             if latest_risk['volatility'] > 0.02:  # 2% daily volatility
    |                                            ^^^^ PLR2004
507 |                 risk_score += 20
508 |                 risk_factors.append("High volatility")
    |

scripts/monitoring_dashboard.py:510:60: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
508 |                 risk_factors.append("High volatility")
509 | 
510 |             if latest_risk['max_position_concentration'] > 0.3:  # 30% concentration
    |                                                            ^^^ PLR2004
511 |                 risk_score += 30
512 |                 risk_factors.append("High position concentration")
    |

scripts/monitoring_dashboard.py:517:50: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
515 |             'timestamp': datetime.now(UTC).isoformat(),
516 |             'risk_score': risk_score,
517 |             'risk_level': 'HIGH' if risk_score > 50 else 'MEDIUM' if risk_score > 25 else 'LOW',
    |                                                  ^^ PLR2004
518 |             'risk_factors': risk_factors,
519 |             'latest_metrics': latest_risk,
    |

scripts/monitoring_dashboard.py:517:83: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
    |
515 |             'timestamp': datetime.now(UTC).isoformat(),
516 |             'risk_score': risk_score,
517 |             'risk_level': 'HIGH' if risk_score > 50 else 'MEDIUM' if risk_score > 25 else 'LOW',
    |                                                                                   ^^ PLR2004
518 |             'risk_factors': risk_factors,
519 |             'latest_metrics': latest_risk,
    |

scripts/monitoring_dashboard.py:527:25: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
525 |         recommendations = []
526 | 
527 |         if risk_score > 50:
    |                         ^^ PLR2004
528 |             recommendations.append("Consider reducing position sizes")
529 |             recommendations.append("Implement stricter stop-loss levels")
    |

scripts/monitoring_dashboard.py:739:12: PLW0603 Using the global statement to update `_monitoring_dashboard` is discouraged
    |
737 | def get_monitoring_dashboard() -> MonitoringDashboard:
738 |     """Get global monitoring dashboard instance."""
739 |     global _monitoring_dashboard
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
740 |     if _monitoring_dashboard is None:
741 |         _monitoring_dashboard = MonitoringDashboard()
    |

scripts/monitoring_dashboard.py:747:12: PLW0603 Using the global statement to update `_monitoring_dashboard` is discouraged
    |
745 | def initialize_monitoring_dashboard(port: int = 5000) -> MonitoringDashboard:
746 |     """Initialize monitoring dashboard."""
747 |     global _monitoring_dashboard
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
748 |     _monitoring_dashboard = MonitoringDashboard(port)
749 |     return _monitoring_dashboard
    |

scripts/optimized_startup.py:102:12: BLE001 Do not catch blind exception: `Exception`
    |
100 |         logging.info("System diagnostic not available, skipping health check")
101 |         return True
102 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
103 |         logging.info(f"Health check failed: {e}")
104 |         return False
    |

scripts/optimized_startup.py:125:12: BLE001 Do not catch blind exception: `Exception`
    |
123 |     except ImportError:
124 |         logging.info("Process manager not available, skipping duplicate cleanup")
125 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
126 |         logging.info(f"Process cleanup failed: {e}")
    |

scripts/optimized_startup.py:151:12: BLE001 Do not catch blind exception: `Exception`
    |
149 |         logging.info("Monitoring systems not available")
150 |         return False
151 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
152 |         logging.info(f"Failed to start monitoring: {e}")
153 |         return False
    |

scripts/optimized_startup.py:166:12: BLE001 Do not catch blind exception: `Exception`
    |
164 |     except ImportError:
165 |         logging.debug("Memory optimizer not available, skipping emergency cleanup")
166 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
167 |         logging.warning(f"Emergency memory cleanup failed: {e}")
    |

scripts/patch_short_selling.py:19:17: PLR2004 Magic value used in comparison, consider replacing `1799` with a constant variable
   |
17 |     # Find and update the first occurrence (sync execute_order)
18 |     for i, line in enumerate(lines):
19 |         if i == 1799 and 'if side.lower() == "sell" and existing == 0:' in line:
   |                 ^^^^ PLR2004
20 |             # Replace the simple logic with enhanced short selling logic
21 |             lines[i+1] = '            # No existing position - check if this is a valid short selling request\n'
   |

scripts/patch_short_selling.py:36:17: PLR2004 Magic value used in comparison, consider replacing `2087` with a constant variable
   |
34 |     # Find and update the second occurrence (async execute_order_async)
35 |     for i, line in enumerate(lines):
36 |         if i == 2087 and 'if side.lower() == "sell" and existing == 0:' in line:
   |                 ^^^^ PLR2004
37 |             # Replace the simple logic with enhanced short selling logic
38 |             lines[i+1] = '            # No existing position - check if this is a valid short selling request\n'
   |

scripts/performance_demo.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import sys
11 | from datetime import UTC, datetime
   |

scripts/performance_demo.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
   | ^^^^^^^^^^ E402
11 | from datetime import UTC, datetime
   |

scripts/performance_demo.py:11:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import sys
11 | from datetime import UTC, datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/performance_demo.py:52:12: BLE001 Do not catch blind exception: `Exception`
   |
50 |             logging.info("  - No performance recommendations needed ✓")
51 | 
52 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
53 |         logging.info(f"✗ System diagnostic error: {e}")
   |

scripts/performance_demo.py:87:12: BLE001 Do not catch blind exception: `Exception`
   |
85 |             logging.info(f"    • {obj_type}: {count:,}")
86 | 
87 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
88 |         logging.info(f"✗ Memory optimizer error: {e}")
   |

scripts/performance_demo.py:133:12: BLE001 Do not catch blind exception: `Exception`
    |
131 |             logging.info("  - No alerts (system healthy) ✓")
132 | 
133 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
134 |         logging.info(f"✗ Performance monitor error: {e}")
    |

scripts/performance_demo.py:177:12: BLE001 Do not catch blind exception: `Exception`
    |
175 |             logging.info("  - All services healthy ✓")
176 | 
177 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
178 |         logging.info(f"✗ Process manager error: {e}")
    |

scripts/performance_demo.py:209:12: BLE001 Do not catch blind exception: `Exception`
    |
207 |             logging.info("  ✓ Periodic memory checks added")
208 | 
209 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
210 |         logging.info(f"✗ Integration check error: {e}")
    |

scripts/performance_demo.py:232:12: BLE001 Do not catch blind exception: `Exception`
    |
230 |             logging.info("  ✗ Startup script not found")
231 | 
232 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
233 |         logging.info(f"✗ Startup optimization error: {e}")
    |

scripts/performance_monitor.py:88:16: BLE001 Do not catch blind exception: `Exception`
   |
86 |             metrics['python'] = self._get_python_metrics()
87 | 
88 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
89 |             self.logger.error(f"Error collecting system metrics: {e}")
90 |             metrics['error'] = str(e)
   |

scripts/performance_monitor.py:131:16: BLE001 Do not catch blind exception: `Exception`
    |
129 |                 }
130 | 
131 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
132 |             memory_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:154:16: BLE001 Do not catch blind exception: `Exception`
    |
152 |             cpu_metrics['usage_percent'] = min(cpu_metrics['load_1min'] / cpu_metrics['cpu_count'] * 100, 100)
153 | 
154 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
155 |             cpu_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:196:16: BLE001 Do not catch blind exception: `Exception`
    |
194 |             disk_metrics['large_files_count'] = len(large_files)
195 | 
196 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
197 |             disk_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:233:20: BLE001 Do not catch blind exception: `Exception`
    |
231 |             try:
232 |                 process_metrics['python_processes'] = self._count_trading_bot_processes()
233 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
234 |                 logger.warning(f"Error counting trading bot processes: {e}")
235 |                 process_metrics['python_processes'] = 1
    |

scripts/performance_monitor.py:234:17: F821 Undefined name `logger`
    |
232 |                 process_metrics['python_processes'] = self._count_trading_bot_processes()
233 |             except Exception as e:
234 |                 logger.warning(f"Error counting trading bot processes: {e}")
    |                 ^^^^^^ F821
235 |                 process_metrics['python_processes'] = 1
    |

scripts/performance_monitor.py:237:16: BLE001 Do not catch blind exception: `Exception`
    |
235 |                 process_metrics['python_processes'] = 1
236 | 
237 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
238 |             process_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:272:33: PLR2004 Magic value used in comparison, consider replacing `11` with a constant variable
    |
271 |                 parts = line.split(None, 10)  # Split into at most 11 parts
272 |                 if len(parts) < 11:
    |                                 ^^ PLR2004
273 |                     continue
    |

scripts/performance_monitor.py:316:53: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
314 |                                 stat_data = f.read().strip().split()
315 |                                 # starttime is the 22nd field (index 21)
316 |                                 if len(stat_data) > 21:
    |                                                     ^^ PLR2004
317 |                                     # For now, just count it as valid if we can read the stat
318 |                                     trading_bot_count += 1
    |

scripts/performance_monitor.py:332:16: BLE001 Do not catch blind exception: `Exception`
    |
330 |             self.logger.warning(f"Error getting process list: {e}")
331 |             return self._count_python_processes_fallback()
332 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
333 |             self.logger.error(f"Unexpected error counting trading bot processes: {e}")
334 |             return self._count_python_processes_fallback()
    |

scripts/performance_monitor.py:364:16: BLE001 Do not catch blind exception: `Exception`
    |
362 |         except (subprocess.SubprocessError, subprocess.CalledProcessError):
363 |             network_metrics['established_connections'] = 0
364 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
365 |             network_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:387:16: BLE001 Do not catch blind exception: `Exception`
    |
385 |             python_metrics['trading_modules_loaded'] = len(trading_modules)
386 | 
387 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
388 |             python_metrics['error'] = str(e)
    |

scripts/performance_monitor.py:455:74: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
453 |             # Alert only if we have significantly more trading bot processes than expected
454 |             # Allow for up to 2 legitimate trading bot processes (main + potential backup/monitor)
455 |             if 'python_processes' in proc and proc['python_processes'] > 2:
    |                                                                          ^ PLR2004
456 |                 alerts.append({
457 |                     'type': 'multiple_trading_bot_processes',
    |

scripts/performance_monitor.py:490:36: BLE001 Do not catch blind exception: `Exception`
    |
488 |                             try:
489 |                                 callback(alert)
490 |                             except Exception as e:
    |                                    ^^^^^^^^^ BLE001
491 |                                 self.logger.error(f"Error in alert callback: {e}")
    |

scripts/performance_monitor.py:500:20: BLE001 Do not catch blind exception: `Exception`
    |
498 |                 self.stop_monitoring.wait(self.monitoring_interval)
499 | 
500 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
501 |                 self.logger.error(f"Error in monitoring loop: {e}")
502 |                 self.stop_monitoring.wait(60)  # Wait longer on error
    |

scripts/performance_monitor.py:553:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
551 |         # Calculate trends
552 |         trends = {}
553 |         if len(recent_metrics) >= 2:
    |                                   ^ PLR2004
554 |             first = recent_metrics[0]
555 |             last = recent_metrics[-1]
    |

scripts/performance_monitor.py:634:12: PLW0603 Using the global statement to update `_performance_monitor` is discouraged
    |
632 | def get_performance_monitor() -> ResourceMonitor:
633 |     """Get global performance monitor instance."""
634 |     global _performance_monitor
    |            ^^^^^^^^^^^^^^^^^^^^ PLW0603
635 |     if _performance_monitor is None:
636 |         _performance_monitor = ResourceMonitor()
    |

scripts/performance_optimizer.py:297:55: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
295 |         # Clear old execution times
296 |         for func_name in list(self.execution_times.keys()):
297 |             if len(self.execution_times[func_name]) > 100:
    |                                                       ^^^ PLR2004
298 |                 # Keep only recent 100 entries
299 |                 recent_times = list(self.execution_times[func_name])[-100:]
    |

scripts/performance_optimizer.py:479:12: PLW0603 Using the global statement to update `_performance_optimizer` is discouraged
    |
477 | def get_performance_optimizer() -> PerformanceOptimizer:
478 |     """Get global performance optimizer instance."""
479 |     global _performance_optimizer
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
480 |     if _performance_optimizer is None:
481 |         _performance_optimizer = PerformanceOptimizer()
    |

scripts/performance_optimizer.py:487:12: PLW0603 Using the global statement to update `_performance_optimizer` is discouraged
    |
485 | def initialize_performance_optimizer(enable_memory_profiling: bool = True) -> PerformanceOptimizer:
486 |     """Initialize performance optimizer."""
487 |     global _performance_optimizer
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
488 |     _performance_optimizer = PerformanceOptimizer(enable_memory_profiling)
489 |     return _performance_optimizer
    |

scripts/portfolio_rl.py:16:12: BLE001 Do not catch blind exception: `Exception`
   |
14 |         _test_module = nn.Module()
15 |         _PYTORCH_WORKS = True
16 |     except Exception:
   |            ^^^^^^^^^ BLE001
17 |         _PYTORCH_WORKS = False
   |

scripts/portfolio_rl.py:19:8: BLE001 Do not catch blind exception: `Exception`
   |
17 |         _PYTORCH_WORKS = False
18 | 
19 | except Exception:  # pragma: no cover - optional dependency
   |        ^^^^^^^^^ BLE001
20 |     # AI-AGENT-REF: Create comprehensive torch fallback that supports type annotations
21 |     torch = types.ModuleType("torch")
   |

scripts/portfolio_rl.py:52:16: BLE001 Do not catch blind exception: `Exception`
   |
50 |                 nn.Softmax(dim=-1),
51 |             )
52 |         except Exception:
   |                ^^^^^^^^^ BLE001
53 |             # AI-AGENT-REF: Handle any PyTorch version compatibility issues during initialization
54 |             self.state_dim = state_dim
   |

scripts/portfolio_rl.py:71:16: BLE001 Do not catch blind exception: `Exception`
   |
69 |         try:
70 |             return self.net(x)
71 |         except Exception:
   |                ^^^^^^^^^ BLE001
72 |             # AI-AGENT-REF: Fallback if forward pass fails due to version issues
73 |             if np is not None:
   |

scripts/portfolio_rl.py:93:16: BLE001 Do not catch blind exception: `Exception`
   |
91 |             self.actor = Actor(state_dim, action_dim)
92 |             self.optimizer = optim.Adam(self.actor.parameters(), lr=1e-3)
93 |         except Exception:
   |                ^^^^^^^^^ BLE001
94 |             # AI-AGENT-REF: Handle initialization errors due to version compatibility
95 |             self.actor = Actor(state_dim, action_dim)
   |

scripts/portfolio_rl.py:98:9: PLR0911 Too many return statements (8 > 6)
    |
 96 |             self.optimizer = None
 97 | 
 98 |     def rebalance_portfolio(self, state) -> object:
    |         ^^^^^^^^^^^^^^^^^^^ PLR0911
 99 |         if np is None:
100 |             # Basic fallback when numpy not available
    |

scripts/portfolio_rl.py:139:16: BLE001 Do not catch blind exception: `Exception`
    |
137 |                 total = 1.0
138 |             return weights / total
139 |         except Exception:
    |                ^^^^^^^^^ BLE001
140 |             # AI-AGENT-REF: Fallback if PyTorch operations fail
141 |             weights = self.actor.forward(state)
    |

scripts/predict.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Prediction utilities using trained models."""
 2 |   
 3 | / from __future__ import annotations
 4 | | 
 5 | | import argparse
 6 | | import json
 7 | | import logging
 8 | | import os
 9 | | 
10 | | # AI-AGENT-REF: graceful joblib fallback for testing
11 | | import joblib
12 | | 
13 | | # AI-AGENT-REF: graceful pandas fallback for testing
14 | | import pandas as pd
15 | | 
16 | | # AI-AGENT-REF: Use HTTP utilities with proper timeout/retry
17 | | from ai_trading.config.management import TradingConfig, reload_env
18 | | from scripts.retrain import prepare_indicators
19 | | 
20 | | CONFIG = TradingConfig()
   | |_^ I001
21 |   
22 |   from ai_trading.utils import http
   |
   = help: Organize imports

scripts/predict.py:22:1: E402 Module level import not at top of file
   |
20 | CONFIG = TradingConfig()
21 | 
22 | from ai_trading.utils import http
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 | from ai_trading.utils.timing import (
24 |     HTTP_TIMEOUT,  # AI-AGENT-REF: explicit timeout constant
   |

scripts/predict.py:23:1: E402 Module level import not at top of file
   |
22 |   from ai_trading.utils import http
23 | / from ai_trading.utils.timing import (
24 | |     HTTP_TIMEOUT,  # AI-AGENT-REF: explicit timeout constant
25 | | )
   | |_^ E402
26 |   
27 |   logger = logging.getLogger(__name__)
   |

scripts/predict.py:37:1: E402 Module level import not at top of file
   |
37 | import threading
   | ^^^^^^^^^^^^^^^^ E402
38 | import time
   |

scripts/predict.py:38:1: E402 Module level import not at top of file
   |
37 | import threading
38 | import time
   | ^^^^^^^^^^^ E402
39 | 
40 | # AI-AGENT-REF: Memory leak prevention with TTLCache
   |

scripts/predict.py:41:1: E402 Module level import not at top of file
   |
40 | # AI-AGENT-REF: Memory leak prevention with TTLCache
41 | from cachetools import TTLCache
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
42 | 
43 | # TTLCache with 5 min TTL and 1000 items max to prevent memory leaks
   |

scripts/predict.py:52:5: PLR0911 Too many return statements (10 > 6)
   |
52 | def fetch_sentiment(symbol: str) -> float:
   |     ^^^^^^^^^^^^^^^ PLR0911
53 |     """Return a sentiment score for ``symbol`` using NewsAPI with rate limiting and TTL cache."""
   |

scripts/predict.py:56:23: F821 Undefined name `config`
   |
55 |     # Support both SENTIMENT_API_KEY and NEWS_API_KEY for backwards compatibility
56 |     api_key = getattr(config, "SENTIMENT_API_KEY", None) or config.NEWS_API_KEY
   |                       ^^^^^^ F821
57 |     if not api_key:
58 |         logger.debug(
   |

scripts/predict.py:56:61: F821 Undefined name `config`
   |
55 |     # Support both SENTIMENT_API_KEY and NEWS_API_KEY for backwards compatibility
56 |     api_key = getattr(config, "SENTIMENT_API_KEY", None) or config.NEWS_API_KEY
   |                                                             ^^^^^^ F821
57 |     if not api_key:
58 |         logger.debug(
   |

scripts/predict.py:67:12: F821 Undefined name `_CACHETOOLS_AVAILABLE`
   |
65 |     with _sentiment_lock:
66 |         # Check cache first (TTLCache handles expiration automatically)
67 |         if _CACHETOOLS_AVAILABLE:
   |            ^^^^^^^^^^^^^^^^^^^^^ F821
68 |             if symbol in _sentiment_cache:
69 |                 cached_score = _sentiment_cache[symbol]
   |

scripts/predict.py:97:20: F821 Undefined name `_CACHETOOLS_AVAILABLE`
   |
95 |                 )
96 |                 # Return cached value if available, otherwise neutral
97 |                 if _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
   |                    ^^^^^^^^^^^^^^^^^^^^^ F821
98 |                     return _sentiment_cache[symbol]
99 |                 elif not _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
   |

scripts/predict.py:99:26: F821 Undefined name `_CACHETOOLS_AVAILABLE`
    |
 97 |                 if _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
 98 |                     return _sentiment_cache[symbol]
 99 |                 elif not _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
    |                          ^^^^^^^^^^^^^^^^^^^^^ F821
100 |                     return _sentiment_cache[symbol][0]
101 |                 return 0.0
    |

scripts/predict.py:108:13: F821 Undefined name `config`
    |
106 |         # Support configurable sentiment API URL, with fallback to NewsAPI
107 |         base_url = getattr(
108 |             config, "SENTIMENT_API_URL", "https://newsapi.org/v2/everything"
    |             ^^^^^^ F821
109 |         )
110 |         url = (
    |

scripts/predict.py:127:16: F821 Undefined name `_CACHETOOLS_AVAILABLE`
    |
125 |         # Cache the result with memory leak prevention
126 |         with _sentiment_lock:
127 |             if _CACHETOOLS_AVAILABLE:
    |                ^^^^^^^^^^^^^^^^^^^^^ F821
128 |                 _sentiment_cache[symbol] = score  # TTLCache handles expiration
129 |             else:
    |

scripts/predict.py:131:45: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
129 |             else:
130 |                 # Manual cache with size limit to prevent memory leaks
131 |                 if len(_sentiment_cache) >= 1000:
    |                                             ^^^^ PLR2004
132 |                     # Remove oldest entry
133 |                     oldest_key = min(
    |

scripts/predict.py:146:16: F821 Undefined name `_CACHETOOLS_AVAILABLE`
    |
144 |         # Return cached value if available during error, otherwise neutral
145 |         with _sentiment_lock:
146 |             if _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
    |                ^^^^^^^^^^^^^^^^^^^^^ F821
147 |                 return _sentiment_cache[symbol]
148 |             elif not _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
    |

scripts/predict.py:148:22: F821 Undefined name `_CACHETOOLS_AVAILABLE`
    |
146 |             if _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
147 |                 return _sentiment_cache[symbol]
148 |             elif not _CACHETOOLS_AVAILABLE and symbol in _sentiment_cache:
    |                      ^^^^^^^^^^^^^^^^^^^^^ F821
149 |                 return _sentiment_cache[symbol][0]
150 |         return 0.0
    |

scripts/problem_statement_validation.py:8:1: E402 Module level import not at top of file
   |
 6 | """
 7 | 
 8 | import re
   | ^^^^^^^^^ E402
 9 | import sys
10 | from pathlib import Path
   |

scripts/problem_statement_validation.py:9:1: E402 Module level import not at top of file
   |
 8 | import re
 9 | import sys
   | ^^^^^^^^^^ E402
10 | from pathlib import Path
   |

scripts/problem_statement_validation.py:10:1: E402 Module level import not at top of file
   |
 8 | import re
 9 | import sys
10 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/problem_statement_validation.py:175:12: BLE001 Do not catch blind exception: `Exception`
    |
173 |         return True
174 | 
175 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
176 |         logging.info(f"❌ Validation failed: {e}")
177 |         import traceback
    |

scripts/process_manager.py:56:42: PLR2004 Magic value used in comparison, consider replacing `11` with a constant variable
   |
54 |                     if 'python' in line.lower() and line.strip():
55 |                         parts = line.split()
56 |                         if len(parts) >= 11:
   |                                          ^^ PLR2004
57 |                             process_info = {
58 |                                 'user': parts[0],
   |

scripts/process_manager.py:150:27: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
149 |         except OSError as e:
150 |             if e.errno == 3:  # No such process
    |                           ^ PLR2004
151 |                 return True  # Already gone
152 |             self.logger.error(f"Failed to kill process {pid}: {e}")
    |

scripts/process_manager.py:270:16: BLE001 Do not catch blind exception: `Exception`
    |
268 |                 # Note: PID file will be automatically removed when process exits
269 |                 # since we hold an exclusive lock on it
270 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
271 |             self.logger.debug(f"Error cleaning up PID file: {e}")
    |

scripts/process_manager.py:400:75: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
399 |         # Memory recommendations
400 |         high_memory_processes = [p for p in processes if p['memory_mb'] > 500]
    |                                                                           ^^^ PLR2004
401 |         if high_memory_processes:
402 |             recommendations.append(
    |

scripts/process_manager.py:425:27: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
423 |         # Performance recommendations
424 |         total_memory = sum(p['memory_mb'] for p in processes)
425 |         if total_memory > 1000:
    |                           ^^^^ PLR2004
426 |             recommendations.append(
427 |                 f"LOW PRIORITY: Total Python process memory usage: {total_memory:.1f}MB. "
    |

scripts/process_manager.py:494:16: BLE001 Do not catch blind exception: `Exception`
    |
492 |             return True
493 | 
494 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
495 |             self.logger.error(f"Failed to acquire process lock: {e}")
496 |             return False
    |

scripts/production_integration.py:28:9: F401 `production_monitoring.get_production_monitor` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
26 |         CircuitBreaker,
27 |         ProductionMonitor,
28 |         get_production_monitor,
   |         ^^^^^^^^^^^^^^^^^^^^^^ F401
29 |         initialize_production_monitoring,
30 |     )
   |
   = help: Remove unused import: `production_monitoring.get_production_monitor`

scripts/production_integration.py:37:9: F401 `performance_optimizer.cached` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
35 | try:
36 |     from performance_optimizer import (
37 |         cached,
   |         ^^^^^^ F401
38 |         get_performance_optimizer,
39 |         initialize_performance_optimizer,
   |
   = help: Remove unused import

scripts/production_integration.py:38:9: F401 `performance_optimizer.get_performance_optimizer` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
36 |     from performance_optimizer import (
37 |         cached,
38 |         get_performance_optimizer,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ F401
39 |         initialize_performance_optimizer,
40 |         profile_performance,
   |
   = help: Remove unused import

scripts/production_integration.py:40:9: F401 `performance_optimizer.profile_performance` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
38 |         get_performance_optimizer,
39 |         initialize_performance_optimizer,
40 |         profile_performance,
   |         ^^^^^^^^^^^^^^^^^^^ F401
41 |     )
42 |     PERFORMANCE_OPTIMIZER_AVAILABLE = True
   |
   = help: Remove unused import

scripts/production_integration.py:47:34: F401 `security_manager.get_security_manager` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
46 | try:
47 |     from security_manager import get_security_manager, initialize_security_manager
   |                                  ^^^^^^^^^^^^^^^^^^^^ F401
48 |     SECURITY_MANAGER_AVAILABLE = True
49 | except ImportError:
   |
   = help: Remove unused import: `security_manager.get_security_manager`

scripts/production_integration.py:54:9: F401 `monitoring_dashboard.get_monitoring_dashboard` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
52 | try:
53 |     from monitoring_dashboard import (
54 |         get_monitoring_dashboard,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^ F401
55 |         initialize_monitoring_dashboard,
56 |     )
   |
   = help: Remove unused import: `monitoring_dashboard.get_monitoring_dashboard`

scripts/production_integration.py:62:30: F401 `health_check.health_monitor` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
61 | try:
62 |     from health_check import health_monitor
   |                              ^^^^^^^^^^^^^^ F401
63 |     HEALTH_CHECK_AVAILABLE = True
64 | except ImportError:
   |
   = help: Remove unused import: `health_check.health_monitor`

scripts/production_integration.py:103:24: BLE001 Do not catch blind exception: `Exception`
    |
101 |                     self.logger.info("✓ Production monitoring initialized")
102 |                     success_count += 1
103 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
104 |                     self.logger.error(f"✗ Failed to initialize production monitoring: {e}")
    |

scripts/production_integration.py:113:24: BLE001 Do not catch blind exception: `Exception`
    |
111 |                     self.logger.info("✓ Performance optimizer initialized")
112 |                     success_count += 1
113 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
114 |                     self.logger.error(f"✗ Failed to initialize performance optimizer: {e}")
    |

scripts/production_integration.py:123:24: BLE001 Do not catch blind exception: `Exception`
    |
121 |                     self.logger.info("✓ Security manager initialized")
122 |                     success_count += 1
123 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
124 |                     self.logger.error(f"✗ Failed to initialize security manager: {e}")
    |

scripts/production_integration.py:133:24: BLE001 Do not catch blind exception: `Exception`
    |
131 |                     self.logger.info("✓ Monitoring dashboard initialized")
132 |                     success_count += 1
133 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
134 |                     self.logger.error(f"✗ Failed to initialize monitoring dashboard: {e}")
    |

scripts/production_integration.py:151:16: BLE001 Do not catch blind exception: `Exception`
    |
149 |             return self.systems_initialized
150 | 
151 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
152 |             self.logger.error(f"Failed to initialize production systems: {e}")
153 |             return False
    |

scripts/production_integration.py:211:16: BLE001 Do not catch blind exception: `Exception`
    |
209 |             self.logger.info("Health check integration configured")
210 | 
211 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
212 |             self.logger.error(f"Failed to setup health check integration: {e}")
    |

scripts/production_integration.py:233:16: BLE001 Do not catch blind exception: `Exception`
    |
231 |             return True
232 | 
233 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
234 |             self.logger.error(f"Failed to start monitoring: {e}")
235 |             return False
    |

scripts/production_integration.py:249:16: BLE001 Do not catch blind exception: `Exception`
    |
247 |             self.logger.info("✓ All monitoring systems stopped")
248 | 
249 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
250 |             self.logger.error(f"Error stopping monitoring: {e}")
    |

scripts/production_integration.py:361:16: BLE001 Do not catch blind exception: `Exception`
    |
359 |                 )
360 | 
361 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
362 |             self.logger.error(f"Error monitoring trade execution: {e}")
    |

scripts/production_integration.py:380:20: BLE001 Do not catch blind exception: `Exception`
    |
378 |                     'performance_report': self.production_monitor.get_performance_report()
379 |                 }
380 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
381 |                 status['systems']['production_monitoring'] = {
382 |                     'status': 'error',
    |

scripts/production_integration.py:394:20: BLE001 Do not catch blind exception: `Exception`
    |
392 |                     'security_report': self.security_manager.get_security_report()
393 |                 }
394 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
395 |                 status['systems']['security'] = {
396 |                     'status': 'error',
    |

scripts/production_integration.py:408:20: BLE001 Do not catch blind exception: `Exception`
    |
406 |                     'performance_report': self.performance_optimizer.get_performance_report()
407 |                 }
408 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
409 |                 status['systems']['performance'] = {
410 |                     'status': 'error',
    |

scripts/production_integration.py:419:20: BLE001 Do not catch blind exception: `Exception`
    |
417 |                 from health_check import get_health_status
418 |                 status['systems']['health'] = get_health_status()
419 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
420 |                 status['systems']['health'] = {
421 |                     'status': 'error',
    |

scripts/production_integration.py:451:55: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
449 |                 systems_count += 1
450 | 
451 |                 if security_audit['security_score'] < 70:
    |                                                       ^^ PLR2004
452 |                     audit_results['critical_issues'].extend(
453 |                         security_audit['recommendations']
    |

scripts/production_integration.py:456:20: BLE001 Do not catch blind exception: `Exception`
    |
454 |                     )
455 | 
456 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
457 |                 audit_results['security_audit'] = {'error': str(e)}
    |

scripts/production_integration.py:476:33: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
474 |                 systems_count += 1
475 | 
476 |                 if perf_score < 70:
    |                                 ^^ PLR2004
477 |                     audit_results['critical_issues'].append(
478 |                         f"Performance violations detected: {len(violations)}"
    |

scripts/production_integration.py:481:20: BLE001 Do not catch blind exception: `Exception`
    |
479 |                     )
480 | 
481 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
482 |                 audit_results['performance_audit'] = {'error': str(e)}
    |

scripts/production_integration.py:502:35: PLR2004 Magic value used in comparison, consider replacing `70` with a constant variable
    |
500 |                 systems_count += 1
501 | 
502 |                 if health_score < 70:
    |                                   ^^ PLR2004
503 |                     audit_results['critical_issues'].append(
504 |                         f"Health status: {health_status['overall_status']}"
    |

scripts/production_integration.py:507:20: BLE001 Do not catch blind exception: `Exception`
    |
505 |                     )
506 | 
507 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
508 |                 audit_results['health_audit'] = {'error': str(e)}
    |

scripts/production_integration.py:515:45: PLR2004 Magic value used in comparison, consider replacing `80` with a constant variable
    |
514 |         # Generate recommendations
515 |         if audit_results['overall_score'] < 80:
    |                                             ^^ PLR2004
516 |             audit_results['recommendations'].extend([
517 |                 "Review and address critical issues immediately",
    |

scripts/production_integration.py:521:47: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
519 |                 "Consider reducing trading activity until issues resolved"
520 |             ])
521 |         elif audit_results['overall_score'] < 90:
    |                                               ^^ PLR2004
522 |             audit_results['recommendations'].extend([
523 |                 "Address identified issues during next maintenance window",
    |

scripts/production_integration.py:540:12: PLW0603 Using the global statement to update `_production_integrator` is discouraged
    |
538 | def get_production_integrator() -> ProductionIntegrator:
539 |     """Get global production integrator instance."""
540 |     global _production_integrator
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
541 |     if _production_integrator is None:
542 |         _production_integrator = ProductionIntegrator()
    |

scripts/production_integration.py:548:12: PLW0603 Using the global statement to update `_production_integrator` is discouraged
    |
546 | def initialize_production_systems(alert_callback: Callable | None = None) -> ProductionIntegrator:
547 |     """Initialize all production systems."""
548 |     global _production_integrator
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
549 |     _production_integrator = ProductionIntegrator()
    |

scripts/production_monitoring.py:208:20: BLE001 Do not catch blind exception: `Exception`
    |
206 |                 self._log_performance_summary(metrics)
207 | 
208 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
209 |                 self.logger.error(f"Error in monitoring loop: {e}")
    |

scripts/production_monitoring.py:238:16: BLE001 Do not catch blind exception: `Exception`
    |
236 |             )
237 | 
238 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
239 |             self.logger.error(f"Error collecting metrics: {e}")
240 |             # Return zero metrics on error
    |

scripts/production_monitoring.py:310:20: BLE001 Do not catch blind exception: `Exception`
    |
308 |                         })
309 | 
310 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
311 |                 self.logger.error(f"Health check {name} failed: {e}")
312 |                 self.last_health_results[name] = HealthCheckResult(
    |

scripts/production_monitoring.py:373:112: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
    |
371 |                     'current': order_latency_values[-1] if order_latency_values else 0,
372 |                     'average': statistics.mean(order_latency_values) if order_latency_values else 0,
373 |                     'p95': statistics.quantiles(order_latency_values, n=20)[18] if len(order_latency_values) > 20 else 0,
    |                                                                                                                ^^ PLR2004
374 |                     'target': self.performance_targets['order_execution_latency_ms']
375 |                 }
    |

scripts/production_monitoring.py:397:12: PLW0603 Using the global statement to update `_production_monitor` is discouraged
    |
395 | def get_production_monitor() -> ProductionMonitor:
396 |     """Get global production monitor instance."""
397 |     global _production_monitor
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
398 |     if _production_monitor is None:
399 |         _production_monitor = ProductionMonitor()
    |

scripts/production_monitoring.py:405:12: PLW0603 Using the global statement to update `_production_monitor` is discouraged
    |
403 | def initialize_production_monitoring(alert_callback: Callable | None = None) -> ProductionMonitor:
404 |     """Initialize production monitoring system."""
405 |     global _production_monitor
    |            ^^^^^^^^^^^^^^^^^^^ PLW0603
406 |     _production_monitor = ProductionMonitor(alert_callback)
407 |     return _production_monitor
    |

scripts/production_validator.py:134:28: BLE001 Do not catch blind exception: `Exception`
    |
132 |                         response_times.append(response_time)
133 |                         successful_requests += 1
134 |                     except Exception as e:
    |                            ^^^^^^^^^ BLE001
135 |                         errors.append(str(e))
136 |                         failed_requests += 1
    |

scripts/production_validator.py:147:24: BLE001 Do not catch blind exception: `Exception`
    |
145 |                     response_times.append(response_time)
146 |                     successful_requests += 1
147 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
148 |                     errors.append(str(e))
149 |                     failed_requests += 1
    |

scripts/production_validator.py:224:20: BLE001 Do not catch blind exception: `Exception`
    |
222 |                 time.sleep(10)
223 | 
224 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
225 |                 self.logger.error(f"Load test {test_name} failed: {e}")
    |

scripts/production_validator.py:242:30: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
241 |         # Simulate occasional errors
242 |         if random.random() < 0.05:  # 5% error rate
    |                              ^^^^ PLR2004
243 |             raise Exception("Simulated error")
    |

scripts/production_validator.py:344:20: BLE001 Do not catch blind exception: `Exception`
    |
342 |                 performance_samples.append(performance)
343 |                 time.sleep(1)
344 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
345 |                 error_details.append(f"Monitoring error at {i}s: {e}")
    |

scripts/production_validator.py:362:20: BLE001 Do not catch blind exception: `Exception`
    |
360 |                     break
361 |                 time.sleep(1)
362 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
363 |                 error_details.append(f"Recovery monitoring error: {e}")
    |

scripts/production_validator.py:435:81: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
433 |         """Check if performance has recovered to baseline levels."""
434 |         # Simple recovery check - CPU and memory within 10% of baseline
435 |         cpu_recovered = abs(current['cpu_percent'] - baseline['cpu_percent']) < 10
    |                                                                                 ^^ PLR2004
436 |         memory_recovered = abs(current['memory_percent'] - baseline['memory_percent']) < 10
    |

scripts/production_validator.py:436:90: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
434 |         # Simple recovery check - CPU and memory within 10% of baseline
435 |         cpu_recovered = abs(current['cpu_percent'] - baseline['cpu_percent']) < 10
436 |         memory_recovered = abs(current['memory_percent'] - baseline['memory_percent']) < 10
    |                                                                                          ^^ PLR2004
437 | 
438 |         return cpu_recovered and memory_recovered
    |

scripts/production_validator.py:471:16: BLE001 Do not catch blind exception: `Exception`
    |
469 |             return True
470 | 
471 |         except Exception:
    |                ^^^^^^^^^ BLE001
472 |             return False
    |

scripts/production_validator.py:486:31: F821 Undefined name `multiprocessing`
    |
484 |         # Start multiple CPU-intensive threads
485 |         threads = []
486 |         for _ in range(min(4, multiprocessing.cpu_count())):
    |                               ^^^^^^^^^^^^^^^ F821
487 |             thread = threading.Thread(target=cpu_burner, daemon=True)
488 |             thread.start()
    |

scripts/production_validator.py:525:29: F821 Undefined name `os`
    |
523 |                 temp_file = f"/tmp/stress_test_{time.time()}.tmp"
524 |                 with open(temp_file, 'wb') as f:
525 |                     f.write(os.urandom(1024 * 1024))  # 1MB of random data
    |                             ^^ F821
526 |                 temp_files.append(temp_file)
527 |                 time.sleep(0.1)
    |

scripts/production_validator.py:532:21: F821 Undefined name `os`
    |
530 |             for temp_file in temp_files:
531 |                 try:
532 |                     os.remove(temp_file)
    |                     ^^ F821
533 |                 except (OSError, FileNotFoundError):
534 |                     logging.debug(f"Could not remove temporary file: {temp_file}")
    |

scripts/production_validator.py:611:38: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
609 |             if performance_score < self.validation_criteria['performance']['min_score']:
610 |                 critical_failures.append(f"Performance tests failed: {performance_score:.1f}% score")
611 |             elif performance_score < 90:
    |                                      ^^ PLR2004
612 |                 warnings.append(f"Performance could be improved: {performance_score:.1f}% score")
    |

scripts/production_validator.py:614:16: BLE001 Do not catch blind exception: `Exception`
    |
612 |                 warnings.append(f"Performance could be improved: {performance_score:.1f}% score")
613 | 
614 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
615 |             critical_failures.append(f"Performance testing failed: {e}")
616 |             test_scores['performance'] = 0
    |

scripts/production_validator.py:632:16: BLE001 Do not catch blind exception: `Exception`
    |
630 |                 critical_failures.append(f"Reliability tests failed: {reliability_score:.1f}% score")
631 | 
632 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
633 |             critical_failures.append(f"Reliability testing failed: {e}")
634 |             test_scores['reliability'] = 0
    |

scripts/production_validator.py:645:16: BLE001 Do not catch blind exception: `Exception`
    |
643 |                 critical_failures.append(f"Security tests failed: {security_score:.1f}% score")
644 | 
645 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
646 |             critical_failures.append(f"Security testing failed: {e}")
647 |             test_scores['security'] = 0
    |

scripts/production_validator.py:658:16: BLE001 Do not catch blind exception: `Exception`
    |
656 |                 critical_failures.append(f"Functionality tests failed: {functionality_score:.1f}% score")
657 | 
658 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
659 |             critical_failures.append(f"Functionality testing failed: {e}")
660 |             test_scores['functionality'] = 0
    |

scripts/production_validator.py:671:16: BLE001 Do not catch blind exception: `Exception`
    |
669 |                 critical_failures.append(f"Compliance tests failed: {compliance_score:.1f}% score")
670 | 
671 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
672 |             critical_failures.append(f"Compliance testing failed: {e}")
673 |             test_scores['compliance'] = 0
    |

scripts/production_validator.py:686:30: PLR2004 Magic value used in comparison, consider replacing `85` with a constant variable
    |
684 |         # Determine production readiness
685 |         production_readiness = (
686 |             overall_score >= 85 and
    |                              ^^ PLR2004
687 |             len(critical_failures) == 0 and
688 |             all(score >= criteria['min_score']
    |

scripts/production_validator.py:789:20: F401 `cryptography` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
787 |         # Check if encryption modules are available
788 |         try:
789 |             import cryptography
    |                    ^^^^^^^^^^^^ F401
790 |             return 95
791 |         except ImportError:
    |
    = help: Remove unused import: `cryptography`

scripts/production_validator.py:815:20: F401 `trade_execution` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
813 |         try:
814 |             # Test imports
815 |             import trade_execution
    |                    ^^^^^^^^^^^^^^^ F401
816 |             from ai_trading.core import bot_engine  # AI-AGENT-REF: canonical import
817 |             return 95
    |
    = help: Remove unused import: `trade_execution`

scripts/production_validator.py:816:41: F401 `ai_trading.core.bot_engine` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
814 |             # Test imports
815 |             import trade_execution
816 |             from ai_trading.core import bot_engine  # AI-AGENT-REF: canonical import
    |                                         ^^^^^^^^^^ F401
817 |             return 95
818 |         except ImportError:
    |
    = help: Remove unused import: `ai_trading.core.bot_engine`

scripts/production_validator.py:833:1: I001 [*] Import block is un-sorted or un-formatted
    |
831 |           """Test data processing functionality."""
832 |           try:
833 | /             import indicators
834 | | 
835 | |             from ai_trading import data_fetcher
836 | |             return 90
    | |_^ I001
837 |           except ImportError:
838 |               return 40
    |
    = help: Organize imports

scripts/production_validator.py:833:20: F401 `indicators` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
831 |         """Test data processing functionality."""
832 |         try:
833 |             import indicators
    |                    ^^^^^^^^^^ F401
834 | 
835 |             from ai_trading import data_fetcher
    |
    = help: Remove unused import: `indicators`

scripts/production_validator.py:835:36: F401 `ai_trading.data_fetcher` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
833 |             import indicators
834 | 
835 |             from ai_trading import data_fetcher
    |                                    ^^^^^^^^^^^^ F401
836 |             return 90
837 |         except ImportError:
    |
    = help: Remove unused import: `ai_trading.data_fetcher`

scripts/production_validator.py:843:46: F401 `ai_trading.telemetry.metrics_logger` imported but unused; consider using `importlib.util.find_spec` to test for availability
    |
841 |         """Test reporting system functionality."""
842 |         try:
843 |             from ai_trading.telemetry import metrics_logger
    |                                              ^^^^^^^^^^^^^^ F401
844 |             return 85
845 |         except ImportError:
    |
    = help: Remove unused import: `ai_trading.telemetry.metrics_logger`

scripts/production_validator.py:889:48: PLR2004 Magic value used in comparison, consider replacing `85` with a constant variable
    |
888 |         # Performance recommendations
889 |         if test_scores.get('performance', 0) < 85:
    |                                                ^^ PLR2004
890 |             recommendations.append("Optimize performance: Consider caching, connection pooling, and algorithm optimization")
    |

scripts/production_validator.py:893:48: PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
    |
892 |         # Reliability recommendations
893 |         if test_scores.get('reliability', 0) < 90:
    |                                                ^^ PLR2004
894 |             recommendations.append("Improve reliability: Implement better error handling and recovery mechanisms")
    |

scripts/production_validator.py:897:45: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
896 |         # Security recommendations
897 |         if test_scores.get('security', 0) < 95:
    |                                             ^^ PLR2004
898 |             recommendations.append("Enhance security: Review access controls, encryption, and audit logging")
    |

scripts/production_validator.py:901:50: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
900 |         # Functionality recommendations
901 |         if test_scores.get('functionality', 0) < 95:
    |                                                  ^^ PLR2004
902 |             recommendations.append("Fix functionality issues: Address module import errors and core functionality")
    |

scripts/production_validator.py:920:12: PLW0603 Using the global statement to update `_production_validator` is discouraged
    |
918 | def get_production_validator() -> ProductionValidator:
919 |     """Get global production validator instance."""
920 |     global _production_validator
    |            ^^^^^^^^^^^^^^^^^^^^^ PLW0603
921 |     if _production_validator is None:
922 |         _production_validator = ProductionValidator()
    |

scripts/profile_indicators.py:4:1: E402 Module level import not at top of file
  |
3 | logger = logging.getLogger(__name__)
4 | import inspect
  | ^^^^^^^^^^^^^^ E402
5 | import time
  |

scripts/profile_indicators.py:4:1: I001 [*] Import block is un-sorted or un-formatted
   |
 3 |   logger = logging.getLogger(__name__)
 4 | / import inspect
 5 | | import time
 6 | | 
 7 | | import numpy as np
 8 | | import pandas as pd
 9 | | 
10 | | from ai_trading import indicators, signals
11 | | 
12 | | 
13 | | def profile(func, *args, **kwargs):
   | |_^ I001
14 |       start = time.perf_counter()
15 |       try:
   |
   = help: Organize imports

scripts/profile_indicators.py:5:1: E402 Module level import not at top of file
  |
3 | logger = logging.getLogger(__name__)
4 | import inspect
5 | import time
  | ^^^^^^^^^^^ E402
6 | 
7 | import numpy as np
  |

scripts/profile_indicators.py:7:1: E402 Module level import not at top of file
  |
5 | import time
6 | 
7 | import numpy as np
  | ^^^^^^^^^^^^^^^^^^ E402
8 | import pandas as pd
  |

scripts/profile_indicators.py:8:1: E402 Module level import not at top of file
   |
 7 | import numpy as np
 8 | import pandas as pd
   | ^^^^^^^^^^^^^^^^^^^ E402
 9 | 
10 | from ai_trading import indicators, signals
   |

scripts/profile_indicators.py:10:1: E402 Module level import not at top of file
   |
 8 | import pandas as pd
 9 | 
10 | from ai_trading import indicators, signals
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/profile_indicators.py:17:12: BLE001 Do not catch blind exception: `Exception`
   |
15 |     try:
16 |         result = func(*args, **kwargs)
17 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
18 |         logger.error("%s failed: %s", func.__name__, e)
19 |         return None, -1
   |

scripts/rebalancer.py:26:5: F403 `from ai_trading.rebalancer import *` used; unable to detect undefined names
   |
24 | _import_success = False
25 | try:
26 |     from ai_trading.rebalancer import *
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F403
27 |     _import_success = True
28 | except Exception:
   |

scripts/rebalancer.py:28:8: BLE001 Do not catch blind exception: `Exception`
   |
26 |     from ai_trading.rebalancer import *
27 |     _import_success = True
28 | except Exception:
   |        ^^^^^^^^^ BLE001
29 |     # Create minimal rebalancer functionality for testing if import fails
30 |     pass
   |

scripts/rebalancer.py:48:5: PLW0127 Self-assignment of variable `datetime`
   |
47 |     # Re-export datetime utilities that tests might need
48 |     datetime = datetime
   |     ^^^^^^^^ PLW0127
49 |     timedelta = timedelta
50 |     timezone = timezone
   |

scripts/rebalancer.py:49:5: PLW0127 Self-assignment of variable `timedelta`
   |
47 |     # Re-export datetime utilities that tests might need
48 |     datetime = datetime
49 |     timedelta = timedelta
   |     ^^^^^^^^^ PLW0127
50 |     timezone = timezone
51 |     threading = threading
   |

scripts/rebalancer.py:50:5: PLW0127 Self-assignment of variable `timezone`
   |
48 |     datetime = datetime
49 |     timedelta = timedelta
50 |     timezone = timezone
   |     ^^^^^^^^ PLW0127
51 |     threading = threading
   |

scripts/rebalancer.py:51:5: PLW0127 Self-assignment of variable `threading`
   |
49 |     timedelta = timedelta
50 |     timezone = timezone
51 |     threading = threading
   |     ^^^^^^^^^ PLW0127
   |

scripts/retrain_model.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import csv
 2 | | import json
 3 | | import logging
 4 | | import os
 5 | | import random
 6 | | 
 7 | | # pandas_ta SyntaxWarning now filtered globally in pytest.ini
 8 | | # AI-AGENT-REF: graceful joblib fallback for testing
 9 | | import joblib
10 | | 
11 | | # AI-AGENT-REF: graceful numpy fallback for testing
12 | | import numpy as np
13 | | 
14 | | # AI-AGENT-REF: graceful pandas fallback for testing
15 | | import pandas as pd
16 | | 
17 | | from ai_trading.config import management as config
18 | | from ai_trading.config.management import TradingConfig
19 | | 
20 | | CONFIG = TradingConfig()
   | |_^ I001
21 |   
22 |   from ai_trading.utils.base import safe_to_datetime
   |
   = help: Organize imports

scripts/retrain_model.py:22:1: E402 Module level import not at top of file
   |
20 | CONFIG = TradingConfig()
21 | 
22 | from ai_trading.utils.base import safe_to_datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
23 | 
24 | logger = logging.getLogger(__name__)
   |

scripts/retrain_model.py:38:1: E402 Module level import not at top of file
   |
36 | except ImportError:
37 |     pass
38 | import importlib
   | ^^^^^^^^^^^^^^^^ E402
39 | from datetime import UTC, date, datetime, time, timedelta
   |

scripts/retrain_model.py:39:1: E402 Module level import not at top of file
   |
37 |     pass
38 | import importlib
39 | from datetime import UTC, date, datetime, time, timedelta
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
40 | 
41 | import requests
   |

scripts/retrain_model.py:41:1: E402 Module level import not at top of file
   |
39 | from datetime import UTC, date, datetime, time, timedelta
40 | 
41 | import requests
   | ^^^^^^^^^^^^^^^ E402
42 | 
43 | # AI-AGENT-REF: graceful lightgbm fallback for testing
   |

scripts/retrain_model.py:44:1: E402 Module level import not at top of file
   |
43 | # AI-AGENT-REF: graceful lightgbm fallback for testing
44 | from lightgbm import LGBMClassifier
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
45 | 
46 | # AI-AGENT-REF: graceful sklearn fallback for testing
   |

scripts/retrain_model.py:47:1: E402 Module level import not at top of file
   |
46 | # AI-AGENT-REF: graceful sklearn fallback for testing
47 | from sklearn.model_selection import ParameterSampler, cross_val_score
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
48 | from sklearn.pipeline import make_pipeline
49 | from sklearn.preprocessing import StandardScaler
   |

scripts/retrain_model.py:48:1: E402 Module level import not at top of file
   |
46 | # AI-AGENT-REF: graceful sklearn fallback for testing
47 | from sklearn.model_selection import ParameterSampler, cross_val_score
48 | from sklearn.pipeline import make_pipeline
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
49 | from sklearn.preprocessing import StandardScaler
   |

scripts/retrain_model.py:49:1: E402 Module level import not at top of file
   |
47 | from sklearn.model_selection import ParameterSampler, cross_val_score
48 | from sklearn.pipeline import make_pipeline
49 | from sklearn.preprocessing import StandardScaler
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
50 | 
51 | try:
   |

scripts/retrain_model.py:53:8: BLE001 Do not catch blind exception: `Exception`
   |
51 | try:
52 |     import optuna
53 | except Exception as e:  # pragma: no cover - optional dependency
   |        ^^^^^^^^^ BLE001
54 |     logger.warning("Optuna import failed: %s", e)
55 |     optuna = None
   |

scripts/retrain_model.py:83:12: BLE001 Do not catch blind exception: `Exception`
   |
81 |             .strip()
82 |         )
83 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
84 |         logger.debug("git hash lookup failed: %s", e)
85 |         return "unknown"
   |

scripts/retrain_model.py:186:12: BLE001 Do not catch blind exception: `Exception`
    |
184 |         return max(-1.0, min(1.0, sentiment_score / max(len(articles), 1)))
185 | 
186 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
187 |         logger.warning("Failed to fetch sentiment for %s: %s", symbol, e)
188 |         return 0.0
    |

scripts/retrain_model.py:198:25: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
196 |     try:
197 |         close = df["close"].astype(float)
198 |         if len(close) < 50:
    |                         ^^ PLR2004
199 |             return "chop"
    |

scripts/retrain_model.py:214:12: BLE001 Do not catch blind exception: `Exception`
    |
212 |         else:
213 |             return "chop"
214 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
215 |         logger.warning("Regime detection failed: %s", e)
216 |         return "chop"
    |

scripts/retrain_model.py:484:14: DTZ011 `datetime.date.today()` used
    |
482 |     """
483 |     raw_store: dict[str, pd.DataFrame] = {}
484 |     end_dt = date.today()
    |              ^^^^^^^^^^^^ DTZ011
485 |     start_dt = end_dt - timedelta(days=lookback_days)
    |
    = help: Use `datetime.datetime.now(tz=...).date()` instead

scripts/retrain_model.py:524:5: PLC2401 Argument name `Δ_minutes` contains a non-ASCII character
    |
522 | def build_feature_label_df(
523 |     raw_store: dict[str, pd.DataFrame],
524 |     Δ_minutes: int = 30,
    |     ^^^^^^^^^ PLC2401
525 |     threshold_pct: float = 0.002,
526 | ) -> pd.DataFrame:
    |
    = help: Rename the variable using ASCII characters

scripts/retrain_model.py:555:21: PLW2901 `for` loop variable `raw` overwritten by assignment target
    |
553 |             for col in list(raw.columns):
554 |                 if col.lower() in ["high", "low", "close", "volume"]:
555 |                     raw = raw.rename(columns={col: col.lower()})
    |                     ^^^ PLW2901
556 |             logger.debug(f"After rename {sym}, tail close:\n{raw[['close']].tail(5)}")
557 |             if (
    |

scripts/retrain_model.py:737:38: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
735 |             parent = random.choice(new_pop).copy()
736 |             for k, values in param_space.items():
737 |                 if random.random() < 0.3:
    |                                      ^^^ PLR2004
738 |                     parent[k] = random.choice(values)
739 |             new_pop.append(parent)
    |

scripts/retrain_model.py:776:5: PLC2401 Argument name `Δ_minutes` contains a non-ASCII character
    |
774 |     symbols,
775 |     lookback_days: int = 5,
776 |     Δ_minutes: int = 30,
    |     ^^^^^^^^^ PLC2401
777 |     threshold_pct: float = 0.002,
778 |     force: bool = False,
    |
    = help: Rename the variable using ASCII characters

scripts/retrain_model.py:782:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
780 |     now = datetime.now(UTC)
781 |     if not force:
782 |         if now.weekday() >= 5:
    |                             ^ PLR2004
783 |             logger.info(
784 |                 "[retrain_meta_learner] Weekend detected; skipping",
    |

scripts/retrain_model.py:842:31: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
841 |         try:
842 |             if len(y_train) < 3:
    |                               ^ PLR2004
843 |                 logger.warning(
844 |                     "[retrain_meta_learner] Not enough training samples for %s; skipping",
    |

scripts/retrain_model.py:853:27: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
852 |         pos_ratio = y_train.mean()
853 |         scoring = "f1" if 0.4 <= pos_ratio <= 0.6 else "roc_auc"
    |                           ^^^ PLR2004
854 |         logger.info(
855 |             "Training %s model using scoring='%s' (pos_ratio=%.3f)",
    |

scripts/retrain_model.py:853:47: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
852 |         pos_ratio = y_train.mean()
853 |         scoring = "f1" if 0.4 <= pos_ratio <= 0.6 else "roc_auc"
    |                                               ^^^ PLR2004
854 |         logger.info(
855 |             "Training %s model using scoring='%s' (pos_ratio=%.3f)",
    |

scripts/run_wfa.py:22:60: F401 `ai_trading.signals.generate_cost_aware_signals` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
20 |     from ai_trading.evaluation.walkforward import WalkForwardEvaluator
21 |     from ai_trading.logging import logger
22 |     from ai_trading.signals import SignalDecisionPipeline, generate_cost_aware_signals
   |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ F401
23 | except ImportError:
24 |     sys.exit(1)
   |
   = help: Remove unused import: `ai_trading.signals.generate_cost_aware_signals`

scripts/run_wfa.py:66:39: F821 Undefined name `pd`
   |
64 |                 try:
65 |                     # Get historical data up to current point
66 |                     historical_data = pd.concat([
   |                                       ^^ F821
67 |                         train_df.tail(100),  # Last 100 days of training
68 |                         test_df.iloc[:i]     # Test data up to current point
   |

scripts/run_wfa.py:71:47: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
69 |                     ])
70 | 
71 |                     if len(historical_data) < 50:  # Need sufficient history
   |                                               ^^ PLR2004
72 |                         continue
   |

scripts/run_wfa.py:90:28: BLE001 Do not catch blind exception: `Exception`
   |
88 |                         predicted_edge = max(-0.05, min(0.05, predicted_edge))
89 | 
90 |                     except Exception:
   |                            ^^^^^^^^^ BLE001
91 |                         predicted_edge = 0.0
   |

scripts/run_wfa.py:134:24: BLE001 Do not catch blind exception: `Exception`
    |
132 |                         })
133 | 
134 |                 except Exception as e:
    |                        ^^^^^^^^^ BLE001
135 |                     logger.debug("Signal generation failed for %s at %d: %s", symbol, i, e)
136 |                     continue
    |

scripts/run_wfa.py:155:20: BLE001 Do not catch blind exception: `Exception`
    |
153 |             try:
154 |                 return data_fetcher.get_historical_data(symbol, start_date, end_date)
155 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
156 |                 logger.warning("Failed to get data for %s: %s", symbol, e)
157 |                 return None
    |

scripts/run_wfa.py:254:12: BLE001 Do not catch blind exception: `Exception`
    |
252 |         logger.info("Walk-forward validation interrupted by user")
253 |         sys.exit(0)
254 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
255 |         logger.error("Walk-forward validation error: %s", e, exc_info=True)
256 |         sys.exit(1)
    |

scripts/scalability_manager.py:175:58: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
174 |         recent_tasks = [t for t in self.task_timings
175 |                        if time.time() - t['timestamp'] < 300]  # Last 5 minutes
    |                                                          ^^^ PLR2004
176 | 
177 |         if not recent_tasks:
    |

scripts/scalability_manager.py:188:46: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
186 |         # Count tasks in last 60 seconds
187 |         recent_tasks = [t for t in self.throughput_tracker
188 |                        if current_time - t < 60]
    |                                              ^^ PLR2004
189 | 
190 |         return len(recent_tasks) / 60.0
    |

scripts/scalability_manager.py:223:62: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
222 |             recent_tasks = [t for t in self.task_timings
223 |                            if time.time() - t['timestamp'] < 60]
    |                                                              ^^ PLR2004
224 | 
225 |             return min(1.0, len(recent_tasks) / (self.max_workers * 60)) * 100
    |

scripts/scalability_manager.py:338:32: BLE001 Do not catch blind exception: `Exception`
    |
336 |                             })
337 | 
338 |                         except Exception as e:
    |                                ^^^^^^^^^ BLE001
339 |                             self.logger.error(f"Failed to backup {file_path}: {e}")
    |

scripts/scalability_manager.py:372:16: BLE001 Do not catch blind exception: `Exception`
    |
370 |             return backup_info
371 | 
372 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
373 |             self.logger.error(f"Backup creation failed: {e}")
374 |             backup_info['success'] = False
    |

scripts/scalability_manager.py:415:16: BLE001 Do not catch blind exception: `Exception`
    |
413 |             return True
414 | 
415 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
416 |             self.logger.error(f"Backup restoration failed: {e}")
417 |             return False
    |

scripts/scalability_manager.py:428:35: DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
    |
426 |                 if backup_path.is_dir():
427 |                     # Check backup age
428 |                     backup_time = datetime.fromtimestamp(backup_path.stat().st_mtime)
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ006
429 | 
430 |                     if backup_time < cutoff_date:
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

scripts/scalability_manager.py:437:16: BLE001 Do not catch blind exception: `Exception`
    |
435 |                 self.logger.info(f"Cleaned up {removed_count} old backups")
436 | 
437 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
438 |             self.logger.error(f"Backup cleanup failed: {e}")
    |

scripts/scalability_manager.py:458:34: DTZ006 `datetime.datetime.fromtimestamp()` called without a `tz` argument
    |
456 |                 backup_list.append({
457 |                     'name': backup_path.name,
458 |                     'timestamp': datetime.fromtimestamp(backup_path.stat().st_mtime).isoformat(),
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ006
459 |                     'size': size
460 |                 })
    |
    = help: Pass a `datetime.timezone` object to the `tz` parameter

scripts/scalability_manager.py:545:20: BLE001 Do not catch blind exception: `Exception`
    |
543 |                 self._update_system_state(health_status)
544 | 
545 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
546 |                 self.logger.error(f"Error in HA monitoring loop: {e}")
    |

scripts/scalability_manager.py:565:16: BLE001 Do not catch blind exception: `Exception`
    |
563 |                 'metrics': lb_metrics
564 |             }
565 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
566 |             health_status['components']['load_balancer'] = {
567 |                 'healthy': False,
    |

scripts/scalability_manager.py:579:16: BLE001 Do not catch blind exception: `Exception`
    |
577 |                 'status': backup_status
578 |             }
579 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
580 |             health_status['components']['data_replication'] = {
581 |                 'healthy': False,
    |

scripts/scalability_manager.py:597:40: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
596 |             # Mark unhealthy if resources are critically low
597 |             if (psutil.cpu_percent() > 95 or
    |                                        ^^ PLR2004
598 |                 psutil.virtual_memory().percent > 95 or
599 |                 psutil.disk_usage('/').percent > 95):
    |

scripts/scalability_manager.py:598:51: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
596 |             # Mark unhealthy if resources are critically low
597 |             if (psutil.cpu_percent() > 95 or
598 |                 psutil.virtual_memory().percent > 95 or
    |                                                   ^^ PLR2004
599 |                 psutil.disk_usage('/').percent > 95):
600 |                 health_status['components']['system_resources']['healthy'] = False
    |

scripts/scalability_manager.py:599:50: PLR2004 Magic value used in comparison, consider replacing `95` with a constant variable
    |
597 |             if (psutil.cpu_percent() > 95 or
598 |                 psutil.virtual_memory().percent > 95 or
599 |                 psutil.disk_usage('/').percent > 95):
    |                                                  ^^ PLR2004
600 |                 health_status['components']['system_resources']['healthy'] = False
601 |                 health_status['overall_healthy'] = False
    |

scripts/scalability_manager.py:710:16: BLE001 Do not catch blind exception: `Exception`
    |
708 |             test_results['tests_performed'].append('load_balancer_resilience')
709 |             test_results['tests_passed'] += 1
710 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
711 |             test_results['tests_performed'].append(f'load_balancer_resilience_FAILED: {e}')
712 |             test_results['tests_failed'] += 1
    |

scripts/scalability_manager.py:723:16: BLE001 Do not catch blind exception: `Exception`
    |
721 |                 test_results['tests_performed'].append('backup_system_FAILED')
722 |                 test_results['tests_failed'] += 1
723 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
724 |             test_results['tests_performed'].append(f'backup_system_FAILED: {e}')
725 |             test_results['tests_failed'] += 1
    |

scripts/scalability_manager.py:736:16: BLE001 Do not catch blind exception: `Exception`
    |
734 |                 test_results['tests_performed'].append('health_monitoring_FAILED')
735 |                 test_results['tests_failed'] += 1
736 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
737 |             test_results['tests_performed'].append(f'health_monitoring_FAILED: {e}')
738 |             test_results['tests_failed'] += 1
    |

scripts/scalability_manager.py:764:16: BLE001 Do not catch blind exception: `Exception`
    |
762 |             self.logger.info("Emergency shutdown completed")
763 | 
764 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
765 |             self.logger.error(f"Error during emergency shutdown: {e}")
    |

scripts/scalability_manager.py:774:12: PLW0603 Using the global statement to update `_ha_manager` is discouraged
    |
772 | def get_ha_manager() -> HighAvailabilityManager:
773 |     """Get global high availability manager instance."""
774 |     global _ha_manager
    |            ^^^^^^^^^^^ PLW0603
775 |     if _ha_manager is None:
776 |         _ha_manager = HighAvailabilityManager()
    |

scripts/scalability_manager.py:782:12: PLW0603 Using the global statement to update `_ha_manager` is discouraged
    |
780 | def initialize_high_availability() -> HighAvailabilityManager:
781 |     """Initialize high availability system."""
782 |     global _ha_manager
    |            ^^^^^^^^^^^ PLW0603
783 |     _ha_manager = HighAvailabilityManager()
784 |     _ha_manager.start_monitoring()
    |

scripts/security_manager.py:297:86: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
295 |         # Check for unusual trade size
296 |         recent_trades = [t for t in self.trade_history
297 |                         if t['symbol'] == symbol and current_time - t['timestamp'] < 3600]
    |                                                                                      ^^^^ PLR2004
298 | 
299 |         if len(recent_trades) > 1:
    |

scripts/security_manager.py:314:60: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
    |
312 |         # Check for rapid-fire orders
313 |         recent_orders = [t for t in self.trade_history
314 |                         if current_time - t['timestamp'] < 60]  # Last minute
    |                                                            ^^ PLR2004
315 | 
316 |         if len(recent_orders) >= self.thresholds['rapid_fire_orders']:
    |

scripts/security_manager.py:366:86: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
364 |         """Get comprehensive anomaly report."""
365 |         recent_anomalies = [a for a in self.anomalies_detected
366 |                            if (datetime.now(UTC) - a['timestamp']).total_seconds() < 3600]
    |                                                                                      ^^^^ PLR2004
367 | 
368 |         return {
    |

scripts/security_manager.py:416:9: PLR0911 Too many return statements (8 > 6)
    |
414 |         self.logger.info("Security manager initialized")
415 | 
416 |     def authenticate_api_request(self, api_key: str, signature: str,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
417 |                                 timestamp: str, body: str, client_ip: str = None) -> bool:
418 |         """Authenticate API request with HMAC signature."""
    |

scripts/security_manager.py:455:55: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
453 |                 request_time = float(timestamp)
454 |                 current_time = time.time()
455 |                 if abs(current_time - request_time) > 300:  # 5 minute window
    |                                                       ^^^ PLR2004
456 |                     self._handle_failed_auth(client_ip, "Request timestamp expired")
457 |                     return False
    |

scripts/security_manager.py:483:16: BLE001 Do not catch blind exception: `Exception`
    |
481 |             return True
482 | 
483 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
484 |             self.logger.error(f"Authentication error: {e}")
485 |             self._handle_failed_auth(client_ip, f"Authentication error: {e}")
    |

scripts/security_manager.py:599:72: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
    |
597 |         recent_events = [
598 |             event for event in self.security_events
599 |             if (datetime.now(UTC) - event.timestamp).total_seconds() < 3600
    |                                                                        ^^^^ PLR2004
600 |         ]
    |

scripts/security_manager.py:673:69: PLR2004 Magic value used in comparison, consider replacing `86400` with a constant variable
    |
671 |             event for event in self.security_events
672 |             if event.severity == SecurityLevel.CRITICAL and
673 |             (datetime.now(UTC) - event.timestamp).total_seconds() < 86400
    |                                                                     ^^^^^ PLR2004
674 |         ]
    |

scripts/security_manager.py:696:12: PLW0603 Using the global statement to update `_security_manager` is discouraged
    |
694 | def get_security_manager() -> SecurityManager:
695 |     """Get global security manager instance."""
696 |     global _security_manager
    |            ^^^^^^^^^^^^^^^^^ PLW0603
697 |     if _security_manager is None:
698 |         _security_manager = SecurityManager()
    |

scripts/security_manager.py:704:12: PLW0603 Using the global statement to update `_security_manager` is discouraged
    |
702 | def initialize_security_manager(enable_encryption: bool = True) -> SecurityManager:
703 |     """Initialize security manager."""
704 |     global _security_manager
    |            ^^^^^^^^^^^^^^^^^ PLW0603
705 |     _security_manager = SecurityManager(enable_encryption)
706 |     return _security_manager
    |

scripts/slippage.py:6:8: BLE001 Do not catch blind exception: `Exception`
  |
4 |     from ai_trading.validation.validate_env import Settings
5 |     settings = Settings()
6 | except Exception:
  |        ^^^^^^^^^ BLE001
7 |     settings = None
  |

scripts/smoke_backtest.py:60:28: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
58 |         cost_drag_bps = (total_costs / position_value) * 10000
59 | 
60 |         if cost_drag_bps < 5.0:
   |                            ^^^ PLR2004
61 |             raise AssertionError(f"Cost drag ({cost_drag_bps:.1f} bps) seems too low")
   |

scripts/smoke_backtest.py:66:12: BLE001 Do not catch blind exception: `Exception`
   |
64 |         return True
65 | 
66 |     except Exception:
   |            ^^^^^^^^^ BLE001
67 |         return False
   |

scripts/smoke_imports.py:17:12: BLE001 Do not catch blind exception: `Exception`
   |
15 |         __import__(module_name)
16 |         return True, f"✅ {module_name} {description}"
17 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
18 |         return False, f"❌ {module_name} {description}: {e}"
   |

scripts/smoke_imports.py:30:12: BLE001 Do not catch blind exception: `Exception`
   |
28 |         cls(*args, **kwargs)
29 |         return True, f"✅ {module_name}.{class_name} {description}"
30 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
31 |         return False, f"❌ {module_name}.{class_name} {description}: {e}"
   |

scripts/smoke_imports.py:53:43: F401 `ai_trading.monitoring.MetricsCollector` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
51 |     # Monitoring classes - critical for startup
52 |     try:
53 |         from ai_trading.monitoring import MetricsCollector, PerformanceMonitor
   |                                           ^^^^^^^^^^^^^^^^ F401
54 |         tests.append((True, "✅ MetricsCollector and PerformanceMonitor imported successfully"))
55 |     except ImportError as e:
   |
   = help: Remove unused import

scripts/smoke_imports.py:53:61: F401 `ai_trading.monitoring.PerformanceMonitor` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
51 |     # Monitoring classes - critical for startup
52 |     try:
53 |         from ai_trading.monitoring import MetricsCollector, PerformanceMonitor
   |                                                             ^^^^^^^^^^^^^^^^^^ F401
54 |         tests.append((True, "✅ MetricsCollector and PerformanceMonitor imported successfully"))
55 |     except ImportError as e:
   |
   = help: Remove unused import

scripts/smoke_imports.py:121:12: BLE001 Do not catch blind exception: `Exception`
    |
119 |             tests.append((False, "❌ TradingConfig.to_dict(safe=True) does not redact secrets properly"))
120 | 
121 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
122 |         tests.append((False, f"❌ TradingConfig.from_env() failed: {e}"))
    |

scripts/smoke_imports.py:132:12: BLE001 Do not catch blind exception: `Exception`
    |
130 |         else:
131 |             tests.append((False, "❌ StrategyAllocator missing allocate method"))
132 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
133 |         tests.append((False, f"❌ StrategyAllocator instantiation failed: {e}"))
    |

scripts/smoke_runtime.py:34:12: BLE001 Do not catch blind exception: `Exception`
   |
32 |         return True
33 | 
34 |     except Exception:
   |            ^^^^^^^^^ BLE001
35 |         return False
   |

scripts/smoke_runtime.py:54:12: BLE001 Do not catch blind exception: `Exception`
   |
52 |         return True
53 | 
54 |     except Exception:
   |            ^^^^^^^^^ BLE001
55 |         return False
   |

scripts/smoke_runtime.py:97:16: BLE001 Do not catch blind exception: `Exception`
   |
95 |             else:
96 |                 pass
97 |         except Exception:
   |                ^^^^^^^^^ BLE001
98 |             # Other exceptions are fine, we just want to test params access
99 |             pass
   |

scripts/smoke_runtime.py:103:12: BLE001 Do not catch blind exception: `Exception`
    |
101 |         return True
102 | 
103 |     except Exception:
    |            ^^^^^^^^^ BLE001
104 |         return False
    |

scripts/smoke_runtime.py:110:1: I001 [*] Import block is un-sorted or un-formatted
    |
108 |       """Test the empty DataFrame helper creates valid indexes."""
109 |       try:
110 | /         import pandas as pd
111 | | 
112 | |         from ai_trading.core.bot_engine import _create_empty_bars_dataframe
113 | | 
    | |_^ I001
114 |           # Test the helper function
115 |           empty_df = _create_empty_bars_dataframe("daily")
    |
    = help: Organize imports

scripts/smoke_runtime.py:126:12: BLE001 Do not catch blind exception: `Exception`
    |
124 |         return True
125 | 
126 |     except Exception:
    |            ^^^^^^^^^ BLE001
127 |         return False
    |

scripts/smoke_runtime.py:147:16: BLE001 Do not catch blind exception: `Exception`
    |
145 |             else:
146 |                 pass
147 |         except Exception:
    |                ^^^^^^^^^ BLE001
148 |             pass
    |

scripts/system_diagnostic.py:99:42: PLR2004 Magic value used in comparison, consider replacing `11` with a constant variable
    |
 97 |                     if 'python' in line.lower() and line.strip():
 98 |                         parts = line.split()
 99 |                         if len(parts) >= 11:
    |                                          ^^ PLR2004
100 |                             processes.append({
101 |                                 'user': parts[0],
    |

scripts/system_diagnostic.py:141:16: BLE001 Do not catch blind exception: `Exception`
    |
139 |                 'function_objects': len([obj for obj in all_objects if callable(obj)])
140 |             }
141 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
142 |             gc_info['object_counts'] = {'error': str(e)}
    |

scripts/system_diagnostic.py:165:16: BLE001 Do not catch blind exception: `Exception`
    |
163 |                     except OSError:
164 |                         continue
165 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
166 |             file_info['error'] = str(e)
    |

scripts/system_diagnostic.py:216:32: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
214 |                 if hasattr(module, '__dict__'):
215 |                     attrs = len(module.__dict__)
216 |                     if attrs > 100:  # Arbitrary threshold for "large"
    |                                ^^^ PLR2004
217 |                         large_modules.append((name, attrs))
218 |             except (AttributeError, ImportError):
    |

scripts/system_diagnostic.py:279:16: BLE001 Do not catch blind exception: `Exception`
    |
277 |             disk_info['large_files'] = sorted(large_files, key=lambda x: x[1], reverse=True)[:10]
278 | 
279 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
280 |             disk_info['error'] = str(e)
    |

scripts/system_diagnostic.py:317:20: BLE001 Do not catch blind exception: `Exception`
    |
315 |                 diagnostic_results[f'{check_name}_time_ms'] = check_time * 1000
316 | 
317 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
318 |                 self.logger.error(f"Error in {check_name}: {str(e)}")
319 |                 diagnostic_results[check_name] = {'error': str(e)}
    |

scripts/system_diagnostic.py:335:76: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
333 |             if 'system_memory' in memory and isinstance(memory['system_memory'], dict):
334 |                 sys_mem = memory['system_memory']
335 |                 if 'swap_used_mb' in sys_mem and sys_mem['swap_used_mb'] > 100:
    |                                                                            ^^^ PLR2004
336 |                     recommendations.append(
337 |                         f"HIGH PRIORITY: Reduce swap usage ({sys_mem['swap_used_mb']:.1f}MB). "
    |

scripts/system_diagnostic.py:342:69: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
341 |                 if ('total_mb' in sys_mem and 'available_mb' in sys_mem and
342 |                     sys_mem['available_mb'] / sys_mem['total_mb'] < 0.1):
    |                                                                     ^^^ PLR2004
343 |                     recommendations.append(
344 |                         "MEDIUM PRIORITY: Low available memory. "
    |

scripts/system_diagnostic.py:362:61: PLR2004 Magic value used in comparison, consider replacing `100000` with a constant variable
    |
360 |             if ('object_counts' in gc_data and isinstance(gc_data['object_counts'], dict) and
361 |                 'total_objects' in gc_data['object_counts'] and
362 |                 gc_data['object_counts']['total_objects'] > 100000):
    |                                                             ^^^^^^ PLR2004
363 |                 recommendations.append(
364 |                     "MEDIUM PRIORITY: High object count detected. "
    |

scripts/system_diagnostic.py:371:84: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
369 |         if 'thread_analysis' in results:
370 |             thread_data = results['thread_analysis']
371 |             if 'active_threads' in thread_data and thread_data['active_threads'] > 10:
    |                                                                                    ^^ PLR2004
372 |                 recommendations.append(
373 |                     f"LOW PRIORITY: High thread count ({thread_data['active_threads']}). "
    |

scripts/system_diagnostic.py:380:90: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
378 |         if 'file_handles' in results:
379 |             fh_data = results['file_handles']
380 |             if 'open_file_descriptors' in fh_data and fh_data['open_file_descriptors'] > 100:
    |                                                                                          ^^^ PLR2004
381 |                 recommendations.append(
382 |                     f"MEDIUM PRIORITY: High file descriptor count ({fh_data['open_file_descriptors']}). "
    |

scripts/system_health_checker.py:236:16: BLE001 Do not catch blind exception: `Exception`
    |
234 |             )
235 | 
236 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
237 |             self.logger.error("Failed to check sentiment health: %s", e)
238 |             return ComponentHealth(
    |

scripts/system_health_checker.py:264:37: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
262 |                     status = "healthy"
263 |                     issue = f"Active with {trade_count} trades"
264 |                 elif trade_count >= 3:  # Can bootstrap
    |                                     ^ PLR2004
265 |                     success_rate = 0.6
266 |                     status = "warning"
    |

scripts/system_health_checker.py:295:16: BLE001 Do not catch blind exception: `Exception`
    |
293 |                 )
294 | 
295 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
296 |             self.logger.error("Failed to check meta-learning health: %s", e)
297 |             return ComponentHealth(
    |

scripts/system_health_checker.py:356:35: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
355 |                 # Basic health assessment
356 |                 if active_count < 10:  # Reasonable number of active orders
    |                                   ^^ PLR2004
357 |                     status = "healthy"
358 |                     success_rate = 0.8  # Assume good performance
    |

scripts/system_health_checker.py:377:16: BLE001 Do not catch blind exception: `Exception`
    |
375 |                 )
376 | 
377 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
378 |             self.logger.error("Failed to check order execution health: %s", e)
379 |             return ComponentHealth(
    |

scripts/system_health_checker.py:399:36: PLR2004 Magic value used in comparison, consider replacing `0.20` with a constant variable
    |
398 |             # Assess if thresholds are reasonable (not too aggressive)
399 |             if spread_threshold <= 0.20 and aggressive_reduction >= 0.70:
    |                                    ^^^^ PLR2004
400 |                 status = "healthy"
401 |                 success_rate = 0.9
    |

scripts/system_health_checker.py:399:69: PLR2004 Magic value used in comparison, consider replacing `0.70` with a constant variable
    |
398 |             # Assess if thresholds are reasonable (not too aggressive)
399 |             if spread_threshold <= 0.20 and aggressive_reduction >= 0.70:
    |                                                                     ^^^^ PLR2004
400 |                 status = "healthy"
401 |                 success_rate = 0.9
    |

scripts/system_health_checker.py:403:38: PLR2004 Magic value used in comparison, consider replacing `0.50` with a constant variable
    |
401 |                 success_rate = 0.9
402 |                 issue = "Thresholds configured appropriately"
403 |             elif spread_threshold <= 0.50 and aggressive_reduction >= 0.50:
    |                                      ^^^^ PLR2004
404 |                 status = "warning"
405 |                 success_rate = 0.7
    |

scripts/system_health_checker.py:403:71: PLR2004 Magic value used in comparison, consider replacing `0.50` with a constant variable
    |
401 |                 success_rate = 0.9
402 |                 issue = "Thresholds configured appropriately"
403 |             elif spread_threshold <= 0.50 and aggressive_reduction >= 0.50:
    |                                                                       ^^^^ PLR2004
404 |                 status = "warning"
405 |                 success_rate = 0.7
    |

scripts/system_health_checker.py:426:16: BLE001 Do not catch blind exception: `Exception`
    |
424 |             )
425 | 
426 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
427 |             self.logger.error("Failed to check liquidity management health: %s", e)
428 |             return ComponentHealth(
    |

scripts/system_health_checker.py:518:16: BLE001 Do not catch blind exception: `Exception`
    |
516 |             self.logger.info("Health report exported to %s", filepath)
517 | 
518 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
519 |             self.logger.error("Failed to export health report: %s", e)
    |

scripts/system_health_checker.py:528:12: PLW0603 Using the global statement to update `_system_health_checker` is discouraged
    |
526 | def get_system_health_checker() -> SystemHealthChecker:
527 |     """Get or create the global system health checker."""
528 |     global _system_health_checker
    |            ^^^^^^^^^^^^^^^^^^^^^^ PLW0603
529 | 
530 |     if _system_health_checker is None:
    |

scripts/trade_monitor.py:124:44: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
123 |         # Alert if execution rates are too low
124 |         if summary['buy_execution_rate'] < 50 and self.execution_stats['buy_orders_attempted'] >= 5:
    |                                            ^^ PLR2004
125 |             logger.critical("LOW_BUY_EXECUTION_RATE", extra={
126 |                 "rate": summary['buy_execution_rate'],
    |

scripts/trade_monitor.py:124:99: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
123 |         # Alert if execution rates are too low
124 |         if summary['buy_execution_rate'] < 50 and self.execution_stats['buy_orders_attempted'] >= 5:
    |                                                                                                   ^ PLR2004
125 |             logger.critical("LOW_BUY_EXECUTION_RATE", extra={
126 |                 "rate": summary['buy_execution_rate'],
    |

scripts/validate_critical_features.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import subprocess
   | ^^^^^^^^^^^^^^^^^ E402
10 | import sys
11 | from pathlib import Path
   |

scripts/validate_critical_features.py:10:1: E402 Module level import not at top of file
   |
 9 | import subprocess
10 | import sys
   | ^^^^^^^^^^ E402
11 | from pathlib import Path
   |

scripts/validate_critical_features.py:11:1: E402 Module level import not at top of file
   |
 9 | import subprocess
10 | import sys
11 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/validate_critical_features.py:30:12: BLE001 Do not catch blind exception: `Exception`
   |
28 |                 logging.info(f"  Error: {result.stderr.strip()}")
29 |             return False
30 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
31 |         logging.info(f"✗ {description} failed with exception: {e}")
32 |         return False
   |

scripts/validate_critical_fix.py:17:1: E402 Module level import not at top of file
   |
15 | """
16 | 
17 | import os
   | ^^^^^^^^^ E402
18 | import sys
   |

scripts/validate_critical_fix.py:18:1: E402 Module level import not at top of file
   |
17 | import os
18 | import sys
   | ^^^^^^^^^^ E402
19 | 
20 | # Set up test environment
   |

scripts/validate_critical_fix.py:32:1: E402 Module level import not at top of file
   |
31 | # (mocks removed; see tests/mocks/validate_critical_fix_mocks.py)
32 | from ai_trading.trade_execution import ExecutionEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
33 | from tests.mocks.validate_critical_fix_mocks import MockContext, MockOrder
   |

scripts/validate_critical_fix.py:33:1: E402 Module level import not at top of file
   |
31 | # (mocks removed; see tests/mocks/validate_critical_fix_mocks.py)
32 | from ai_trading.trade_execution import ExecutionEngine
33 | from tests.mocks.validate_critical_fix_mocks import MockContext, MockOrder
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/validate_critical_fix.py:83:16: BLE001 Do not catch blind exception: `Exception`
   |
81 |             else:
82 |                 raise
83 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
84 |             logging.info(f"   ⚠️  Other exception (acceptable): {type(e).__name__}")
   |

scripts/validate_critical_fix.py:108:16: BLE001 Do not catch blind exception: `Exception`
    |
106 |             else:
107 |                 raise
108 |         except Exception:
    |                ^^^^^^^^^ BLE001
109 |             logging.info(f"   ✅ {description}: handled gracefully")
    |

scripts/validate_critical_fixes.py:16:1: E402 Module level import not at top of file
   |
14 | """
15 | 
16 | import os
   | ^^^^^^^^^ E402
17 | import sys
18 | import traceback
   |

scripts/validate_critical_fixes.py:17:1: E402 Module level import not at top of file
   |
16 | import os
17 | import sys
   | ^^^^^^^^^^ E402
18 | import traceback
   |

scripts/validate_critical_fixes.py:18:1: E402 Module level import not at top of file
   |
16 | import os
17 | import sys
18 | import traceback
   | ^^^^^^^^^^^^^^^^ E402
19 | 
20 | # Set up minimal environment for testing
   |

scripts/validate_critical_fixes.py:47:12: BLE001 Do not catch blind exception: `Exception`
   |
46 |         return True
47 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
48 |         logging.info(f"  ❌ Sentiment module test failed: {e}")
49 |         traceback.print_exc()
   |

scripts/validate_critical_fixes.py:83:12: BLE001 Do not catch blind exception: `Exception`
   |
82 |         return True
83 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
84 |         logging.info(f"  ❌ MetaLearning strategy test failed: {e}")
85 |         traceback.print_exc()
   |

scripts/validate_critical_fixes.py:114:12: BLE001 Do not catch blind exception: `Exception`
    |
112 |         logging.info("  ✅ Alpaca API endpoints are correctly configured")
113 |         return True
114 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
115 |         logging.info(f"  ❌ Alpaca API test failed: {e}")
116 |         traceback.print_exc()
    |

scripts/validate_critical_fixes.py:133:12: BLE001 Do not catch blind exception: `Exception`
    |
132 |         return True
133 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
134 |         logging.info(f"  ❌ Import resolution test failed: {e}")
135 |         traceback.print_exc()
    |

scripts/validate_enhanced_debugging.py:6:1: E402 Module level import not at top of file
  |
4 | """Simple test to validate enhanced execution debugging functionality."""
5 | 
6 | import os
  | ^^^^^^^^^ E402
7 | import sys
  |

scripts/validate_enhanced_debugging.py:7:1: E402 Module level import not at top of file
  |
6 | import os
7 | import sys
  | ^^^^^^^^^^ E402
8 | 
9 | # Set required environment variables
  |

scripts/validate_enhanced_debugging.py:67:37: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
65 |     positions = reconciler.get_bot_positions()
66 |     logging.info(f"✓ Bot positions: {positions}")
67 |     assert positions.get('MSFT') == 100
   |                                     ^^^ PLR2004
68 | 
69 |     # Test position adjustment
   |

scripts/validate_enhanced_debugging.py:73:37: PLR2004 Magic value used in comparison, consider replacing `150` with a constant variable
   |
71 |     positions = reconciler.get_bot_positions()
72 |     logging.info(f"✓ Adjusted position: {positions}")
73 |     assert positions.get('MSFT') == 150
   |                                     ^^^ PLR2004
74 | 
75 |     # Test reconciliation stats
   |

scripts/validate_enhanced_debugging.py:108:27: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
106 |     events = attributor.get_recent_pnl_events(symbol='GOOGL', limit=5)
107 |     logging.info(f"✓ Recent events count: {len(events)}")
108 |     assert len(events) == 3  # trade, fees, dividend
    |                           ^ PLR2004
109 | 
110 |     # Get statistics
    |

scripts/validate_enhanced_debugging.py:168:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
166 |     pnl_breakdown = attributor.get_pnl_by_symbol(symbol)
167 |     logging.info(f"✓ PnL breakdown: {pnl_breakdown}")
168 |     assert len(pnl_breakdown) >= 2  # Should have position change and fees
    |                                  ^ PLR2004
169 | 
170 |     logging.info("Integration test PASSED\n")
    |

scripts/validate_enhanced_debugging.py:197:12: BLE001 Do not catch blind exception: `Exception`
    |
195 |         return True
196 | 
197 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
198 |         logging.info(f"\nTEST FAILED: {e}")
199 |         import traceback
    |

scripts/validate_enhancements.py:51:12: BLE001 Do not catch blind exception: `Exception`
   |
49 |         return True
50 | 
51 |     except Exception:
   |            ^^^^^^^^^ BLE001
52 |         return False
   |

scripts/validate_enhancements.py:101:12: BLE001 Do not catch blind exception: `Exception`
    |
 99 |         return passed == len(results)
100 | 
101 |     except Exception:
    |            ^^^^^^^^^ BLE001
102 |         return False
    |

scripts/validate_enhancements.py:168:12: BLE001 Do not catch blind exception: `Exception`
    |
166 |         return True
167 | 
168 |     except Exception:
    |            ^^^^^^^^^ BLE001
169 |         import traceback
170 |         traceback.print_exc()
    |

scripts/validate_enhancements.py:192:12: BLE001 Do not catch blind exception: `Exception`
    |
190 |         return True
191 | 
192 |     except Exception:
    |            ^^^^^^^^^ BLE001
193 |         return False
    |

scripts/validate_enhancements.py:210:16: BLE001 Do not catch blind exception: `Exception`
    |
208 |             result = test_func()
209 |             results.append((test_name, result))
210 |         except Exception:
    |                ^^^^^^^^^ BLE001
211 |             results.append((test_name, False))
    |

scripts/validate_final_polish.py:8:1: E402 Module level import not at top of file
  |
6 | """
7 | 
8 | import os
  | ^^^^^^^^^ E402
9 | import tempfile
  |

scripts/validate_final_polish.py:9:1: E402 Module level import not at top of file
  |
8 | import os
9 | import tempfile
  | ^^^^^^^^^^^^^^^ E402
  |

scripts/validate_final_polish.py:21:44: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
19 |         content = f.read()
20 | 
21 |     if len(content.strip().split('\n')) <= 5 and 'from ai_trading.core.bot_engine import *' in content:
   |                                            ^ PLR2004
22 |         logging.info("✓ Bot engine shim is correctly minimal")
23 |     else:
   |

scripts/validate_fixes.py:10:1: E402 Module level import not at top of file
   |
 8 | the actual code changes rather than running complex tests.
 9 | """
10 | import os
   | ^^^^^^^^^ E402
11 | import re
12 | import sys
   |

scripts/validate_fixes.py:11:1: E402 Module level import not at top of file
   |
 9 | """
10 | import os
11 | import re
   | ^^^^^^^^^ E402
12 | import sys
   |

scripts/validate_fixes.py:12:1: E402 Module level import not at top of file
   |
10 | import os
11 | import re
12 | import sys
   | ^^^^^^^^^^ E402
   |

scripts/validate_fixes.py:101:23: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
 99 |             fixes_found += 1
100 | 
101 |     if fixes_found >= 2:
    |                       ^ PLR2004
102 |         logging.info("   ✅ Meta-learning price validation improvements implemented")
103 |         return True
    |

scripts/validate_fixes.py:134:23: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
132 |         fixes_found += 1
133 | 
134 |     if fixes_found >= 2:
    |                       ^ PLR2004
135 |         logging.info("   ✅ Data fetching optimizations implemented")
136 |         return True
    |

scripts/validate_fixes.py:177:23: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
175 |         fixes_found += 1
176 | 
177 |     if fixes_found >= 3:
    |                       ^ PLR2004
178 |         logging.info("   ✅ Circuit breaker error handling enhancements implemented")
179 |         return True
    |

scripts/validate_fixes_root.py:80:12: BLE001 Do not catch blind exception: `Exception`
   |
78 |         return True
79 | 
80 |     except Exception:
   |            ^^^^^^^^^ BLE001
81 |         return False
   |

scripts/validate_fixes_root.py:120:36: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
118 |     ensure_ascii_false_count = content.count('ensure_ascii=False')
119 | 
120 |     if ensure_ascii_false_count >= 2:
    |                                    ^ PLR2004
121 |         return True
122 |     else:
    |

scripts/validate_fixes_root.py:143:16: BLE001 Do not catch blind exception: `Exception`
    |
141 |             if test_func():
142 |                 passed += 1
143 |         except Exception:
    |                ^^^^^^^^^ BLE001
144 |             pass
    |

scripts/validate_improvements.py:8:1: E402 Module level import not at top of file
   |
 6 | """
 7 | 
 8 | import os
   | ^^^^^^^^^ E402
 9 | import subprocess
10 | import sys
   |

scripts/validate_improvements.py:9:1: E402 Module level import not at top of file
   |
 8 | import os
 9 | import subprocess
   | ^^^^^^^^^^^^^^^^^ E402
10 | import sys
   |

scripts/validate_improvements.py:10:1: E402 Module level import not at top of file
   |
 8 | import os
 9 | import subprocess
10 | import sys
   | ^^^^^^^^^^ E402
   |

scripts/validate_improvements.py:29:12: BLE001 Do not catch blind exception: `Exception`
   |
27 |         logging.info("✓ ai_trading imported successfully without Alpaca packages")
28 |         return True
29 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
30 |         logging.info(f"✗ Failed to import ai_trading: {e}")
31 |         return False
   |

scripts/validate_improvements.py:43:12: BLE001 Do not catch blind exception: `Exception`
   |
41 |         logging.info("✓ Package-safe imports working correctly")
42 |         return True
43 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
44 |         logging.info(f"✗ Package import failed: {e}")
45 |         return False
   |

scripts/validate_improvements.py:60:12: BLE001 Do not catch blind exception: `Exception`
   |
58 |         logging.info("✓ Timezone-aware datetime utilities working")
59 |         return True
60 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
61 |         logging.info(f"✗ Timezone utilities failed: {e}")
62 |         return False
   |

scripts/validate_improvements.py:71:12: BLE001 Do not catch blind exception: `Exception`
   |
69 |         logging.info("✓ Idempotency and reconciliation modules available")
70 |         return True
71 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
72 |         logging.info(f"✗ Idempotency/reconciliation modules failed: {e}")
73 |         return False
   |

scripts/validate_improvements.py:126:12: BLE001 Do not catch blind exception: `Exception`
    |
124 |         logging.info("✗ Pytest timed out")
125 |         return False
126 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
127 |         logging.info(f"✗ Pytest check failed: {e}")
128 |         return False
    |

scripts/validate_improvements.py:151:16: BLE001 Do not catch blind exception: `Exception`
    |
149 |             result = test()
150 |             results.append(result)
151 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
152 |             logging.info(f"✗ Test {test.__name__} failed with exception: {e}\n")
153 |             results.append(False)
    |

scripts/validate_migration.py:25:12: BLE001 Do not catch blind exception: `Exception`
   |
23 |     except SyntaxError as e:
24 |         return False, f"Syntax error: {e}"
25 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
26 |         return False, f"Error: {e}"
   |

scripts/validate_migration.py:41:12: BLE001 Do not catch blind exception: `Exception`
   |
39 |                     imports.append(f"from {module} import {alias.name}")
40 |         return imports
41 |     except Exception:
   |            ^^^^^^^^^ BLE001
42 |         return []
   |

scripts/validate_migration.py:44:5: PLR0911 Too many return statements (7 > 6)
   |
42 |         return []
43 | 
44 | def main():
   |     ^^^^ PLR0911
45 |     """Run migration validation."""
   |

scripts/validate_peak_performance.py:8:1: E402 Module level import not at top of file
  |
6 | """
7 | 
8 | import sys
  | ^^^^^^^^^^ E402
9 | from pathlib import Path
  |

scripts/validate_peak_performance.py:9:1: E402 Module level import not at top of file
   |
 8 | import sys
 9 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
10 | 
11 | # Add current directory to path for imports
   |

scripts/validate_peak_performance.py:38:16: BLE001 Do not catch blind exception: `Exception`
   |
36 |             imported.append(module)
37 |             logging.info(f"  ✓ {module}")
38 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
39 |             failed.append((module, str(e)))
40 |             logging.info(f"  ✗ {module}: {e}")
   |

scripts/validate_peak_performance.py:61:12: BLE001 Do not catch blind exception: `Exception`
   |
59 |         logging.info("  ✓ Idempotency system working")
60 | 
61 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
62 |         logging.info(f"  ✗ Idempotency test failed: {e}")
63 |         return False
   |

scripts/validate_peak_performance.py:80:12: BLE001 Do not catch blind exception: `Exception`
   |
78 |         logging.info("  ✓ Cost model working")
79 | 
80 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
81 |         logging.info(f"  ✗ Cost model test failed: {e}")
82 |         return False
   |

scripts/validate_peak_performance.py:86:1: I001 [*] Import block is un-sorted or un-formatted
   |
84 |       try:
85 |           # Test determinism
86 | /         import numpy as np
87 | | 
88 | |         from ai_trading.utils.determinism import set_random_seeds
89 | | 
   | |_^ I001
90 |           set_random_seeds(42)
91 |           random1 = np.random.random(5)
   |
   = help: Organize imports

scripts/validate_peak_performance.py:99:12: BLE001 Do not catch blind exception: `Exception`
    |
 97 |         logging.info("  ✓ Determinism working")
 98 | 
 99 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
100 |         logging.info(f"  ✗ Determinism test failed: {e}")
101 |         return False
    |

scripts/validate_peak_performance.py:112:12: BLE001 Do not catch blind exception: `Exception`
    |
110 |         logging.info("  ✓ Performance cache working")
111 | 
112 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
113 |         logging.info(f"  ✗ Performance cache test failed: {e}")
114 |         return False
    |

scripts/validate_peak_performance.py:155:12: BLE001 Do not catch blind exception: `Exception`
    |
153 |         return True
154 | 
155 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
156 |         logging.info(f"  ✗ Integration test failed: {e}")
157 |         return False
    |

scripts/validate_problem_statement_fixes.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import os
   | ^^^^^^^^^ E402
10 | import re
11 | import sys
   |

scripts/validate_problem_statement_fixes.py:10:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import re
   | ^^^^^^^^^ E402
11 | import sys
   |

scripts/validate_problem_statement_fixes.py:11:1: E402 Module level import not at top of file
   |
 9 | import os
10 | import re
11 | import sys
   | ^^^^^^^^^^ E402
12 | 
13 | # Set up minimal environment
   |

scripts/validate_problem_statement_fixes.py:55:12: BLE001 Do not catch blind exception: `Exception`
   |
53 |         return actual_failures == expected_failures and actual_recovery == expected_recovery
54 | 
55 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
56 |         logging.info(f"Error validating sentiment circuit breaker: {e}")
57 |         return False
   |

scripts/validate_problem_statement_fixes.py:81:12: BLE001 Do not catch blind exception: `Exception`
   |
79 |             return False
80 | 
81 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
82 |         logging.info(f"Error validating meta-learning: {e}")
83 |         return False
   |

scripts/validate_problem_statement_fixes.py:102:12: BLE001 Do not catch blind exception: `Exception`
    |
100 |             return False
101 | 
102 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
103 |         logging.info(f"Error validating PLTR sector: {e}")
104 |         return False
    |

scripts/validate_problem_statement_fixes.py:132:12: BLE001 Do not catch blind exception: `Exception`
    |
130 |         return all_implemented
131 | 
132 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
133 |         logging.info(f"Error validating execution optimizations: {e}")
134 |         return False
    |

scripts/validate_problem_statement_fixes.py:161:12: BLE001 Do not catch blind exception: `Exception`
    |
159 |         return all_implemented
160 | 
161 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
162 |         logging.info(f"Error validating quantity tracking: {e}")
163 |         return False
    |

scripts/validate_production_fixes.py:11:1: E402 Module level import not at top of file
   |
 9 | """
10 | 
11 | import os
   | ^^^^^^^^^ E402
12 | import sys
13 | from datetime import datetime
   |

scripts/validate_production_fixes.py:12:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
   | ^^^^^^^^^^ E402
13 | from datetime import datetime
   |

scripts/validate_production_fixes.py:13:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
13 | from datetime import datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/validate_production_fixes.py:52:12: BLE001 Do not catch blind exception: `Exception`
   |
50 |             logging.info("❌ Sentiment API variables missing from config.py")
51 |             return False
52 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
53 |         logging.info(f"❌ Error checking config.py: {e}")
54 |         return False
   |

scripts/validate_production_fixes.py:79:16: BLE001 Do not catch blind exception: `Exception`
   |
77 |             count = monitor._count_trading_bot_processes()
78 |             logging.info(f"✅ Process detection works, found {count} trading bot processes")
79 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
80 |             logging.info(f"⚠️  Process detection method exists but failed to run: {e}")
81 |             # This is not a failure in test environment
   |

scripts/validate_production_fixes.py:91:45: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
89 |         if process_alerts:
90 |             alert = process_alerts[0]
91 |             if alert.get('threshold', 1) == 2:
   |                                             ^ PLR2004
92 |                 logging.info("✅ Alert threshold correctly set to 2 (allowing main + backup)")
93 |             else:
   |

scripts/validate_production_fixes.py:131:12: BLE001 Do not catch blind exception: `Exception`
    |
129 |         return True
130 | 
131 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
132 |         logging.info(f"❌ Error validating data staleness: {e}")
133 |         return False
    |

scripts/validate_production_fixes.py:203:12: BLE001 Do not catch blind exception: `Exception`
    |
201 |         return True
202 | 
203 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
204 |         logging.info(f"❌ Backwards compatibility check failed: {e}")
205 |         return False
    |

scripts/validate_production_fixes.py:232:16: BLE001 Do not catch blind exception: `Exception`
    |
230 |             else:
231 |                 logging.info(f"❌ {test_name} validation failed")
232 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
233 |             logging.info(f"❌ {test_name} validation error: {e}")
    |

scripts/validate_profit_critical.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import sys
   | ^^^^^^^^^^ E402
10 | from pathlib import Path
   |

scripts/validate_profit_critical.py:10:1: E402 Module level import not at top of file
   |
 9 | import sys
10 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
11 | 
12 | # Add the repo root to path to import modules directly
   |

scripts/validate_profit_critical.py:116:16: BLE001 Do not catch blind exception: `Exception`
    |
114 |             result = test()
115 |             results.append(result)
116 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
117 |             logging.info(f"✗ Test {test.__name__} failed: {e}")
118 |             results.append(False)
    |

scripts/validate_runtime_hardening.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import pathlib
   | ^^^^^^^^^^^^^^ E402
10 | import re
11 | import sys
   |

scripts/validate_runtime_hardening.py:10:1: E402 Module level import not at top of file
   |
 9 | import pathlib
10 | import re
   | ^^^^^^^^^ E402
11 | import sys
12 | from datetime import UTC
   |

scripts/validate_runtime_hardening.py:11:1: E402 Module level import not at top of file
   |
 9 | import pathlib
10 | import re
11 | import sys
   | ^^^^^^^^^^ E402
12 | from datetime import UTC
   |

scripts/validate_runtime_hardening.py:12:1: E402 Module level import not at top of file
   |
10 | import re
11 | import sys
12 | from datetime import UTC
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/validate_runtime_hardening.py:162:16: BLE001 Do not catch blind exception: `Exception`
    |
160 |             else:
161 |                 failed += 1
162 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
163 |             logging.info(f"✗ {test.__name__} failed with error: {e}")
164 |             failed += 1
    |

scripts/validate_standalone.py:9:1: E402 Module level import not at top of file
   |
 7 | """
 8 | 
 9 | import hashlib
   | ^^^^^^^^^^^^^^ E402
10 | import json
11 | import os
   |

scripts/validate_standalone.py:10:1: E402 Module level import not at top of file
   |
 9 | import hashlib
10 | import json
   | ^^^^^^^^^^^ E402
11 | import os
12 | import sys
   |

scripts/validate_standalone.py:11:1: E402 Module level import not at top of file
   |
 9 | import hashlib
10 | import json
11 | import os
   | ^^^^^^^^^ E402
12 | import sys
13 | from dataclasses import dataclass
   |

scripts/validate_standalone.py:12:1: E402 Module level import not at top of file
   |
10 | import json
11 | import os
12 | import sys
   | ^^^^^^^^^^ E402
13 | from dataclasses import dataclass
14 | from datetime import UTC, datetime
   |

scripts/validate_standalone.py:13:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
13 | from dataclasses import dataclass
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
14 | from datetime import UTC, datetime
15 | from enum import Enum
   |

scripts/validate_standalone.py:14:1: E402 Module level import not at top of file
   |
12 | import sys
13 | from dataclasses import dataclass
14 | from datetime import UTC, datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
15 | from enum import Enum
16 | from pathlib import Path
   |

scripts/validate_standalone.py:15:1: E402 Module level import not at top of file
   |
13 | from dataclasses import dataclass
14 | from datetime import UTC, datetime
15 | from enum import Enum
   | ^^^^^^^^^^^^^^^^^^^^^ E402
16 | from pathlib import Path
   |

scripts/validate_standalone.py:16:1: E402 Module level import not at top of file
   |
14 | from datetime import UTC, datetime
15 | from enum import Enum
16 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
17 | 
18 | # Set dummy environment variables to avoid config issues
   |

scripts/validate_standalone.py:161:39: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
159 |     slippage = costs.slippage_cost_bps(volume_ratio=2.0)
160 |     expected = 1.5 * math.sqrt(2.0)
161 |     assert abs(slippage - expected) < 0.01
    |                                       ^^^^ PLR2004
162 | 
163 |     # Test total cost
    |

scripts/validate_standalone.py:166:47: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
164 |     total_cost = costs.total_execution_cost_bps(volume_ratio=1.5)
165 |     expected_total = (2.0 * 2) + 0.5 + (1.5 * math.sqrt(1.5))
166 |     assert abs(total_cost - expected_total) < 0.01
    |                                               ^^^^ PLR2004
167 | 
168 |     logging.info("  ✓ Cost model calculations working")
    |

scripts/validate_standalone.py:287:20: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
286 |     # Determine drift level
287 |     if psi_score < 0.1:
    |                    ^^^ PLR2004
288 |         drift_level = "low"
289 |     elif psi_score < 0.2:
    |

scripts/validate_standalone.py:289:22: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
287 |     if psi_score < 0.1:
288 |         drift_level = "low"
289 |     elif psi_score < 0.2:
    |                      ^^^ PLR2004
290 |         drift_level = "medium"
291 |     else:
    |

scripts/validate_standalone.py:307:35: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
305 |     )
306 | 
307 |     assert metrics.sample_size == 500
    |                                   ^^^ PLR2004
308 |     assert metrics.drift_level in ["low", "medium", "high"]
    |

scripts/validate_standalone.py:472:16: BLE001 Do not catch blind exception: `Exception`
    |
470 |             test()
471 |             passed += 1
472 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
473 |             logging.info(f"  ✗ {test.__name__} failed: {e}")
474 |             failed += 1
    |

scripts/validate_startup_fixes.py:17:1: E402 Module level import not at top of file
   |
15 | """
16 | 
17 | import os
   | ^^^^^^^^^ E402
18 | import sys
19 | import tempfile
   |

scripts/validate_startup_fixes.py:18:1: E402 Module level import not at top of file
   |
17 | import os
18 | import sys
   | ^^^^^^^^^^ E402
19 | import tempfile
20 | import traceback
   |

scripts/validate_startup_fixes.py:19:1: E402 Module level import not at top of file
   |
17 | import os
18 | import sys
19 | import tempfile
   | ^^^^^^^^^^^^^^^ E402
20 | import traceback
21 | from datetime import UTC, datetime
   |

scripts/validate_startup_fixes.py:20:1: E402 Module level import not at top of file
   |
18 | import sys
19 | import tempfile
20 | import traceback
   | ^^^^^^^^^^^^^^^^ E402
21 | from datetime import UTC, datetime
   |

scripts/validate_startup_fixes.py:21:1: E402 Module level import not at top of file
   |
19 | import tempfile
20 | import traceback
21 | from datetime import UTC, datetime
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

scripts/validate_startup_fixes.py:33:32: F401 `ai_trading.runner` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
32 |     try:
33 |         from ai_trading import runner
   |                                ^^^^^^ F401
34 |         from ai_trading.config.management import _resolve_alpaca_env
35 |         logging.info("   ✓ Core modules imported without credentials")
   |
   = help: Remove unused import: `ai_trading.runner`

scripts/validate_startup_fixes.py:34:50: F401 `ai_trading.config.management._resolve_alpaca_env` imported but unused; consider using `importlib.util.find_spec` to test for availability
   |
32 |     try:
33 |         from ai_trading import runner
34 |         from ai_trading.config.management import _resolve_alpaca_env
   |                                                  ^^^^^^^^^^^^^^^^^^^ F401
35 |         logging.info("   ✓ Core modules imported without credentials")
36 |         logging.info("   ✓ No sys.exit() calls during import")
   |
   = help: Remove unused import: `ai_trading.config.management._resolve_alpaca_env`

scripts/validate_startup_fixes.py:45:12: BLE001 Do not catch blind exception: `Exception`
   |
43 |         logging.info("   ✓ No sys.exit() crashes - this is good!")
44 |         return True
45 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
46 |         logging.info(f"   ✗ Unexpected error: {e}")
47 |         return False
   |

scripts/validate_startup_fixes.py:215:12: BLE001 Do not catch blind exception: `Exception`
    |
213 |             return False
214 | 
215 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
216 |         logging.info(f"   ✗ Redacted logging test failed: {e}")
217 |         return False
    |

scripts/validate_startup_fixes.py:239:16: BLE001 Do not catch blind exception: `Exception`
    |
237 |             result = test()
238 |             results.append(result)
239 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
240 |             logging.info(f"   ✗ Test failed with exception: {e}")
241 |             traceback.print_exc()
    |

scripts/validate_unified_config.py:15:1: E402 Module level import not at top of file
   |
13 | """
14 | 
15 | import os
   | ^^^^^^^^^ E402
16 | import sys
   |

scripts/validate_unified_config.py:16:1: E402 Module level import not at top of file
   |
15 | import os
16 | import sys
   | ^^^^^^^^^^ E402
17 | 
18 | sys.path.append('.')
   |

scripts/validate_unified_config.py:66:30: PLR2004 Magic value used in comparison, consider replacing `15.75` with a constant variable
   |
64 |     m2 = Money("5.25")
65 | 
66 |     assert float(m1 + m2) == 15.75, "Money addition failed"
   |                              ^^^^^ PLR2004
67 |     assert float(m1 - m2) == 5.25, "Money subtraction failed"
68 |     assert float(m1 * 2) == 21.0, "Money multiplication failed"
   |

scripts/validate_unified_config.py:67:30: PLR2004 Magic value used in comparison, consider replacing `5.25` with a constant variable
   |
66 |     assert float(m1 + m2) == 15.75, "Money addition failed"
67 |     assert float(m1 - m2) == 5.25, "Money subtraction failed"
   |                              ^^^^ PLR2004
68 |     assert float(m1 * 2) == 21.0, "Money multiplication failed"
69 |     logging.info("✓ Money arithmetic works")
   |

scripts/validate_unified_config.py:68:29: PLR2004 Magic value used in comparison, consider replacing `21.0` with a constant variable
   |
66 |     assert float(m1 + m2) == 15.75, "Money addition failed"
67 |     assert float(m1 - m2) == 5.25, "Money subtraction failed"
68 |     assert float(m1 * 2) == 21.0, "Money multiplication failed"
   |                             ^^^^ PLR2004
69 |     logging.info("✓ Money arithmetic works")
   |

scripts/validate_unified_config.py:74:28: PLR2004 Magic value used in comparison, consider replacing `15.57` with a constant variable
   |
72 |     tick_size = Decimal('0.01')
73 |     price = round_to_tick('15.567', tick_size)
74 |     assert float(price) == 15.57, f"Expected 15.57, got {float(price)}"
   |                            ^^^^^ PLR2004
75 |     logging.info("✓ Price quantization works")
   |

scripts/validate_unified_config.py:79:23: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
77 |     # Test lot rounding
78 |     lot_qty = round_to_lot(157.8, 100)
79 |     assert lot_qty == 200, f"Expected 200, got {lot_qty}"
   |                       ^^^ PLR2004
80 |     logging.info("✓ Lot quantization works")
   |

scripts/validate_unified_config.py:164:12: BLE001 Do not catch blind exception: `Exception`
    |
162 |     try:
163 |         logging.info("✓ ai_trading import works")
164 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
165 |         logging.info(f"✗ ai_trading import failed: {e}")
166 |         return False
    |

scripts/validate_unified_config.py:170:12: BLE001 Do not catch blind exception: `Exception`
    |
168 |     try:
169 |         logging.info("✓ settings_singleton import works")
170 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
171 |         logging.info(f"✗ settings_singleton import failed: {e}")
172 |         return False
    |

scripts/validate_unified_config.py:176:12: BLE001 Do not catch blind exception: `Exception`
    |
174 |     try:
175 |         logging.info("✓ Money class import works")
176 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
177 |         logging.info(f"✗ Money class import failed: {e}")
178 |         return False
    |

scripts/validate_unified_config.py:182:12: BLE001 Do not catch blind exception: `Exception`
    |
180 |     try:
181 |         logging.info("✓ rate_limit import works")
182 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
183 |         logging.info(f"✗ rate_limit import failed: {e}")
184 |         return False
    |

scripts/validate_unified_config.py:211:12: BLE001 Do not catch blind exception: `Exception`
    |
209 |         return True
210 | 
211 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
212 |         logging.info(f"❌ VALIDATION FAILED: {e}")
213 |         import traceback
    |

scripts/verify_config.py:11:1: E402 Module level import not at top of file
   |
 9 | """
10 | 
11 | import os
   | ^^^^^^^^^ E402
12 | import sys
13 | from pathlib import Path
   |

scripts/verify_config.py:12:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
   | ^^^^^^^^^^ E402
13 | from pathlib import Path
   |

scripts/verify_config.py:13:1: E402 Module level import not at top of file
   |
11 | import os
12 | import sys
13 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
14 | 
15 | from ai_trading.config import management as config
   |

scripts/verify_config.py:15:1: E402 Module level import not at top of file
   |
13 | from pathlib import Path
14 | 
15 | from ai_trading.config import management as config
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
16 | from ai_trading.config.management import TradingConfig
   |

scripts/verify_config.py:16:1: E402 Module level import not at top of file
   |
15 | from ai_trading.config import management as config
16 | from ai_trading.config.management import TradingConfig
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
17 | 
18 | CONFIG = TradingConfig()
   |

scripts/verify_config.py:59:12: BLE001 Do not catch blind exception: `Exception`
   |
57 |     except ImportError:
58 |         return False, "❌ python-dotenv not installed. Run: pip install python-dotenv"
59 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
60 |         return False, f"❌ Error reading .env file: {e}"
   |

scripts/verify_config.py:81:29: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
79 |         elif api_key.startswith('YOUR_'):
80 |             issues.append("ALPACA_API_KEY still contains placeholder text")
81 |         elif len(api_key) < 20:
   |                             ^^ PLR2004
82 |             issues.append("ALPACA_API_KEY appears too short")
   |

scripts/verify_config.py:89:32: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
87 |         elif secret_key.startswith('YOUR_'):
88 |             issues.append("ALPACA_SECRET_KEY still contains placeholder text")
89 |         elif len(secret_key) < 30:
   |                                ^^ PLR2004
90 |             issues.append("ALPACA_SECRET_KEY appears too short")
   |

scripts/verify_config.py:109:12: BLE001 Do not catch blind exception: `Exception`
    |
107 |     except ImportError:
108 |         return False, "❌ python-dotenv not installed. Run: pip install python-dotenv"
109 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
110 |         return False, f"❌ Error checking API keys: {e}"
    |

scripts/verify_config.py:128:12: BLE001 Do not catch blind exception: `Exception`
    |
126 |             return False, "⚠️  Configuration imports but API keys not properly set"
127 | 
128 |     except Exception as e:
    |            ^^^^^^^^^ BLE001
129 |         return False, f"❌ Error importing config: {e}"
    |

tests/allocators/test_confidence_gate_env.py:15:49: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
   |
13 |     w1 = alloc.score_to_weight(score=0.69)
14 |     assert w1 == 0.0
15 |     assert any(getattr(r, "threshold", None) == 0.7 for r in caplog.records)
   |                                                 ^^^ PLR2004
16 |     caplog.clear()
17 |     alloc.score_to_weight(score=0.5)
   |

tests/allocators/test_confidence_gate_env.py:18:53: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
   |
16 |     caplog.clear()
17 |     alloc.score_to_weight(score=0.5)
18 |     assert not any(getattr(r, "threshold", None) == 0.7 for r in caplog.records)
   |                                                     ^^^ PLR2004
   |

tests/conftest.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime as dt
 2 | | import os
 3 | | import sys
 4 | | import types
 5 | | 
 6 | | import pytest
 7 | | 
 8 | | from ai_trading.utils.optional_import import optional_import
 9 | | 
10 | | 
11 | | def _has(mod: str) -> bool:
   | |_^ I001
12 |       return optional_import(mod) is not None
   |
   = help: Organize imports

tests/conftest.py:53:8: BLE001 Do not catch blind exception: `Exception`
   |
51 | try:
52 |     from dotenv import load_dotenv
53 | except Exception:
   |        ^^^^^^^^^ BLE001
54 |     def load_dotenv(*a, **k):
55 |         pass
   |

tests/conftest.py:65:8: BLE001 Do not catch blind exception: `Exception`
   |
63 | try:
64 |     from hypothesis import HealthCheck, given, settings
65 | except Exception:
   |        ^^^^^^^^^ BLE001
66 |     import types
   |

tests/conftest.py:118:8: BLE001 Do not catch blind exception: `Exception`
    |
116 | try:
117 |     pass
118 | except Exception:
    |        ^^^^^^^^^ BLE001
119 |     import types
120 |     class LockStub:
    |

tests/conftest.py:138:8: BLE001 Do not catch blind exception: `Exception`
    |
136 | try:
137 |     pass
138 | except Exception:
    |        ^^^^^^^^^ BLE001
139 |     import types
140 |     class ScheduleStub:
    |

tests/conftest.py:157:8: BLE001 Do not catch blind exception: `Exception`
    |
155 | try:
156 |     pass
157 | except Exception:
    |        ^^^^^^^^^ BLE001
158 |     import types
    |

tests/conftest.py:205:8: BLE001 Do not catch blind exception: `Exception`
    |
203 | try:
204 |     pass
205 | except Exception:
    |        ^^^^^^^^^ BLE001
206 |     import types
207 |     hmmlearn_mod = types.ModuleType("hmmlearn")
    |

tests/conftest.py:227:8: BLE001 Do not catch blind exception: `Exception`
    |
225 | try:
226 |     pass
227 | except Exception:
    |        ^^^^^^^^^ BLE001
228 |     import types
    |

tests/conftest.py:251:8: BLE001 Do not catch blind exception: `Exception`
    |
249 | try:
250 |     pass
251 | except Exception:
    |        ^^^^^^^^^ BLE001
252 |     import types
    |

tests/conftest.py:346:8: BLE001 Do not catch blind exception: `Exception`
    |
344 |         wait_exponential,
345 |     )
346 | except Exception:
    |        ^^^^^^^^^ BLE001
347 |     import types
    |

tests/conftest.py:397:1: E402 Module level import not at top of file
    |
396 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
397 | import types
    | ^^^^^^^^^^^^ E402
398 | from datetime import UTC
399 | from pathlib import Path
    |

tests/conftest.py:398:1: E402 Module level import not at top of file
    |
396 | sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
397 | import types
398 | from datetime import UTC
    | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
399 | from pathlib import Path
    |

tests/conftest.py:399:1: E402 Module level import not at top of file
    |
397 | import types
398 | from datetime import UTC
399 | from pathlib import Path
    | ^^^^^^^^^^^^^^^^^^^^^^^^ E402
400 | 
401 | import pytest
    |

tests/conftest.py:401:1: E402 Module level import not at top of file
    |
399 | from pathlib import Path
400 | 
401 | import pytest
    | ^^^^^^^^^^^^^ E402
402 | 
403 | # AI-AGENT-REF: Add numpy stub before any imports that might need it
    |

tests/conftest.py:406:8: BLE001 Do not catch blind exception: `Exception`
    |
404 | try:
405 |     pass
406 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
407 |     import types
    |

tests/conftest.py:509:8: BLE001 Do not catch blind exception: `Exception`
    |
507 | try:
508 |     import urllib3
509 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
510 |     import types
511 |     urllib3 = types.ModuleType("urllib3")
    |

tests/conftest.py:518:8: BLE001 Do not catch blind exception: `Exception`
    |
516 | try:
517 |     pass
518 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
519 |     import types
    |

tests/conftest.py:659:44: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
657 |                     # For testing mean reversion, return a series where the last value
658 |                     # creates a high z-score when compared to the moving average
659 |                     if len(self.series) >= 2:
    |                                            ^ PLR2004
660 |                         # Create a mock rolling mean that will give us the expected z-score
661 |                         # For test data [1, 1, 1, 1, 5], we want the last value to have high z-score
    |

tests/conftest.py:675:44: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
673 |                 def std(self, ddof=0):
674 |                     # For z-score calculation, return std that will give us expected result
675 |                     if len(self.series) >= 2:
    |                                            ^ PLR2004
676 |                         result = []
677 |                         for i in range(len(self.series)):
    |

tests/conftest.py:731:43: F823 Local variable `dt` referenced before assignment
    |
729 |                     self.value = str(args[0])
730 |             else:
731 |                 self.value = datetime.now(dt.UTC).isoformat()
    |                                           ^^ F823
732 | 
733 |             # Handle timezone parameter
    |

tests/conftest.py:866:8: BLE001 Do not catch blind exception: `Exception`
    |
864 | try:
865 |     pass  # ensure real package available
866 | except Exception:  # pragma: no cover - allow missing in test env
    |        ^^^^^^^^^ BLE001
867 |     req_mod = types.ModuleType("requests")
868 |     exc_mod = types.ModuleType("requests.exceptions")
    |

tests/conftest.py:879:8: BLE001 Do not catch blind exception: `Exception`
    |
877 | try:
878 |     pass
879 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
880 |     import types
881 |     ta_mod = types.ModuleType("pandas_ta")
    |

tests/conftest.py:897:8: BLE001 Do not catch blind exception: `Exception`
    |
895 | try:
896 |     pass
897 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
898 |     import types
    |

tests/conftest.py:913:8: BLE001 Do not catch blind exception: `Exception`
    |
911 | try:
912 |     pass
913 | except Exception:  # pragma: no cover - optional dependency
    |        ^^^^^^^^^ BLE001
914 |     import types
    |

tests/conftest.py:1003:16: PLW0603 Using the global statement to update `_settings_instance` is discouraged
     |
1001 |     _settings_instance = None
1002 |     def get_settings():
1003 |         global _settings_instance
     |                ^^^^^^^^^^^^^^^^^^ PLW0603
1004 |         if _settings_instance is None:
1005 |             _settings_instance = BaseSettingsStub()
     |

tests/conftest.py:1014:8: BLE001 Do not catch blind exception: `Exception`
     |
1012 | try:
1013 |     pass
1014 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1015 |     import types
     |

tests/conftest.py:1046:8: BLE001 Do not catch blind exception: `Exception`
     |
1044 | try:
1045 |     pass
1046 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1047 |     import types
     |

tests/conftest.py:1072:8: BLE001 Do not catch blind exception: `Exception`
     |
1070 | try:
1071 |     from alpaca.common.exceptions import APIError
1072 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1073 |     import types
1074 |     from enum import Enum
     |

tests/conftest.py:1257:8: BLE001 Do not catch blind exception: `Exception`
     |
1255 | try:
1256 |     pass
1257 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1258 |     import types
1259 |     psutil_mod = types.ModuleType("psutil")
     |

tests/conftest.py:1265:8: BLE001 Do not catch blind exception: `Exception`
     |
1263 | try:
1264 |     pass
1265 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1266 |     import types
1267 |     tzlocal_mod = types.ModuleType("tzlocal")
     |

tests/conftest.py:1275:8: BLE001 Do not catch blind exception: `Exception`
     |
1273 | try:
1274 |     from bs4 import BeautifulSoup
1275 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1276 |     import types
     |

tests/conftest.py:1299:8: BLE001 Do not catch blind exception: `Exception`
     |
1297 | try:
1298 |     from flask import Flask
1299 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1300 |     import types
     |

tests/conftest.py:1327:8: BLE001 Do not catch blind exception: `Exception`
     |
1325 | try:
1326 |     from ratelimit import limits, sleep_and_retry
1327 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1328 |     import types
     |

tests/conftest.py:1347:8: BLE001 Do not catch blind exception: `Exception`
     |
1345 | try:
1346 |     pass
1347 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1348 |     import types
     |

tests/conftest.py:1371:8: BLE001 Do not catch blind exception: `Exception`
     |
1369 | try:
1370 |     from prometheus_client import Counter, Gauge, Histogram, start_http_server
1371 | except Exception:  # pragma: no cover - optional dependency
     |        ^^^^^^^^^ BLE001
1372 |     import types
     |

tests/conftest.py:1446:1: E402 Module level import not at top of file
     |
1446 | import importlib
     | ^^^^^^^^^^^^^^^^ E402
1447 | import types
     |

tests/conftest.py:1447:1: E402 Module level import not at top of file
     |
1446 | import importlib
1447 | import types
     | ^^^^^^^^^^^^ E402
     |

tests/conftest.py:1474:40: F821 Undefined name `MockTradingConfig`
     |
1472 |             # Set the attribute on the config module instance, not the class
1473 |             if hasattr(config, '__dict__'):
1474 |                 config.TradingConfig = MockTradingConfig
     |                                        ^^^^^^^^^^^^^^^^^ F821
1475 |             else:
1476 |                 # If config is an instance, set it as an attribute
     |

tests/conftest.py:1477:40: F821 Undefined name `MockTradingConfig`
     |
1475 |             else:
1476 |                 # If config is an instance, set it as an attribute
1477 |                 config.TradingConfig = MockTradingConfig
     |                                        ^^^^^^^^^^^^^^^^^ F821
1478 |     except ImportError as e:
1479 |         # AI-AGENT-REF: Log config import failure for debugging
     |

tests/conftest.py:1510:12: BLE001 Do not catch blind exception: `Exception`
     |
1508 |         logger.debug(f"Could not import bot_engine for mocking: {e}")
1509 |         pass
1510 |     except Exception:
     |            ^^^^^^^^^ BLE001
1511 |         # If bot_engine import fails due to config issues, skip it for now
1512 |         pass
     |

tests/conftest.py:1600:1: E402 Module level import not at top of file
     |
1599 | # AI-AGENT-REF: provide minimal 'config' stub for tests
1600 | import os as _os
     | ^^^^^^^^^^^^^^^^ E402
1601 | import sys as _sys
1602 | import types as _types
     |

tests/conftest.py:1601:1: E402 Module level import not at top of file
     |
1599 | # AI-AGENT-REF: provide minimal 'config' stub for tests
1600 | import os as _os
1601 | import sys as _sys
     | ^^^^^^^^^^^^^^^^^^ E402
1602 | import types as _types
     |

tests/conftest.py:1602:1: E402 Module level import not at top of file
     |
1600 | import os as _os
1601 | import sys as _sys
1602 | import types as _types
     | ^^^^^^^^^^^^^^^^^^^^^^ E402
     |

tests/conftest.py:1638:8: BLE001 Do not catch blind exception: `Exception`
     |
1636 | try:
1637 |     from pydantic import AliasChoices as _AliasChoices  # noqa: F401
1638 | except Exception:
     |        ^^^^^^^^^ BLE001
1639 |     import pydantic as _pydantic
     |

tests/conftest.py:1648:8: BLE001 Do not catch blind exception: `Exception`
     |
1646 | try:
1647 |     from pydantic import model_validator as _model_validator  # noqa: F401
1648 | except Exception:
     |        ^^^^^^^^^ BLE001
1649 |     import pydantic as _pydantic
     |

tests/conftest.py:1662:8: BLE001 Do not catch blind exception: `Exception`
     |
1660 | try:
1661 |     import pydantic_settings as _pydantic_settings
1662 | except Exception:
     |        ^^^^^^^^^ BLE001
1663 |     import types as _types2
1664 |     _pydantic_settings = _types2.ModuleType("pydantic_settings")
     |

tests/data_fetcher/test_datetime_narrow_exceptions.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | import pytest
3 | | 
4 | | from ai_trading.data_fetcher import ensure_datetime
5 | | 
6 | | 
7 | | def test_dt_invalid_raises_typeerror():
  | |_^ I001
8 |       with pytest.raises(TypeError):
9 |           ensure_datetime(object())
  |
  = help: Organize imports

tests/execution/test_fetch_minute_df_safe_empty.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | import pytest
3 | | 
4 | | from ai_trading.core.bot_engine import DataFetchError, fetch_minute_df_safe
5 | | 
6 | | 
7 | | def test_empty_minute_raises(monkeypatch):
  | |_^ I001
8 |       """fetch_minute_df_safe should raise when providers return empty data."""
9 |       monkeypatch.setattr(
  |
  = help: Organize imports

tests/institutional/__init__.py:9:5: PLC0414 Import alias does not rename original package
   |
 8 | from .framework import (
 9 |     ComplianceTestSuite as ComplianceTestSuite,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
10 | )
11 | from .framework import (
   |
   = help: Remove import alias

tests/institutional/__init__.py:12:5: PLC0414 Import alias does not rename original package
   |
10 | )
11 | from .framework import (
12 |     MockMarketDataProvider as MockMarketDataProvider,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
13 | )
14 | from .framework import (
   |
   = help: Remove import alias

tests/institutional/__init__.py:15:5: PLC0414 Import alias does not rename original package
   |
13 | )
14 | from .framework import (
15 |     TradingScenarioRunner as TradingScenarioRunner,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PLC0414
16 | )
   |
   = help: Remove import alias

tests/institutional/framework.py:99:20: BLE001 Do not catch blind exception: `Exception`
    |
 97 |                     logger.error(f"❌ {scenario_name} failed: {scenario_result.get('error', 'Unknown error')}")
 98 | 
 99 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
100 |                 logger.error(f"❌ {scenario_name} failed with exception: {e}")
101 |                 results["scenarios"].append({
    |

tests/institutional/framework.py:145:20: BLE001 Do not catch blind exception: `Exception`
    |
143 |                     passed += 1
144 | 
145 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
146 |                 results["scenarios"].append({
147 |                     "name": scenario_name,
    |

tests/institutional/framework.py:198:56: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
196 |         # Determine pass/fail based on thresholds
197 |         performance_ok = (
198 |             results["metrics"]["average_latency_ms"] < 100 and
    |                                                        ^^^ PLR2004
199 |             results["metrics"]["orders_per_second"] > 50 and
200 |             results["metrics"]["memory_usage_mb"] < 100
    |

tests/institutional/framework.py:199:55: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
    |
197 |         performance_ok = (
198 |             results["metrics"]["average_latency_ms"] < 100 and
199 |             results["metrics"]["orders_per_second"] > 50 and
    |                                                       ^^ PLR2004
200 |             results["metrics"]["memory_usage_mb"] < 100
201 |         )
    |

tests/institutional/framework.py:200:53: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
198 |             results["metrics"]["average_latency_ms"] < 100 and
199 |             results["metrics"]["orders_per_second"] > 50 and
200 |             results["metrics"]["memory_usage_mb"] < 100
    |                                                     ^^^ PLR2004
201 |         )
    |

tests/institutional/framework.py:233:16: BLE001 Do not catch blind exception: `Exception`
    |
231 |                 "order_id": result.get("id") if result else None
232 |             }
233 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
234 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:251:16: BLE001 Do not catch blind exception: `Exception`
    |
249 |                 "order_id": result.get("id") if result else None
250 |             }
251 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
252 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:273:16: BLE001 Do not catch blind exception: `Exception`
    |
271 |                 "details": f"Cancellation result: {cancel_result}"
272 |             }
273 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
274 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:292:65: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
291 |             return {
292 |                 "status": "passed" if len(successful_orders) >= 2 else "failed",
    |                                                                 ^ PLR2004
293 |                 "details": f"Successfully submitted {len(successful_orders)}/{len(symbols)} orders"
294 |             }
    |

tests/institutional/framework.py:295:16: BLE001 Do not catch blind exception: `Exception`
    |
293 |                 "details": f"Successfully submitted {len(successful_orders)}/{len(symbols)} orders"
294 |             }
295 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
296 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:319:16: BLE001 Do not catch blind exception: `Exception`
    |
317 |                 "details": "Error handling validation"
318 |             }
319 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
320 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:339:16: BLE001 Do not catch blind exception: `Exception`
    |
337 |                 "details": "Circuit breaker status check"
338 |             }
339 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
340 |             return {"status": "failed", "error": str(e)}
    |

tests/institutional/framework.py:423:20: BLE001 Do not catch blind exception: `Exception`
    |
421 |                     passed += 1
422 | 
423 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
424 |                 results["tests"].append({
425 |                     "name": test_name,
    |

tests/institutional/test_live_trading.py:21:1: E402 Module level import not at top of file
   |
19 | pytest.importorskip('alpaca_trade_api', reason='alpaca not installed')
20 | 
21 | from ai_trading.execution.live_trading import AlpacaExecutionEngine
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
22 | 
23 | from .framework import (
   |

tests/institutional/test_live_trading.py:23:1: E402 Module level import not at top of file
   |
21 |   from ai_trading.execution.live_trading import AlpacaExecutionEngine
22 |   
23 | / from .framework import (
24 | |     ComplianceTestSuite,
25 | |     MockMarketDataProvider,
26 | |     TradingScenarioRunner,
27 | | )
   | |_^ E402
   |

tests/institutional/test_live_trading.py:66:40: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
   |
65 |         assert results["overall_status"] == "passed", f"End-to-end test failed: {results}"
66 |         assert results["pass_rate"] >= 0.8, f"Pass rate too low: {results['pass_rate']}"
   |                                        ^^^ PLR2004
67 | 
68 |         # Check specific scenarios
   |

tests/institutional/test_live_trading.py:81:40: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
   |
80 |         assert results["overall_status"] == "passed", f"Risk scenario tests failed: {results}"
81 |         assert results["pass_rate"] >= 0.9, f"Risk management pass rate too low: {results['pass_rate']}"
   |                                        ^^^ PLR2004
82 | 
83 |     @pytest.mark.asyncio
   |

tests/institutional/test_live_trading.py:91:48: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
90 |         metrics = results["metrics"]
91 |         assert metrics["average_latency_ms"] < 100, f"Latency too high: {metrics['average_latency_ms']}ms"
   |                                                ^^^ PLR2004
92 |         assert metrics["orders_per_second"] > 50, f"Throughput too low: {metrics['orders_per_second']} ops/s"
93 |         assert metrics["memory_usage_mb"] < 100, f"Memory usage too high: {metrics['memory_usage_mb']}MB"
   |

tests/institutional/test_live_trading.py:92:47: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
90 |         metrics = results["metrics"]
91 |         assert metrics["average_latency_ms"] < 100, f"Latency too high: {metrics['average_latency_ms']}ms"
92 |         assert metrics["orders_per_second"] > 50, f"Throughput too low: {metrics['orders_per_second']} ops/s"
   |                                               ^^ PLR2004
93 |         assert metrics["memory_usage_mb"] < 100, f"Memory usage too high: {metrics['memory_usage_mb']}MB"
   |

tests/institutional/test_live_trading.py:93:45: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
91 |         assert metrics["average_latency_ms"] < 100, f"Latency too high: {metrics['average_latency_ms']}ms"
92 |         assert metrics["orders_per_second"] > 50, f"Throughput too low: {metrics['orders_per_second']} ops/s"
93 |         assert metrics["memory_usage_mb"] < 100, f"Memory usage too high: {metrics['memory_usage_mb']}MB"
   |                                             ^^^ PLR2004
94 | 
95 |     @pytest.mark.asyncio
   |

tests/institutional/test_live_trading.py:101:47: PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
    |
100 |         assert results["overall_status"] == "passed", f"Compliance tests failed: {results}"
101 |         assert results["compliance_score"] >= 0.95, f"Compliance score too low: {results['compliance_score']}"
    |                                               ^^^^ PLR2004
102 | 
103 |     def test_execution_engine_initialization(self, execution_engine):
    |

tests/institutional/test_live_trading.py:179:16: BLE001 Do not catch blind exception: `Exception`
    |
177 |             execution_engine.submit_market_order("AAPL", "invalid_side", 100)
178 |             # Should handle gracefully
179 |         except Exception:
    |                ^^^^^^^^^ BLE001
180 |             # Error handling is working
181 |             pass
    |

tests/institutional/test_live_trading.py:275:29: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
    |
273 |             pytest.skip('ALPACA credentials required for integration test')
274 |         now = dt.datetime.now(pytz.timezone('US/Eastern'))
275 |         if now.weekday() >= 5 or not (dt.time(9, 30) <= now.time() <= dt.time(16, 0)):
    |                             ^ PLR2004
276 |             pytest.skip('Market closed')
277 |         # This would test the integration of:
    |

tests/institutional/test_live_trading.py:287:1: I001 [*] Import block is un-sorted or un-formatted
    |
285 |           try:
286 |               # Import key modules
287 | /             from ai_trading.execution.live_trading import AlpacaExecutionEngine
288 | |             from tests.institutional.framework import TradingScenarioRunner
289 | | 
    | |_^ I001
290 |               # Create and initialize components
291 |               engine = AlpacaExecutionEngine()
    |
    = help: Organize imports

tests/integration/test_regime_fallback.py:7:8: BLE001 Do not catch blind exception: `Exception`
  |
5 | try:
6 |     from ai_trading.core import bot_engine
7 | except Exception:
  |        ^^^^^^^^^ BLE001
8 |     pytest.skip("bot engine not importable", allow_module_level=True)
  |

tests/mocks/alpaca_mocks.py:31:1: E402 Module level import not at top of file
   |
31 | import types
   | ^^^^^^^^^^^^ E402
   |

tests/mocks/tenacity_mock.py:15:12: F821 Undefined name `MockWait`
   |
14 | def wait_exponential(*args, **kwargs):
15 |     return MockWait()
   |            ^^^^^^^^ F821
16 | 
17 | def wait_random(*args, **kwargs):
   |

tests/mocks/tenacity_mock.py:18:12: F821 Undefined name `MockWait`
   |
17 | def wait_random(*args, **kwargs):
18 |     return MockWait()
   |            ^^^^^^^^ F821
19 | 
20 | def retry_if_exception_type(*args):
   |

tests/runtime/test_alpaca_wrapped.py:7:1: E402 Module level import not at top of file
  |
5 | pytest.importorskip("alpaca")
6 | 
7 | from ai_trading.broker.alpaca import AlpacaBroker, APIError
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
  |

tests/runtime/test_alpaca_wrapped.py:29:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
27 |     resp = broker.submit_order(symbol="AAPL", qty=1, side="buy")
28 |     assert resp == {"ok": True}
29 |     assert calls["n"] == 2
   |                          ^ PLR2004
   |

tests/runtime/test_http_wrapped.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import requests
2 | | 
3 | | from ai_trading.utils import http
4 | | from ai_trading.utils.timing import HTTP_TIMEOUT, clamp_timeout
5 | | 
6 | | 
7 | | class DummyResp:
  | |_^ I001
8 |       def __init__(self, data):
9 |           self._data = data
  |
  = help: Organize imports

tests/runtime/test_http_wrapped.py:32:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
30 |     resp = http.get("https://example.com")
31 |     assert resp.json() == {"ok": True}
32 |     assert len(calls) == 2
   |                          ^ PLR2004
   |

tests/slow/test_meta_learning_heavy.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 7 |   try:
 8 | /     import pydantic_settings  # noqa: F401
 9 | | 
10 | |     from ai_trading import meta_learning
11 | | except Exception:
   | |_^ I001
12 |       pytest.skip("pydantic v2 required", allow_module_level=True)
13 |   import sklearn.linear_model
   |
   = help: Organize imports

tests/slow/test_meta_learning_heavy.py:11:8: BLE001 Do not catch blind exception: `Exception`
   |
10 |     from ai_trading import meta_learning
11 | except Exception:
   |        ^^^^^^^^^ BLE001
12 |     pytest.skip("pydantic v2 required", allow_module_level=True)
13 | import sklearn.linear_model
   |

tests/test_additional_coverage.py:14:1: I001 [*] Import block is un-sorted or un-formatted
   |
13 |   try:
14 | /     import pydantic_settings  # noqa: F401
15 | | 
16 | |     from ai_trading import config, meta_learning
17 | | except Exception:
   | |_^ I001
18 |       pytest.skip("pydantic v2 required", allow_module_level=True)
   |
   = help: Organize imports

tests/test_additional_coverage.py:17:8: BLE001 Do not catch blind exception: `Exception`
   |
16 |     from ai_trading import config, meta_learning
17 | except Exception:
   |        ^^^^^^^^^ BLE001
18 |     pytest.skip("pydantic v2 required", allow_module_level=True)
   |

tests/test_additional_coverage.py:23:1: I001 [*] Import block is un-sorted or un-formatted
   |
21 |       pytest.skip("pydantic v2 required", allow_module_level=True)
22 |   
23 | / import ai_trading.risk.engine as risk_engine  # AI-AGENT-REF: normalized import
24 | | from ai_trading import (
25 | |     main,
26 | |     ml_model,  # AI-AGENT-REF: canonical import
27 | |     utils,
28 | | )
29 | | from ai_trading.strategies.mean_reversion import MeanReversionStrategy
30 | | from tests.mocks.app_mocks import MockConfig
31 | | 
32 | | 
33 | | def test_config_missing_vars(monkeypatch):
   | |_^ I001
34 |       """_require_env_vars raises when variables missing."""
35 |       with pytest.raises(RuntimeError):
   |
   = help: Organize imports

tests/test_additional_coverage.py:90:50: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
88 |     assert client is not None, "test_client() returned None"
89 |     assert client.get("/health").json() == {"status": "ok"}
90 |     assert client.get("/healthz").status_code == 200
   |                                                  ^^^ PLR2004
   |

tests/test_additional_coverage.py:145:34: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
    |
143 |     perf = {"a": 1.0, "b": 3.0}
144 |     res = meta_learning.update_signal_weights(w, perf)
145 |     assert round(res["b"], 2) == 0.75
    |                                  ^^^^ PLR2004
    |

tests/test_additional_coverage.py:240:26: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
238 |     model = ml_model.train_model([1, 2, 3], [1, 2, 3])
239 |     preds = ml_model.predict_model(model, [[1], [2], [3]])
240 |     assert len(preds) == 3
    |                          ^ PLR2004
241 |     with pytest.raises(ValueError):
242 |         ml_model.predict_model(None, [1])
    |

tests/test_additional_coverage.py:266:45: PLR2004 Magic value used in comparison, consider replacing `0.4` with a constant variable
    |
264 |     eng.strategy_limits["s"] = 0.4
265 |     eng.exposure["equity"] = 0.0
266 |     assert eng._apply_weight_limits(sig) == 0.4
    |                                             ^^^ PLR2004
267 |     res = risk_engine.calculate_position_size(
268 |         risk_engine.TradeSignal(
    |

tests/test_additional_coverage.py:279:19: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
277 |         10,
278 |     )
279 |     assert res == 10
    |                   ^^ PLR2004
    |

tests/test_advanced_features.py:24:8: BLE001 Do not catch blind exception: `Exception`
   |
22 | try:
23 |     from ai_trading import alpaca_api  # AI-AGENT-REF: canonical import
24 | except Exception:
   |        ^^^^^^^^^ BLE001
25 |     pytest.skip("alpaca_api not available", allow_module_level=True)
26 | try:
   |

tests/test_advanced_features.py:28:8: BLE001 Do not catch blind exception: `Exception`
   |
26 | try:
27 |     from ai_trading import rebalancer
28 | except Exception:
   |        ^^^^^^^^^ BLE001
29 |     pytest.skip("alpaca_trade_api not available", allow_module_level=True)
30 | try:
   |

tests/test_advanced_features.py:32:8: BLE001 Do not catch blind exception: `Exception`
   |
30 | try:
31 |     from ai_trading.execution import slippage  # AI-AGENT-REF: use prod slippage module
32 | except Exception:  # pragma: no cover - module optional
   |        ^^^^^^^^^ BLE001
33 |     slippage = None
   |

tests/test_allocator_size_bias.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import logging
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading.config.management import TradingConfig
 6 | | from ai_trading.config.settings import get_settings
 7 | | from ai_trading.settings import get_settings as base_get_settings
 8 | | from ai_trading.strategies.performance_allocator import (
 9 | |     PerformanceBasedAllocator,
10 | |     _resolve_conf_threshold,
11 | | )
12 | | 
13 | | 
14 | | class Sig:
   | |_^ I001
15 |       def __init__(self, sym: str, confidence: float, weight: float = 1.0):
16 |           self.symbol = sym
   |
   = help: Organize imports

tests/test_allocator_size_bias.py:41:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
40 |     items = list(out.get("momentum", []))
41 |     assert len(items) == 2
   |                          ^ PLR2004
42 |     weights = {s.symbol: s.weight for s in items}
43 |     assert weights["B"] > weights["A"]
   |

tests/test_alpaca_api_extended.py:18:26: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   |
16 |     res = alpaca_api.submit_order(api, symbol="AAPL", qty=1, side="buy")
17 |     assert not res.success
18 |     assert res.status == 500
   |                          ^^^ PLR2004
19 |     assert res.retryable
   |

tests/test_alpaca_api_module.py:43:26: PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
   |
41 |     assert not res.success
42 |     assert res.retryable
43 |     assert res.status == 429
   |                          ^^^ PLR2004
44 |     assert api.calls == 1
   |

tests/test_alpaca_contract.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import types
2 | | 
3 | | from ai_trading import alpaca_api  # AI-AGENT-REF: canonical import
4 | | from tests.mocks.alpaca_mocks import MockClient
5 | | 
6 | | 
7 | | def test_submit_order_contract():
  | |_^ I001
8 |       api = MockClient()
9 |       req = types.SimpleNamespace(symbol="AAPL", qty=1, side="buy", time_in_force="day")
  |
  = help: Organize imports

tests/test_alpaca_time_params.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime as dt
 2 | | from unittest.mock import MagicMock, patch
 3 | | 
 4 | | import pandas as pd
 5 | | 
 6 | | from ai_trading.alpaca_api import get_bars_df
 7 | | 
 8 | | 
 9 | | class _Resp:
   | |_^ I001
10 |       def __init__(self, df):
11 |           self.df = df
   |
   = help: Organize imports

tests/test_alpaca_time_params.py:25:37: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
23 |     assert (
24 |         isinstance(kwargs["start"], str)
25 |         and len(kwargs["start"]) == 10
   |                                     ^^ PLR2004
26 |         and kwargs["start"].count("-") == 2
27 |     )
   |

tests/test_alpaca_time_params.py:26:43: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
24 |         isinstance(kwargs["start"], str)
25 |         and len(kwargs["start"]) == 10
26 |         and kwargs["start"].count("-") == 2
   |                                           ^ PLR2004
27 |     )
28 |     assert (
   |

tests/test_alpaca_time_params.py:30:35: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
28 |     assert (
29 |         isinstance(kwargs["end"], str)
30 |         and len(kwargs["end"]) == 10
   |                                   ^^ PLR2004
31 |         and kwargs["end"].count("-") == 2
32 |     )
   |

tests/test_alpaca_time_params.py:31:41: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
29 |         isinstance(kwargs["end"], str)
30 |         and len(kwargs["end"]) == 10
31 |         and kwargs["end"].count("-") == 2
   |                                         ^ PLR2004
32 |     )
33 |     assert kwargs["timeframe"] in ("1Day", "1D")
   |

tests/test_alpaca_timeframe_mapping.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import sys
 2 | | import types
 3 | | from unittest.mock import MagicMock, patch
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | from ai_trading.alpaca_api import get_bars_df
 8 | | 
 9 | | try:
   | |_^ I001
10 |       from alpaca.data.timeframe import TimeFrame, TimeFrameUnit
11 |   except Exception:  # pragma: no cover - inject stub
   |
   = help: Organize imports

tests/test_alpaca_timeframe_mapping.py:11:8: BLE001 Do not catch blind exception: `Exception`
   |
 9 | try:
10 |     from alpaca.data.timeframe import TimeFrame, TimeFrameUnit
11 | except Exception:  # pragma: no cover - inject stub
   |        ^^^^^^^^^ BLE001
12 |     mod = types.ModuleType("alpaca.data.timeframe")
   |

tests/test_alpha_quality.py:29:50: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
   |
27 |         # Check that returns are calculated correctly
28 |         expected = np.log(102/100)  # First return
29 |         assert abs(returns.iloc[0] - expected) < 1e-6, "Fixed horizon return calculation failed"
   |                                                  ^^^^ PLR2004
30 | 
31 |         # Check with fees
   |

tests/test_alpha_quality.py:38:12: BLE001 Do not catch blind exception: `Exception`
   |
36 |     except ImportError:
37 |         pass
38 |     except Exception:
   |            ^^^^^^^^^ BLE001
39 |         pass
   |

tests/test_alpha_quality.py:64:12: BLE001 Do not catch blind exception: `Exception`
   |
62 |     except ImportError:
63 |         pass
64 |     except Exception:
   |            ^^^^^^^^^ BLE001
65 |         pass
   |

tests/test_alpha_quality.py:82:27: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
80 |         # Should be positive and reasonable
81 |         assert slippage > 0, "Slippage should be positive"
82 |         assert slippage < 0.1, "Slippage should be reasonable (< 10%)"
   |                           ^^^ PLR2004
83 | 
84 |         # Test that larger trades have higher slippage
   |

tests/test_alpha_quality.py:91:12: BLE001 Do not catch blind exception: `Exception`
   |
89 |     except ImportError:
90 |         pass
91 |     except Exception:
   |            ^^^^^^^^^ BLE001
92 |         pass
   |

tests/test_alpha_quality.py:130:12: BLE001 Do not catch blind exception: `Exception`
    |
128 |     except ImportError:
129 |         pass
130 |     except Exception:
    |            ^^^^^^^^^ BLE001
131 |         pass
    |

tests/test_alpha_quality.py:169:51: PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
    |
167 |             # Load model back
168 |             loaded_model, loaded_metadata = registry.load_model(model_id)
169 |             assert loaded_metadata["cv_score"] == 0.85, "Metadata should be preserved"
    |                                                   ^^^^ PLR2004
170 | 
171 |             # Test listing models
    |

tests/test_alpha_quality.py:179:12: BLE001 Do not catch blind exception: `Exception`
    |
177 |     except ImportError:
178 |         pass
179 |     except Exception:
    |            ^^^^^^^^^ BLE001
180 |         pass
    |

tests/test_alpha_quality.py:220:12: BLE001 Do not catch blind exception: `Exception`
    |
218 |     except ImportError:
219 |         pass
220 |     except Exception:
    |            ^^^^^^^^^ BLE001
221 |         pass
    |

tests/test_alpha_quality.py:258:16: BLE001 Do not catch blind exception: `Exception`
    |
256 |             validate_pipeline_no_leakage(pipeline, X_train, X_test)
257 |             # The test should pass (no obvious leakage)
258 |         except Exception:
    |                ^^^^^^^^^ BLE001
259 |             # If validation fails due to missing dependencies, that's OK
260 |             pass
    |

tests/test_alpha_quality.py:264:12: BLE001 Do not catch blind exception: `Exception`
    |
262 |     except ImportError:
263 |         pass
264 |     except Exception:
    |            ^^^^^^^^^ BLE001
265 |         pass
    |

tests/test_api_settings.py:11:26: PLR2004 Magic value used in comparison, consider replacing `9001` with a constant variable
   |
 9 |     assert hasattr(s, "api_port")
10 |     assert s.api_host == "0.0.0.0"
11 |     assert s.api_port == 9001
   |                          ^^^^ PLR2004
   |

tests/test_audit_column_fix.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import csv
 2 | | from pathlib import Path
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading import audit  # AI-AGENT-REF: canonical import
 7 | | 
 8 | | 
 9 | | def force_coverage(mod):
   | |_^ I001
10 |       """Force coverage by importing and accessing module attributes instead of using exec."""
11 |       try:
   |
   = help: Organize imports

tests/test_audit_column_fix.py:16:12: BLE001 Do not catch blind exception: `Exception`
   |
14 |             if not attr_name.startswith('_'):
15 |                 getattr(mod, attr_name, None)
16 |     except Exception:
   |            ^^^^^^^^^ BLE001
17 |         # Fallback to original method if needed for coverage
18 |         lines = Path(mod.__file__).read_text().splitlines()
   |

tests/test_audit_column_fix.py:84:49: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
82 |     # Validate no UUID-like strings in symbol column
83 |     symbol = row["symbol"]
84 |     assert not ('-' in symbol and len(symbol) > 10), f"Symbol looks like UUID: {symbol}"
   |                                                 ^^ PLR2004
   |

tests/test_audit_column_fix.py:119:44: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
117 |         symbol = row["symbol"]
118 |         # Check if symbol looks like a UUID
119 |         if '-' in symbol and len(symbol) > 10 and all(c.lower() in uuid_pattern_chars for c in symbol):
    |                                            ^^ PLR2004
120 |             pytest.fail(f"Row {i+1} has UUID-like symbol: {symbol}")
    |

tests/test_audit_smoke.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import csv
 2 | | from pathlib import Path
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading import audit  # AI-AGENT-REF: canonical import
 7 | | 
 8 | | 
 9 | | def force_coverage(mod):
   | |_^ I001
10 |       """Force coverage by importing and accessing module attributes instead of using exec."""
11 |       try:
   |
   = help: Organize imports

tests/test_audit_smoke.py:16:12: BLE001 Do not catch blind exception: `Exception`
   |
14 |             if not attr_name.startswith('_'):
15 |                 getattr(mod, attr_name, None)
16 |     except Exception:
   |            ^^^^^^^^^ BLE001
17 |         # Fallback to original method if needed for coverage
18 |         lines = Path(mod.__file__).read_text().splitlines()
   |

tests/test_backtest_smoke.py:14:12: BLE001 Do not catch blind exception: `Exception`
   |
12 |             if not attr_name.startswith('_'):
13 |                 getattr(mod, attr_name, None)
14 |     except Exception:
   |            ^^^^^^^^^ BLE001
15 |         # Fallback to original method if needed for coverage
16 |         lines = Path(mod.__file__).read_text().splitlines()
   |

tests/test_bars_fallback.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.data.bars import _resample_minutes_to_daily
4 | | 
5 | | 
6 | | def test_resample_minute_to_daily_basic():
  | |_^ I001
7 |       idx = pd.date_range(
8 |           "2025-08-19 13:30", periods=390 * 2, freq="1min", tz="America/New_York"
  |
  = help: Organize imports

tests/test_bars_timeframe_feed_canonicalization.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading.data import bars as bars_mod
 6 | | 
 7 | | # AI-AGENT-REF: test central helpers
 8 | | from ai_trading.logging.normalize import (
 9 | |     canon_feed as _canon_feed,
10 | | )
11 | | from ai_trading.logging.normalize import (
12 | |     canon_timeframe as _canon_tf,
13 | | )
14 | | 
15 | | 
16 | | def _dummy_callable():  # AI-AGENT-REF: simulate stub attribute
   | |_^ I001
17 |       return None
   |
   = help: Organize imports

tests/test_batch_and_warmup.py:7:8: BLE001 Do not catch blind exception: `Exception`
  |
5 | try:
6 |     from ai_trading.data_fetcher import get_bars_batch, warmup_cache
7 | except Exception:
  |        ^^^^^^^^^ BLE001
8 |     pytest.skip("data_fetcher deps missing", allow_module_level=True)
  |

tests/test_batch_paths.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | import ai_trading.core.bot_engine as be
 6 | | import ai_trading.trade_logic as tl
 7 | | 
 8 | | 
 9 | | def _mk_df():
   | |_^ I001
10 |       return pd.DataFrame(
11 |           {
   |
   = help: Organize imports

tests/test_benchmarks.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import inspect
 2 | | 
 3 | | import numpy as np
 4 | | import pandas as pd
 5 | | import pytest
 6 | | 
 7 | | from ai_trading import indicators, signals
 8 | | 
 9 | | df = pd.DataFrame({
   | |_^ I001
10 |       'open': np.random.random(500_000) * 100,
11 |       'high': np.random.random(500_000) * 100,
   |
   = help: Organize imports

tests/test_benchmarks.py:37:12: E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
   |
35 |             continue
36 |         # skip if explicitly takes str, not intended for DataFrames
37 |         if required_positional[0].annotation == str:
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E721
38 |             continue
39 |         if hasattr(func, "py_func") or name == "jit":
   |

tests/test_bot.py:202:1: E402 Module level import not at top of file
    |
200 |     sys.modules["pandas_ta"].vwap = lambda *a, **k: pd.Series([0])
201 | 
202 | from ai_trading.core import bot_engine as bot
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
    |

tests/test_bot_engine_imports.py:41:24: BLE001 Do not catch blind exception: `Exception`
   |
39 |                     assert model_pipeline == "mock_model_pipeline"
40 |                     primary_success = True
41 |                 except Exception:
   |                        ^^^^^^^^^ BLE001
42 |                     primary_success = False
   |

tests/test_bot_engine_imports.py:70:28: BLE001 Do not catch blind exception: `Exception`
   |
68 |                         from ai_trading.pipeline import model_pipeline  # type: ignore
69 |                         fallback_triggered = False
70 |                     except Exception:  # pragma: no cover
   |                            ^^^^^^^^^ BLE001
71 |                         from pipeline import model_pipeline  # type: ignore
72 |                         fallback_triggered = True
   |

tests/test_bot_extended.py:201:1: E402 Module level import not at top of file
    |
199 | sys.modules["pybreaker"].CircuitBreaker = _DummyBreaker
200 | 
201 | from ai_trading.core import bot_engine as bot
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
    |

tests/test_bot_extended.py:207:45: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
    |
205 |     """compute_time_range should span the requested minutes."""
206 |     start, end = bot.compute_time_range(5)
207 |     assert (end - start).total_seconds() == 300
    |                                             ^^^ PLR2004
    |

tests/test_bot_extended.py:215:40: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
    |
213 |     assert bot.get_latest_close(None) == 0.0
214 |     df = pd.DataFrame({"close": [1.5]}, index=[pd.Timestamp("2024-01-01")])
215 |     assert bot.get_latest_close(df) == 1.5
    |                                        ^^^ PLR2004
    |

tests/test_broker_alpaca.py:38:61: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
36 |     broker._is_new = False
37 |     pos = broker.get_open_position("MSFT")
38 |     assert pos and pos.symbol == "MSFT" and int(pos.qty) == 5
   |                                                             ^ PLR2004
39 |     none = broker.get_open_position("NVDA")
40 |     assert none is None
   |

tests/test_broker_alpaca_adapter.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pytest
2 | | 
3 | | from ai_trading.broker.alpaca import AlpacaBroker
4 | | 
5 | | pytestmark = pytest.mark.alpaca
  | |_^ I001
6 |   
7 |   # Fake “new” and “old” clients that expose just enough to be called.
  |
  = help: Organize imports

tests/test_capital_scaling_smoke.py:18:12: BLE001 Do not catch blind exception: `Exception`
   |
16 |             if not attr_name.startswith('_'):
17 |                 getattr(mod, attr_name, None)
18 |     except Exception:
   |            ^^^^^^^^^ BLE001
19 |         # Fallback to original method if needed for coverage
20 |         lines = Path(mod.__file__).read_text().splitlines()
   |

tests/test_capital_scaling_smoke.py:28:38: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
26 | def test_capital_scaler_basic():
27 |     eng = capital_scaling.CapitalScalingEngine({"x": 1})
28 |     assert eng.scale_position(10) == 10
   |                                      ^^ PLR2004
   |

tests/test_centralized_config.py:27:41: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
   |
26 |         # Test default values are set
27 |         assert config.kelly_fraction == 0.6
   |                                         ^^^ PLR2004
28 |         assert config.conf_threshold == 0.75
29 |         assert config.daily_loss_limit == 0.03
   |

tests/test_centralized_config.py:28:41: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   |
26 |         # Test default values are set
27 |         assert config.kelly_fraction == 0.6
28 |         assert config.conf_threshold == 0.75
   |                                         ^^^^ PLR2004
29 |         assert config.daily_loss_limit == 0.03
30 |         assert config.capital_cap == 0.25
   |

tests/test_centralized_config.py:29:43: PLR2004 Magic value used in comparison, consider replacing `0.03` with a constant variable
   |
27 |         assert config.kelly_fraction == 0.6
28 |         assert config.conf_threshold == 0.75
29 |         assert config.daily_loss_limit == 0.03
   |                                           ^^^^ PLR2004
30 |         assert config.capital_cap == 0.25
31 |         assert config.max_position_size == 8000
   |

tests/test_centralized_config.py:30:38: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
28 |         assert config.conf_threshold == 0.75
29 |         assert config.daily_loss_limit == 0.03
30 |         assert config.capital_cap == 0.25
   |                                      ^^^^ PLR2004
31 |         assert config.max_position_size == 8000
   |

tests/test_centralized_config.py:31:44: PLR2004 Magic value used in comparison, consider replacing `8000` with a constant variable
   |
29 |         assert config.daily_loss_limit == 0.03
30 |         assert config.capital_cap == 0.25
31 |         assert config.max_position_size == 8000
   |                                            ^^^^ PLR2004
32 | 
33 |     def test_trading_config_from_env(self):
   |

tests/test_centralized_config.py:62:41: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
60 |         config = TradingConfig.from_env("conservative")
61 | 
62 |         assert config.kelly_fraction == 0.25
   |                                         ^^^^ PLR2004
63 |         assert config.conf_threshold == 0.85
64 |         assert config.daily_loss_limit == 0.03
   |

tests/test_centralized_config.py:63:41: PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
   |
62 |         assert config.kelly_fraction == 0.25
63 |         assert config.conf_threshold == 0.85
   |                                         ^^^^ PLR2004
64 |         assert config.daily_loss_limit == 0.03
65 |         assert config.capital_cap == 0.04
   |

tests/test_centralized_config.py:64:43: PLR2004 Magic value used in comparison, consider replacing `0.03` with a constant variable
   |
62 |         assert config.kelly_fraction == 0.25
63 |         assert config.conf_threshold == 0.85
64 |         assert config.daily_loss_limit == 0.03
   |                                           ^^^^ PLR2004
65 |         assert config.capital_cap == 0.04
66 |         assert config.confirmation_count == 3
   |

tests/test_centralized_config.py:65:38: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
63 |         assert config.conf_threshold == 0.85
64 |         assert config.daily_loss_limit == 0.03
65 |         assert config.capital_cap == 0.04
   |                                      ^^^^ PLR2004
66 |         assert config.confirmation_count == 3
67 |         assert config.take_profit_factor == 1.5
   |

tests/test_centralized_config.py:66:45: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
64 |         assert config.daily_loss_limit == 0.03
65 |         assert config.capital_cap == 0.04
66 |         assert config.confirmation_count == 3
   |                                             ^ PLR2004
67 |         assert config.take_profit_factor == 1.5
68 |         assert config.max_position_size == 5000
   |

tests/test_centralized_config.py:67:45: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
   |
65 |         assert config.capital_cap == 0.04
66 |         assert config.confirmation_count == 3
67 |         assert config.take_profit_factor == 1.5
   |                                             ^^^ PLR2004
68 |         assert config.max_position_size == 5000
   |

tests/test_centralized_config.py:68:44: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
   |
66 |         assert config.confirmation_count == 3
67 |         assert config.take_profit_factor == 1.5
68 |         assert config.max_position_size == 5000
   |                                            ^^^^ PLR2004
69 | 
70 |     def test_balanced_mode_parameters(self):
   |

tests/test_centralized_config.py:74:41: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
   |
72 |         config = TradingConfig.from_env("balanced")
73 | 
74 |         assert config.kelly_fraction == 0.6
   |                                         ^^^ PLR2004
75 |         assert config.conf_threshold == 0.75
76 |         assert config.daily_loss_limit == 0.03
   |

tests/test_centralized_config.py:75:41: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   |
74 |         assert config.kelly_fraction == 0.6
75 |         assert config.conf_threshold == 0.75
   |                                         ^^^^ PLR2004
76 |         assert config.daily_loss_limit == 0.03
77 |         assert config.capital_cap == 0.04
   |

tests/test_centralized_config.py:76:43: PLR2004 Magic value used in comparison, consider replacing `0.03` with a constant variable
   |
74 |         assert config.kelly_fraction == 0.6
75 |         assert config.conf_threshold == 0.75
76 |         assert config.daily_loss_limit == 0.03
   |                                           ^^^^ PLR2004
77 |         assert config.capital_cap == 0.04
78 |         assert config.confirmation_count == 2
   |

tests/test_centralized_config.py:77:38: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
75 |         assert config.conf_threshold == 0.75
76 |         assert config.daily_loss_limit == 0.03
77 |         assert config.capital_cap == 0.04
   |                                      ^^^^ PLR2004
78 |         assert config.confirmation_count == 2
79 |         assert config.take_profit_factor == 1.8
   |

tests/test_centralized_config.py:78:45: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
76 |         assert config.daily_loss_limit == 0.03
77 |         assert config.capital_cap == 0.04
78 |         assert config.confirmation_count == 2
   |                                             ^ PLR2004
79 |         assert config.take_profit_factor == 1.8
80 |         assert config.max_position_size == 8000
   |

tests/test_centralized_config.py:79:45: PLR2004 Magic value used in comparison, consider replacing `1.8` with a constant variable
   |
77 |         assert config.capital_cap == 0.04
78 |         assert config.confirmation_count == 2
79 |         assert config.take_profit_factor == 1.8
   |                                             ^^^ PLR2004
80 |         assert config.max_position_size == 8000
   |

tests/test_centralized_config.py:80:44: PLR2004 Magic value used in comparison, consider replacing `8000` with a constant variable
   |
78 |         assert config.confirmation_count == 2
79 |         assert config.take_profit_factor == 1.8
80 |         assert config.max_position_size == 8000
   |                                            ^^^^ PLR2004
81 | 
82 |     def test_aggressive_mode_parameters(self):
   |

tests/test_centralized_config.py:86:41: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   |
84 |         config = TradingConfig.from_env("aggressive")
85 | 
86 |         assert config.kelly_fraction == 0.75
   |                                         ^^^^ PLR2004
87 |         assert config.conf_threshold == 0.65
88 |         assert config.daily_loss_limit == 0.03
   |

tests/test_centralized_config.py:87:41: PLR2004 Magic value used in comparison, consider replacing `0.65` with a constant variable
   |
86 |         assert config.kelly_fraction == 0.75
87 |         assert config.conf_threshold == 0.65
   |                                         ^^^^ PLR2004
88 |         assert config.daily_loss_limit == 0.03
89 |         assert config.capital_cap == 0.04
   |

tests/test_centralized_config.py:88:43: PLR2004 Magic value used in comparison, consider replacing `0.03` with a constant variable
   |
86 |         assert config.kelly_fraction == 0.75
87 |         assert config.conf_threshold == 0.65
88 |         assert config.daily_loss_limit == 0.03
   |                                           ^^^^ PLR2004
89 |         assert config.capital_cap == 0.04
90 |         assert config.confirmation_count == 1
   |

tests/test_centralized_config.py:89:38: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
87 |         assert config.conf_threshold == 0.65
88 |         assert config.daily_loss_limit == 0.03
89 |         assert config.capital_cap == 0.04
   |                                      ^^^^ PLR2004
90 |         assert config.confirmation_count == 1
91 |         assert config.take_profit_factor == 2.5
   |

tests/test_centralized_config.py:91:45: PLR2004 Magic value used in comparison, consider replacing `2.5` with a constant variable
   |
89 |         assert config.capital_cap == 0.04
90 |         assert config.confirmation_count == 1
91 |         assert config.take_profit_factor == 2.5
   |                                             ^^^ PLR2004
92 |         assert config.max_position_size == 12000
   |

tests/test_centralized_config.py:92:44: PLR2004 Magic value used in comparison, consider replacing `12000` with a constant variable
   |
90 |         assert config.confirmation_count == 1
91 |         assert config.take_profit_factor == 2.5
92 |         assert config.max_position_size == 12000
   |                                            ^^^^^ PLR2004
93 | 
94 |     def test_legacy_parameter_interface(self):
   |

tests/test_centralized_config.py:126:49: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
    |
125 |         # Conservative mode checks
126 |         assert cons_params["KELLY_FRACTION"] == 0.25
    |                                                 ^^^^ PLR2004
127 |         assert cons_params["CONF_THRESHOLD"] == 0.85
128 |         assert cons_params["CONFIRMATION_COUNT"] == 3
    |

tests/test_centralized_config.py:127:49: PLR2004 Magic value used in comparison, consider replacing `0.85` with a constant variable
    |
125 |         # Conservative mode checks
126 |         assert cons_params["KELLY_FRACTION"] == 0.25
127 |         assert cons_params["CONF_THRESHOLD"] == 0.85
    |                                                 ^^^^ PLR2004
128 |         assert cons_params["CONFIRMATION_COUNT"] == 3
    |

tests/test_centralized_config.py:128:53: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
126 |         assert cons_params["KELLY_FRACTION"] == 0.25
127 |         assert cons_params["CONF_THRESHOLD"] == 0.85
128 |         assert cons_params["CONFIRMATION_COUNT"] == 3
    |                                                     ^ PLR2004
129 | 
130 |         # Balanced mode checks
    |

tests/test_centralized_config.py:131:48: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
    |
130 |         # Balanced mode checks
131 |         assert bal_params["KELLY_FRACTION"] == 0.6
    |                                                ^^^ PLR2004
132 |         assert bal_params["CONF_THRESHOLD"] == 0.75
133 |         assert bal_params["CONFIRMATION_COUNT"] == 2
    |

tests/test_centralized_config.py:132:48: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
    |
130 |         # Balanced mode checks
131 |         assert bal_params["KELLY_FRACTION"] == 0.6
132 |         assert bal_params["CONF_THRESHOLD"] == 0.75
    |                                                ^^^^ PLR2004
133 |         assert bal_params["CONFIRMATION_COUNT"] == 2
    |

tests/test_centralized_config.py:133:52: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
131 |         assert bal_params["KELLY_FRACTION"] == 0.6
132 |         assert bal_params["CONF_THRESHOLD"] == 0.75
133 |         assert bal_params["CONFIRMATION_COUNT"] == 2
    |                                                    ^ PLR2004
134 | 
135 |         # Aggressive mode checks
    |

tests/test_centralized_config.py:136:48: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
    |
135 |         # Aggressive mode checks
136 |         assert agg_params["KELLY_FRACTION"] == 0.75
    |                                                ^^^^ PLR2004
137 |         assert agg_params["CONF_THRESHOLD"] == 0.65
138 |         assert agg_params["CONFIRMATION_COUNT"] == 1
    |

tests/test_centralized_config.py:137:48: PLR2004 Magic value used in comparison, consider replacing `0.65` with a constant variable
    |
135 |         # Aggressive mode checks
136 |         assert agg_params["KELLY_FRACTION"] == 0.75
137 |         assert agg_params["CONF_THRESHOLD"] == 0.65
    |                                                ^^^^ PLR2004
138 |         assert agg_params["CONFIRMATION_COUNT"] == 1
    |

tests/test_centralized_config.py:200:41: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
199 |         # Check that optimization parameters were applied
200 |         assert config.kelly_fraction == 0.5
    |                                         ^^^ PLR2004
201 |         assert config.conf_threshold == 0.8
202 |         assert config.daily_loss_limit == 0.04
    |

tests/test_centralized_config.py:201:41: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
199 |         # Check that optimization parameters were applied
200 |         assert config.kelly_fraction == 0.5
201 |         assert config.conf_threshold == 0.8
    |                                         ^^^ PLR2004
202 |         assert config.daily_loss_limit == 0.04
    |

tests/test_centralized_config.py:202:43: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
    |
200 |         assert config.kelly_fraction == 0.5
201 |         assert config.conf_threshold == 0.8
202 |         assert config.daily_loss_limit == 0.04
    |                                           ^^^^ PLR2004
203 | 
204 |     def test_environment_variable_override(self):
    |

tests/test_centralized_config.py:214:45: PLR2004 Magic value used in comparison, consider replacing `0.35` with a constant variable
    |
213 |             # Check that environment variables were used
214 |             assert config.kelly_fraction == 0.35
    |                                             ^^^^ PLR2004
215 |             assert config.conf_threshold == 0.72
    |

tests/test_centralized_config.py:215:45: PLR2004 Magic value used in comparison, consider replacing `0.72` with a constant variable
    |
213 |             # Check that environment variables were used
214 |             assert config.kelly_fraction == 0.35
215 |             assert config.conf_threshold == 0.72
    |                                             ^^^^ PLR2004
216 | 
217 |         finally:
    |

tests/test_centralized_logging_no_duplicates.py:59:44: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
58 |             # Validate results
59 |             assert handlers_after_first <= 2, f"Too many handlers after first setup: {handlers_after_first}"
   |                                            ^ PLR2004
60 |             assert handlers_after_first == handlers_after_second, "Handler count changed on second setup"
61 |             assert handlers_after_second == handlers_after_third, "Handler count changed on third setup"
   |

tests/test_centralized_logging_no_duplicates.py:113:16: BLE001 Do not catch blind exception: `Exception`
    |
111 |                 setup_logging(debug=True)
112 |                 results.append(len(logging.getLogger().handlers))
113 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
114 |             exceptions.append(e)
    |

tests/test_centralized_logging_no_duplicates.py:141:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
140 |         # Verify reasonable handler count
141 |         assert results[0] <= 2, f"Too many handlers: {results[0]}"
    |                              ^ PLR2004
142 | 
143 |     finally:
    |

tests/test_client_order_id.py:23:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
21 |     alpaca_api.submit_order(api, make_req())
22 |     alpaca_api.submit_order(api, make_req())
23 |     assert len(set(api.ids)) == 2
   |                                 ^ PLR2004
   |

tests/test_conf_size_curve.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import numpy as np
2 | | import pytest
3 | | 
4 | | from ai_trading.strategies.performance_allocator import _compute_conf_multiplier
5 | | 
6 | | 
7 | | @pytest.mark.parametrize(
  | |_^ I001
8 |       "th,max_boost,gamma",
9 |       [
  |
  = help: Organize imports

tests/test_conf_size_curve.py:21:31: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
   |
19 |     assert max(ys) <= max_boost + 1e-9
20 |     assert all(b + 1e-12 >= a for a, b in zip(ys, ys[1:]))
21 |     assert abs(ys[0] - 1.0) < 1e-6
   |                               ^^^^ PLR2004
22 |     assert abs(ys[-1] - max_boost) < 1e-6
   |

tests/test_conf_size_curve.py:22:38: PLR2004 Magic value used in comparison, consider replacing `1e-6` with a constant variable
   |
20 |     assert all(b + 1e-12 >= a for a, b in zip(ys, ys[1:]))
21 |     assert abs(ys[0] - 1.0) < 1e-6
22 |     assert abs(ys[-1] - max_boost) < 1e-6
   |                                      ^^^^ PLR2004
   |

tests/test_confidence_gate.py:9:12: BLE001 Do not catch blind exception: `Exception`
   |
 7 |         import ai_trading.strategy_allocator as s
 8 |         return s
 9 |     except Exception:
   |            ^^^^^^^^^ BLE001
10 |         import scripts.strategy_allocator as s
11 |         return s
   |

tests/test_config_additional.py:2:1: I001 [*] Import block is un-sorted or un-formatted
  |
2 | / import pytest
3 | | 
4 | | from ai_trading import config
5 | | 
6 | | 
7 | | def test_get_env_required_missing(monkeypatch):
  | |_^ I001
8 |       """get_env raises when required variable is absent."""
9 |       with pytest.raises(RuntimeError):
  |
  = help: Organize imports

tests/test_config_deadlock_fix.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Tests for configuration validation deadlock fix."""
 2 |   
 3 | / import os
 4 | | import threading
 5 | | import time
 6 | | from unittest.mock import patch
 7 | | 
 8 | | import pytest
 9 | | 
10 | | from ai_trading import config
11 | | 
12 | | 
13 | | def test_no_hang_on_basic_validation():
   | |_^ I001
14 |       """Test that basic validation operations complete without hanging."""
15 |       start_time = time.time()
   |
   = help: Organize imports

tests/test_config_deadlock_fix.py:24:22: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
23 |     elapsed = time.time() - start_time
24 |     assert elapsed < 5.0, f"Validation took too long (possible hang): {elapsed:.2f} seconds"
   |                      ^^^ PLR2004
   |

tests/test_config_deadlock_fix.py:37:22: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
36 |     elapsed = time.time() - start_time
37 |     assert elapsed < 5.0, f"Validation took too long (possible hang): {elapsed:.2f} seconds"
   |                      ^^^ PLR2004
   |

tests/test_config_deadlock_fix.py:58:26: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
57 |         elapsed = time.time() - start_time
58 |         assert elapsed < 5.0, f"Nested validation took too long: {elapsed:.2f} seconds"
   |                          ^^^ PLR2004
   |

tests/test_config_deadlock_fix.py:91:28: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
   |
90 |     total_elapsed = time.time() - start_time
91 |     assert total_elapsed < 10.0, f"Total concurrent validation took too long: {total_elapsed:.2f} seconds"
   |                            ^^^^ PLR2004
92 |     assert len(results) == 3, f"Not all threads completed: got {len(results)} results"
   |

tests/test_config_deadlock_fix.py:92:28: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
90 |     total_elapsed = time.time() - start_time
91 |     assert total_elapsed < 10.0, f"Total concurrent validation took too long: {total_elapsed:.2f} seconds"
92 |     assert len(results) == 3, f"Not all threads completed: got {len(results)} results"
   |                            ^ PLR2004
   |

tests/test_config_deadlock_fix.py:99:36: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
    |
 97 |     # This is a bit tricky to test, but we can verify the timeout mechanism exists
 98 |     assert hasattr(config, '_LOCK_TIMEOUT')
 99 |     assert config._LOCK_TIMEOUT == 30
    |                                    ^^ PLR2004
100 | 
101 |     # Test that the lock tracking functions exist and work
    |

tests/test_config_deadlock_fix.py:129:26: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
128 |         elapsed = time.time() - start_time
129 |         assert elapsed < 5.0, f"Validation took too long: {elapsed:.2f} seconds"
    |                          ^^^ PLR2004
    |

tests/test_config_deadlock_fix.py:139:12: BLE001 Do not catch blind exception: `Exception`
    |
137 |         # This is the specific test case mentioned in the problem statement
138 |         pass
139 |     except Exception:
    |            ^^^^^^^^^ BLE001
140 |         # Import might fail due to missing dependencies, but it shouldn't hang
141 |         pass
    |

tests/test_config_deadlock_fix.py:144:22: PLR2004 Magic value used in comparison, consider replacing `10.0` with a constant variable
    |
143 |     elapsed = time.time() - start_time
144 |     assert elapsed < 10.0, f"Import took too long (possible hang): {elapsed:.2f} seconds"
    |                      ^^^^ PLR2004
    |

tests/test_config_deadlock_fix.py:161:22: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
160 |     elapsed = time.time() - start_time
161 |     assert elapsed < 5.0, f"Deadlock scenario took too long: {elapsed:.2f} seconds"
    |                      ^^^ PLR2004
    |

tests/test_config_env.py:69:20: BLE001 Do not catch blind exception: `Exception`
   |
67 |                 result = os.getenv("DISABLE_DAILY_RETRAIN", "false").lower() in ("true", "1")
68 |                 assert result is True
69 |             except Exception as e:
   |                    ^^^^^^^^^ BLE001
70 |                 # If import fails due to missing env vars, that's expected in test environment
71 |                 # Just ensure our logic works
   |

tests/test_config_validation_max_position_size.py:26:55: PLR2004 Magic value used in comparison, consider replacing `8000.0` with a constant variable
   |
24 |         main._validate_runtime_config(cfg, tcfg)
25 | 
26 |     assert getattr(tcfg, "max_position_size", 0.0) == 8000.0
   |                                                       ^^^^^^ PLR2004
27 | 
28 |     assert any(
   |

tests/test_core_init_fix.py:65:60: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
   |
64 |         # Test enum properties
65 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
   |                                                            ^^^^ PLR2004
66 |         assert RiskLevel.MODERATE.max_position_size == 0.05
67 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |

tests/test_core_init_fix.py:66:56: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
64 |         # Test enum properties
65 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
66 |         assert RiskLevel.MODERATE.max_position_size == 0.05
   |                                                        ^^^^ PLR2004
67 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |

tests/test_core_init_fix.py:67:58: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
   |
65 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
66 |         assert RiskLevel.MODERATE.max_position_size == 0.05
67 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |                                                          ^^^^ PLR2004
68 | 
69 |     def test_trading_constants_structure(self):
   |

tests/test_coverage_hack.py:21:16: BLE001 Do not catch blind exception: `Exception`
   |
19 |         except SyntaxError as e:
20 |             logger.error("Syntax error in %s: %s", fname, e)
21 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
22 |             logger.error("Coverage test failed for %s: %s", fname, e)
23 |             # Don't fail the test, just log the error
   |

tests/test_critical_datetime_fixes.py:26:20: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
25 |         # Test with naive datetime
26 |         naive_dt = datetime(2025, 1, 1, 12, 0, 0)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
27 |         result = ensure_datetime(naive_dt)
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_critical_datetime_fixes.py:67:16: BLE001 Do not catch blind exception: `Exception`
   |
65 |         try:
66 |             get_bars("AAPL", start_dt, end_dt)
67 |         except Exception as e:  # pragma: no cover - ensure no TZ errors
   |                ^^^^^^^^^ BLE001
68 |             if "timezone" in str(e).lower():
69 |                 self.fail(f"get_bars failed due to timezone issues: {e}")
   |

tests/test_critical_datetime_fixes.py:113:1: I001 [*] Import block is un-sorted or un-formatted
    |
111 |           """Test that sentiment caching properly handles rate limits."""
112 |           try:
113 | /             import time
114 | | 
115 | |             from requests.exceptions import HTTPError
116 | | 
117 | |             from ai_trading.core.bot_engine import _SENTIMENT_CACHE, fetch_sentiment
118 | | 
    | |_^ I001
119 |               # Clear cache
120 |               _SENTIMENT_CACHE.clear()
    |
    = help: Organize imports

tests/test_critical_fixes.py:125:44: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
123 |     assert fresh_result['is_fresh'] is True
124 |     assert fresh_result['symbol'] == "AAPL"
125 |     assert fresh_result['minutes_stale'] < 15
    |                                            ^^ PLR2004
126 | 
127 |     # Test freshness check for stale data
    |

tests/test_critical_fixes.py:131:44: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
    |
129 |     assert stale_result['is_fresh'] is False
130 |     assert stale_result['symbol'] == "MSFT"
131 |     assert stale_result['minutes_stale'] > 15
    |                                            ^^ PLR2004
132 | 
133 |     # Test batch validation
    |

tests/test_critical_fixes.py:190:42: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
188 |     risk_engine.exposure['equity'] = 0.5
189 |     updated_exposure = risk_engine.get_current_exposure()
190 |     assert updated_exposure['equity'] == 0.5
    |                                          ^^^ PLR2004
191 | 
192 |     # Test max exposure configuration
    |

tests/test_critical_fixes.py:220:12: BLE001 Do not catch blind exception: `Exception`
    |
218 |         log_trade("AAPL", 10, "buy", 150.0, datetime.now(UTC), "test")
219 |         # If it succeeds, that's fine - we're mainly testing the error handling path exists
220 |     except Exception:
    |            ^^^^^^^^^ BLE001
221 |         # If it fails due to missing dependencies, that's also acceptable for this test
222 |         pass
    |

tests/test_critical_fixes.py:256:46: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
    |
254 |     updated_exposure = risk_engine.get_current_exposure()
255 |     assert 'test_asset' in updated_exposure
256 |     assert updated_exposure['test_asset'] == 0.3
    |                                              ^^^ PLR2004
    |

tests/test_critical_fixes_focused.py:68:16: BLE001 Do not catch blind exception: `Exception`
   |
66 |                 self.assertTrue(0 <= signal.confidence <= 1,
67 |                               f"Signal confidence {signal.confidence} is not in [0,1] range")
68 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
69 |             self.fail(f"Confidence normalization failed: {e}")
   |

tests/test_critical_fixes_focused.py:149:35: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
148 |     # Fixed logic - ensure minimum position size when cash available
149 |     if raw_qty <= 0 and balance > 1000 and target_weight > 0.001 and current_price > 0:
    |                                   ^^^^ PLR2004
150 |         raw_qty = max(1, int(1000 / current_price))  # Minimum $1000 position
    |

tests/test_critical_fixes_focused.py:149:60: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
    |
148 |     # Fixed logic - ensure minimum position size when cash available
149 |     if raw_qty <= 0 and balance > 1000 and target_weight > 0.001 and current_price > 0:
    |                                                            ^^^^^ PLR2004
150 |         raw_qty = max(1, int(1000 / current_price))  # Minimum $1000 position
    |

tests/test_critical_fixes_focused.py:197:27: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
196 |         # Should have 3 valid rows (INVALID row should be filtered out)
197 |         assert len(df) == 3, f"Should have 3 valid price rows, got {len(df)}"
    |                           ^ PLR2004
198 |         assert all(df["entry_price"] > 0), "All entry prices should be positive"
199 |         assert all(df["exit_price"] > 0), "All exit prices should be positive"
    |

tests/test_critical_fixes_focused.py:216:27: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
215 |     # Fixed logic - allow minimum position with sufficient cash
216 |     if liquidity_factor < 0.2:
    |                           ^^^ PLR2004
217 |         if cash > 5000:
218 |             # Use minimum viable position
    |

tests/test_critical_fixes_focused.py:217:19: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
    |
215 |     # Fixed logic - allow minimum position with sufficient cash
216 |     if liquidity_factor < 0.2:
217 |         if cash > 5000:
    |                   ^^^^ PLR2004
218 |             # Use minimum viable position
219 |             result = max(1, int(1000 / price)) if price > 0 else 1
    |

tests/test_critical_fixes_focused.py:276:5: F821 Undefined name `test_timestamp_format_includes_timezone`
    |
275 | if __name__ == "__main__":
276 |     test_timestamp_format_includes_timezone()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ F821
277 |     test_position_sizing_minimum_viable()
278 |     test_meta_learning_price_conversion()
    |

tests/test_critical_fixes_implementation.py:47:34: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
45 |     # Test safe_divide function
46 |     assert safe_divide(10, 0) == 0.0
47 |     assert safe_divide(10, 2) == 5.0
   |                                  ^^^ PLR2004
48 |     assert safe_divide(10, 0, default=99) == 99
   |

tests/test_critical_fixes_implementation.py:48:46: PLR2004 Magic value used in comparison, consider replacing `99` with a constant variable
   |
46 |     assert safe_divide(10, 0) == 0.0
47 |     assert safe_divide(10, 2) == 5.0
48 |     assert safe_divide(10, 0, default=99) == 99
   |                                              ^^ PLR2004
49 | 
50 |     # Test ATR with edge cases
   |

tests/test_critical_fixes_implementation.py:77:16: BLE001 Do not catch blind exception: `Exception`
   |
75 |                 result = optimizer._calculate_kelly_fraction("TEST")
76 |                 results.append(result)
77 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
78 |             errors.append(e)
   |

tests/test_critical_fixes_implementation.py:92:28: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
   |
90 |     # Should have results from all threads without errors
91 |     assert len(errors) == 0, f"Thread safety errors: {errors}"
92 |     assert len(results) == 500  # 5 threads * 100 calculations each
   |                            ^^^ PLR2004
   |

tests/test_critical_fixes_implementation.py:109:49: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
108 |         # Cache should not exceed maxsize
109 |         assert len(predict._sentiment_cache) <= 1000
    |                                                 ^^^^ PLR2004
110 |     else:
111 |         # Test manual cache management
    |

tests/test_critical_fixes_implementation.py:125:49: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
    |
124 |         # Cache should be bounded
125 |         assert len(predict._sentiment_cache) <= 1000
    |                                                 ^^^^ PLR2004
    |

tests/test_critical_fixes_implementation.py:141:29: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
140 |     # Should only contain last 100 items
141 |     assert buffer.size() == 100
    |                             ^^^ PLR2004
142 |     data = buffer.get_array()
143 |     assert len(data) == 100
    |

tests/test_critical_fixes_implementation.py:143:25: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
141 |     assert buffer.size() == 100
142 |     data = buffer.get_array()
143 |     assert len(data) == 100
    |                         ^^^ PLR2004
144 |     assert data[0] == 100.0  # First item should be 100 (not 0)
145 |     assert data[-1] == 199.0  # Last item should be 199
    |

tests/test_critical_fixes_implementation.py:144:23: PLR2004 Magic value used in comparison, consider replacing `100.0` with a constant variable
    |
142 |     data = buffer.get_array()
143 |     assert len(data) == 100
144 |     assert data[0] == 100.0  # First item should be 100 (not 0)
    |                       ^^^^^ PLR2004
145 |     assert data[-1] == 199.0  # Last item should be 199
    |

tests/test_critical_fixes_implementation.py:145:24: PLR2004 Magic value used in comparison, consider replacing `199.0` with a constant variable
    |
143 |     assert len(data) == 100
144 |     assert data[0] == 100.0  # First item should be 100 (not 0)
145 |     assert data[-1] == 199.0  # Last item should be 199
    |                        ^^^^^ PLR2004
    |

tests/test_critical_fixes_implementation.py:169:33: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
    |
167 |     result = sma.update(14.0)
168 |     assert result is not None
169 |     assert abs(result - 12.0) < 0.001  # Mean of 10,11,12,13,14 is 12
    |                                 ^^^^^ PLR2004
170 | 
171 |     # Test EMA
    |

tests/test_critical_fixes_implementation.py:187:35: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
186 |     assert rsi.is_initialized
187 |     assert 0 <= rsi.last_value <= 100
    |                                   ^^^ PLR2004
    |

tests/test_critical_fixes_implementation.py:259:40: F821 Undefined name `MockConfigManager`
    |
257 |     # Mock implementation
258 |     # Register implementation
259 |     container.register(IConfigManager, MockConfigManager)
    |                                        ^^^^^^^^^^^^^^^^^ F821
260 | 
261 |     # Resolve implementation
    |

tests/test_critical_fixes_implementation.py:263:39: F821 Undefined name `MockConfigManager`
    |
261 |     # Resolve implementation
262 |     config_manager = container.resolve(IConfigManager)
263 |     assert isinstance(config_manager, MockConfigManager)
    |                                       ^^^^^^^^^^^^^^^^^ F821
264 |     assert config_manager.get("test") == "mock_test"
    |

tests/test_critical_fixes_implementation.py:267:40: F821 Undefined name `MockConfigManager`
    |
266 |     # Test singleton
267 |     container.register(IConfigManager, MockConfigManager, singleton=True)
    |                                        ^^^^^^^^^^^^^^^^^ F821
268 |     instance1 = container.resolve(IConfigManager)
269 |     instance2 = container.resolve(IConfigManager)
    |

tests/test_critical_fixes_implementation.py:293:41: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
291 |     # Check performance stats
292 |     stats = manager.get_performance_stats()
293 |     assert stats['total_indicators'] == 2
    |                                         ^ PLR2004
294 |     assert stats['total_calculations'] > 0
    |

tests/test_critical_fixes_simple.py:34:35: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
   |
33 |     # Fixed logic - ensure minimum position size when cash available
34 |     if raw_qty <= 0 and balance > 1000 and target_weight > 0.001 and current_price > 0:
   |                                   ^^^^ PLR2004
35 |         raw_qty = max(1, int(1000 / current_price))  # Minimum $1000 position
   |

tests/test_critical_fixes_simple.py:34:60: PLR2004 Magic value used in comparison, consider replacing `0.001` with a constant variable
   |
33 |     # Fixed logic - ensure minimum position size when cash available
34 |     if raw_qty <= 0 and balance > 1000 and target_weight > 0.001 and current_price > 0:
   |                                                            ^^^^^ PLR2004
35 |         raw_qty = max(1, int(1000 / current_price))  # Minimum $1000 position
   |

tests/test_critical_fixes_simple.py:71:31: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
70 |     # Should have 3 valid rows (invalid row should be filtered out)
71 |     assert len(valid_rows) == 3, f"Should have 3 valid price rows, got {len(valid_rows)}"
   |                               ^ PLR2004
72 |     assert all(row['entry_price'] > 0 for row in valid_rows), "All entry prices should be positive"
73 |     assert all(row['exit_price'] > 0 for row in valid_rows), "All exit prices should be positive"
   |

tests/test_critical_fixes_simple.py:85:27: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
   |
84 |     # Fixed logic - allow minimum position with sufficient cash
85 |     if liquidity_factor < 0.2:
   |                           ^^^ PLR2004
86 |         if cash > 5000:
87 |             # Use minimum viable position
   |

tests/test_critical_fixes_simple.py:86:19: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
   |
84 |     # Fixed logic - allow minimum position with sufficient cash
85 |     if liquidity_factor < 0.2:
86 |         if cash > 5000:
   |                   ^^^^ PLR2004
87 |             # Use minimum viable position
88 |             result = max(1, int(1000 / price)) if price > 0 else 1
   |

tests/test_critical_issues_resolution.py:50:16: BLE001 Do not catch blind exception: `Exception`
   |
48 |             order.add_fill(1, Money(150.0))
49 |             self.assertTrue(order.is_partially_filled)
50 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
51 |             self.fail(f"Partial fill handling failed: {e}")
   |

tests/test_critical_issues_resolution.py:92:16: BLE001 Do not catch blind exception: `Exception`
   |
90 |                 fallback_result = {'status': 'fallback_active', 'reason': 'insufficient_data'}
91 |                 self.assertEqual(fallback_result['status'], 'fallback_active')
92 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
93 |             self.fail(f"Fallback mechanism should not raise exceptions: {e}")
   |

tests/test_critical_issues_resolution.py:100:31: PLR2004 Magic value used in comparison, consider replacing `429` with a constant variable
    |
 98 |         def mock_sentiment_with_rate_limit(ticker, status_code=200):
 99 |             """Simulate sentiment fetch with different response codes."""
100 |             if status_code == 429:
    |                               ^^^ PLR2004
101 |                 # Rate limited - should return neutral and cache
102 |                 return 0.0
    |

tests/test_critical_issues_resolution.py:103:33: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
101 |                 # Rate limited - should return neutral and cache
102 |                 return 0.0
103 |             elif status_code == 200:
    |                                 ^^^ PLR2004
104 |                 # Normal response
105 |                 return 0.5
    |

tests/test_critical_issues_resolution.py:167:16: BLE001 Do not catch blind exception: `Exception`
    |
165 |             self.assertIsInstance(spacing, float, "Order spacing should return float")
166 |             self.assertGreaterEqual(spacing, 0, "Order spacing should be non-negative")
167 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
168 |             self.fail(f"RiskEngine order spacing test failed: {e}")
    |

tests/test_critical_trading_fixes.py:28:8: BLE001 Do not catch blind exception: `Exception`
   |
26 | try:
27 |     from ai_trading.analysis import sentiment
28 | except Exception:  # pragma: no cover - optional torch dependency
   |        ^^^^^^^^^ BLE001
29 |     pytest.skip("sentiment module unavailable", allow_module_level=True)
30 | from ai_trading import config, meta_learning
   |

tests/test_critical_trading_fixes.py:124:46: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
122 |         # Should return discounted sentiment from similar symbol
123 |         self.assertIsNotNone(result)
124 |         self.assertTrue(abs(result - 0.64) < 0.1)  # 0.8 * 0.8 = 0.64
    |                                              ^^^ PLR2004
125 | 
126 |     def test_sector_sentiment_proxy(self):
    |

tests/test_critical_trading_fixes.py:136:45: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
134 |         # Should return discounted sentiment from sector
135 |         self.assertIsNotNone(result)
136 |         self.assertTrue(abs(result - 0.3) < 0.1)  # 0.5 * 0.6 = 0.3
    |                                             ^^^ PLR2004
    |

tests/test_critical_trading_fixes.py:207:20: BLE001 Do not catch blind exception: `Exception`
    |
205 |                 meta_learning._generate_bootstrap_training_data(self.trade_log_path, 10)
206 |                 success = True
207 |             except Exception:
    |                    ^^^^^^^^^ BLE001
208 |                 success = False
    |

tests/test_critical_trading_fixes.py:487:47: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
485 |         assert quality_report['file_exists'] is True
486 |         assert quality_report['has_valid_format'] is True
487 |         assert quality_report['row_count'] == 3
    |                                               ^ PLR2004
488 |         assert quality_report['valid_price_rows'] == 2  # Should filter out negative price
489 |     finally:
    |

tests/test_critical_trading_fixes.py:488:54: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
486 |         assert quality_report['has_valid_format'] is True
487 |         assert quality_report['row_count'] == 3
488 |         assert quality_report['valid_price_rows'] == 2  # Should filter out negative price
    |                                                      ^ PLR2004
489 |     finally:
490 |         os.unlink(tmp_path)
    |

tests/test_critical_trading_fixes.py:651:52: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
649 |         assert integrity_report['valid_format'] is True
650 |         assert integrity_report['data_consistent'] is True
651 |         assert integrity_report['total_trades'] == 2
    |                                                    ^ PLR2004
652 |         assert integrity_report['integrity_score'] >= 0.9
653 |     finally:
    |

tests/test_critical_trading_fixes.py:652:55: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
650 |         assert integrity_report['data_consistent'] is True
651 |         assert integrity_report['total_trades'] == 2
652 |         assert integrity_report['integrity_score'] >= 0.9
    |                                                       ^^^ PLR2004
653 |     finally:
654 |         os.unlink(tmp_path)
    |

tests/test_critical_trading_fixes.py:695:54: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
693 |         assert integrity_report['data_consistent'] is False
694 |         assert len(integrity_report['corrupted_rows']) >= 1
695 |         assert integrity_report['integrity_score'] < 0.9
    |                                                      ^^^ PLR2004
696 |     finally:
697 |         os.unlink(tmp_path)
    |

tests/test_critical_trading_fixes.py:753:20: BLE001 Do not catch blind exception: `Exception`
    |
751 |             try:
752 |                 retrain_meta_learner(trade_log_path=tmp_path, min_samples=1)
753 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
754 |                 # Training may fail due to missing sklearn, but that's OK for this test
755 |                 mock_logger.warning.call_args_list.append(f"Meta learning training failed as expected: {e}")
    |

tests/test_critical_trading_issues.py:295:25: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
293 |             spread = 0.10
294 | 
295 |             if spread > 0.05:
    |                         ^^^^ PLR2004
296 |                 slice_qty = min(int(vol * pct * 0.5), total_qty)  # Reduced by 50%
297 |             else:
    |

tests/test_daily_bars_datetime_sanitization.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | from datetime import UTC, datetime, timedelta
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | from ai_trading.core import bot_engine as be
 8 | | 
 9 | | 
10 | | def test_daily_request_sanitizes_inputs(monkeypatch):
   | |_^ I001
11 |       fetcher = be.DataFetcher()
12 |       symbol = "SPY"
   |
   = help: Organize imports

tests/test_daily_bars_datetime_sanitization.py:54:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
52 |     result = fetcher.get_daily_df(object(), symbol)
53 | 
54 |     assert calls["n"] == 2
   |                          ^ PLR2004
55 |     assert result is None
   |

tests/test_daily_sanitization_retry.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | import ai_trading.core.bot_engine as be_mod
 6 | | from ai_trading.core.bot_engine import DataFetcher
 7 | | 
 8 | | 
 9 | | def test_daily_retry_handles_callable(monkeypatch):
   | |_^ I001
10 |       # AI-AGENT-REF: ensure callable retry sanitization
11 |       calls = {"n": 0}
   |
   = help: Organize imports

tests/test_daily_sanitization_retry.py:39:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
38 |     df = DataFetcher().get_daily_df(None, "SPY")
39 |     assert calls["n"] == 2
   |                          ^ PLR2004
40 |     assert df is not None
   |

tests/test_daily_sanitize_debug.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | import types
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | from ai_trading.core import bot_engine as be
 8 | | 
 9 | | 
10 | | def test_callable_triggers_single_debug(monkeypatch, caplog):
   | |_^ I001
11 |       caplog.set_level("DEBUG")
   |
   = help: Organize imports

tests/test_data_cache.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import time
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading.market import cache as mcache
 6 | | 
 7 | | 
 8 | | def test_mem_cache_ttl_basic(tmp_path):
   | |_^ I001
 9 |       df = pd.DataFrame({"timestamp":[1], "open":[1], "high":[1], "low":[1], "close":[1], "volume":[1]})
10 |       mcache.put_mem("AAPL", "1D", "2024-01-01", "2024-01-31", df)
   |
   = help: Organize imports

tests/test_data_fetch.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import os
 2 | | from datetime import UTC, datetime
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading.alpaca_api import _bars_time_window, get_bars_df  # AI-AGENT-REF
 7 | | from ai_trading.utils.optional_import import optional_import
 8 | | 
 9 | | alpaca = optional_import("alpaca_trade_api")
   | |_^ I001
10 |   TimeFrame = optional_import("alpaca_trade_api.rest", "TimeFrame")
   |
   = help: Organize imports

tests/test_data_fetch.py:32:34: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
30 |     e_dt = datetime.fromisoformat(end.replace("Z", "+00:00"))
31 |     assert e_dt <= datetime.now(UTC)
32 |     assert (e_dt - s_dt).days >= 10
   |                                  ^^ PLR2004
   |

tests/test_data_fetcher.py:86:1: E402 Module level import not at top of file
   |
84 | sys.modules["finnhub"].FinnhubAPIException = _DummyFinnhubException
85 | 
86 | from ai_trading import data_fetcher
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_data_fetcher.py:233:1: E402 Module level import not at top of file
    |
232 | # AI-AGENT-REF: Replaced unsafe _raise_dynamic_exec_disabled() with direct import from core module
233 | from ai_trading.core.bot_engine import fetch_minute_df_safe
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
    |

tests/test_data_fetcher_canonicalization.py:29:58: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
27 |     start_u, end_u = nyse_session_utc(d)
28 |     payload = df._format_fallback_payload_df("1Min", "iex", start_u, end_u)
29 |     assert isinstance(payload, list) and len(payload) == 4
   |                                                          ^ PLR2004
30 |     tf, feed, s, e = payload
31 |     assert tf == "1Min"
   |

tests/test_data_fetcher_extended.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime
 2 | | import types
 3 | | 
 4 | | import pandas as pd
 5 | | import pytest
 6 | | 
 7 | | from ai_trading import data_fetcher
 8 | | 
 9 | | 
10 | | class DummyClient:
   | |_^ I001
11 |       def __init__(self, df):
12 |           self.df = df
   |
   = help: Organize imports

tests/test_data_fetcher_extended.py:59:13: DTZ011 `datetime.date.today()` used
   |
57 | def test_get_minute_df_market_closed(monkeypatch):
58 |     monkeypatch.setattr(data_fetcher, "is_market_open", lambda: False)
59 |     today = datetime.date.today()
   |             ^^^^^^^^^^^^^^^^^^^^^ DTZ011
60 |     result = data_fetcher.get_minute_df("AAPL", today, today)
61 |     assert result.empty
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_data_fetcher_extended.py:81:50: DTZ011 `datetime.date.today()` used
   |
79 |     monkeypatch.setattr(data_fetcher, "is_market_open", lambda: True)
80 |     with pytest.raises(ValueError):
81 |         data_fetcher.get_minute_df("AAPL", None, datetime.date.today())
   |                                                  ^^^^^^^^^^^^^^^^^^^^^ DTZ011
82 |     with pytest.raises(TypeError):
83 |         data_fetcher.get_minute_df("AAPL", 123, datetime.date.today())
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_data_fetcher_extended.py:83:49: DTZ011 `datetime.date.today()` used
   |
81 |         data_fetcher.get_minute_df("AAPL", None, datetime.date.today())
82 |     with pytest.raises(TypeError):
83 |         data_fetcher.get_minute_df("AAPL", 123, datetime.date.today())
   |                                                 ^^^^^^^^^^^^^^^^^^^^^ DTZ011
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_data_fetcher_fallbacks.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime as dt
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading import data_fetcher as dfetch
 6 | | 
 7 | | 
 8 | | def _fake_yf(symbol, period=None, start=None, end=None, interval="1m", **_):
   | |_^ I001
 9 |       idx = pd.date_range(end=dt.datetime.now(dt.UTC), periods=5, freq="1min")
10 |       return pd.DataFrame(
   |
   = help: Organize imports

tests/test_data_fetcher_timezone.py:42:34: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
40 |     _install_fake_yf(monkeypatch)
41 | 
42 |     df1 = _yahoo_get_bars("SPY", datetime(2025, 8, 1), datetime(2025, 8, 10), "1Day")
   |                                  ^^^^^^^^^^^^^^^^^^^^ DTZ001
43 |     assert not df1.empty and df1["timestamp"].dt.tz is not None
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_data_fetcher_timezone.py:42:56: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
40 |     _install_fake_yf(monkeypatch)
41 | 
42 |     df1 = _yahoo_get_bars("SPY", datetime(2025, 8, 1), datetime(2025, 8, 10), "1Day")
   |                                                        ^^^^^^^^^^^^^^^^^^^^^ DTZ001
43 |     assert not df1.empty and df1["timestamp"].dt.tz is not None
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_data_pipeline.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.features import compute_macd, compute_macds, ensure_columns
4 | | 
5 | | 
6 | | def test_macd_pipeline_produces_macds():
  | |_^ I001
7 |       df = pd.DataFrame(
8 |           {
  |
  = help: Organize imports

tests/test_datetime_wrappers.py:10:16: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
 8 | def test_naive_et_is_converted_to_utc():
 9 |     # AI-AGENT-REF: naive ET → UTC conversion
10 |     et_naive = datetime(2025, 8, 20, 9, 30)  # intended ET naive
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
11 |     dt_utc = ensure_datetime(et_naive)
12 |     assert dt_utc.tzinfo is UTC
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_datetime_wrappers.py:13:27: PLR2004 Magic value used in comparison, consider replacing `13` with a constant variable
   |
11 |     dt_utc = ensure_datetime(et_naive)
12 |     assert dt_utc.tzinfo is UTC
13 |     assert dt_utc.hour == 13 and dt_utc.minute == 30
   |                           ^^ PLR2004
   |

tests/test_datetime_wrappers.py:13:51: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
11 |     dt_utc = ensure_datetime(et_naive)
12 |     assert dt_utc.tzinfo is UTC
13 |     assert dt_utc.hour == 13 and dt_utc.minute == 30
   |                                                   ^^ PLR2004
   |

tests/test_datetime_wrappers.py:18:38: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
16 | def test_callable_is_unwrapped():
17 |     # AI-AGENT-REF: callable handling
18 |     dt_utc = ensure_datetime(lambda: datetime(2025, 8, 20, 9, 30))
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
19 |     assert dt_utc.tzinfo is UTC
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_deprecation_warnings.py:43:1: I001 [*] Import block is un-sorted or un-formatted
   |
41 |       with warnings.catch_warnings(record=True) as w:
42 |           warnings.simplefilter("always")
43 | /         from ai_trading import alpaca_api  # noqa: F401  # AI-AGENT-REF: canonical import
44 | | 
   | |_^ I001
45 |           # Ensure no deprecation warning is raised for packaged import
46 |           assert not w
   |
   = help: Organize imports

tests/test_dual_schema_credentials.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |   
 8 | / import os
 9 | | from unittest.mock import patch
10 | | 
11 | | import pytest
12 | | 
13 | | from ai_trading.config.management import (
14 | |     _resolve_alpaca_env,
15 | |     _warn_duplicate_env_keys,
16 | |     validate_alpaca_credentials,
17 | | )
18 | | 
19 | | 
20 | | class TestDualSchemaCredentials:
   | |_^ I001
21 |       """Test dual credential schema support."""
   |
   = help: Organize imports

tests/test_dynamic_position_sizing.py:46:20: PLR2004 Magic value used in comparison, consider replacing `4000.0` with a constant variable
   |
44 |         size, meta = resolve_max_position_size(cfg, tcfg, force_refresh=True)
45 | 
46 |     assert size == 4000.0
   |                    ^^^^^^ PLR2004
47 |     assert meta["source"] in {"alpaca", "cache"}
   |

tests/test_dynamic_position_sizing.py:69:20: PLR2004 Magic value used in comparison, consider replacing `9000.0` with a constant variable
   |
67 |         size, meta = resolve_max_position_size(cfg, tcfg, force_refresh=True)
68 | 
69 |     assert size == 9000.0
   |                    ^^^^^^ PLR2004
70 |     assert meta["source"] == "fallback"
   |

tests/test_emit_once_logger.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Tests for EmitOnceLogger functionality."""
 2 |   
 3 | / import logging
 4 | | from io import StringIO
 5 | | 
 6 | | import pytest
 7 | | 
 8 | | from ai_trading.logging import EmitOnceLogger
 9 | | 
10 | | 
11 | | @pytest.fixture
   | |_^ I001
12 |   def logger_with_capture():
13 |       """Create a logger that captures output to a string."""
   |
   = help: Organize imports

tests/test_empty_policy.py:10:31: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
 9 | def test_classify_levels() -> None:
10 |     assert classify(False) == 20  # INFO
   |                               ^^ PLR2004
11 |     assert classify(True) == 30   # WARNING
   |

tests/test_empty_policy.py:11:30: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
 9 | def test_classify_levels() -> None:
10 |     assert classify(False) == 20  # INFO
11 |     assert classify(True) == 30   # WARNING
   |                              ^^ PLR2004
   |

tests/test_enhanced_signals.py:6:8: BLE001 Do not catch blind exception: `Exception`
  |
4 | try:
5 |     import ai_trading.risk.engine as risk_engine  # AI-AGENT-REF: normalized import
6 | except Exception:  # pragma: no cover - optional dependency
  |        ^^^^^^^^^ BLE001
7 |     import pytest
8 |     pytest.skip("risk_engine not available", allow_module_level=True)
  |

tests/test_ensure_utc.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from datetime import UTC, date, datetime
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading.data.timeutils import ensure_utc_datetime
 6 | | 
 7 | | 
 8 | | def test_reject_callable():
   | |_^ I001
 9 |       with pytest.raises(TypeError):
10 |           ensure_utc_datetime(lambda: None)
   |
   = help: Organize imports

tests/test_ensure_utc.py:14:30: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
13 | def test_datetime_naive_to_utc():
14 |     dt = ensure_utc_datetime(datetime(2025, 8, 20, 12, 0, 0))
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
15 |     assert dt.tzinfo == UTC
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_ensure_utc_datetime_callables.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from datetime import UTC, datetime
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading.data.timeutils import ensure_utc_datetime
 6 | | 
 7 | | 
 8 | | def test_callable_rejected():
   | |_^ I001
 9 |       def cb():
10 |           return datetime.now(UTC)
   |
   = help: Organize imports

tests/test_env_order_and_lazy_import.py:226:20: BLE001 Do not catch blind exception: `Exception`
    |
224 |                 # If we get here, import succeeded despite missing .env
225 |                 assert True
226 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
227 |                 pytest.fail(f"Import failed with missing .env file: {e}")
    |

tests/test_execution_classes.py:32:35: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
30 |         assert result.symbol == "AAPL"
31 |         assert result.side == "buy"
32 |         assert result.quantity == 100
   |                                   ^^^ PLR2004
33 |         assert result.fill_price == 150.0
34 |         assert result.message == "Order filled successfully"
   |

tests/test_execution_classes.py:33:37: PLR2004 Magic value used in comparison, consider replacing `150.0` with a constant variable
   |
31 |         assert result.side == "buy"
32 |         assert result.quantity == 100
33 |         assert result.fill_price == 150.0
   |                                     ^^^^^ PLR2004
34 |         assert result.message == "Order filled successfully"
35 |         assert result.is_successful is True
   |

tests/test_execution_classes.py:89:43: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
   |
87 |         assert result_dict["symbol"] == "TSLA"
88 |         assert result_dict["side"] == "buy"
89 |         assert result_dict["quantity"] == 25
   |                                           ^^ PLR2004
90 |         assert result_dict["fill_price"] == 800.0
91 |         assert result_dict["actual_slippage_bps"] == 5.2
   |

tests/test_execution_classes.py:90:45: PLR2004 Magic value used in comparison, consider replacing `800.0` with a constant variable
   |
88 |         assert result_dict["side"] == "buy"
89 |         assert result_dict["quantity"] == 25
90 |         assert result_dict["fill_price"] == 800.0
   |                                             ^^^^^ PLR2004
91 |         assert result_dict["actual_slippage_bps"] == 5.2
92 |         assert result_dict["notional_value"] == 20000.0
   |

tests/test_execution_classes.py:91:54: PLR2004 Magic value used in comparison, consider replacing `5.2` with a constant variable
   |
89 |         assert result_dict["quantity"] == 25
90 |         assert result_dict["fill_price"] == 800.0
91 |         assert result_dict["actual_slippage_bps"] == 5.2
   |                                                      ^^^ PLR2004
92 |         assert result_dict["notional_value"] == 20000.0
93 |         assert result_dict["is_successful"] is True
   |

tests/test_execution_classes.py:92:49: PLR2004 Magic value used in comparison, consider replacing `20000.0` with a constant variable
   |
90 |         assert result_dict["fill_price"] == 800.0
91 |         assert result_dict["actual_slippage_bps"] == 5.2
92 |         assert result_dict["notional_value"] == 20000.0
   |                                                 ^^^^^^^ PLR2004
93 |         assert result_dict["is_successful"] is True
94 |         assert result_dict["is_failed"] is False
   |

tests/test_execution_classes.py:129:36: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
127 |         assert request.symbol == "AAPL"
128 |         assert request.side == OrderSide.BUY
129 |         assert request.quantity == 100
    |                                    ^^^ PLR2004
130 |         assert request.order_type == OrderType.MARKET
131 |         assert request.strategy == "test_strategy"
    |

tests/test_execution_classes.py:146:33: PLR2004 Magic value used in comparison, consider replacing `300.0` with a constant variable
    |
145 |         assert request.order_type == OrderType.LIMIT
146 |         assert request.price == 300.0
    |                                 ^^^^^ PLR2004
147 |         assert request.is_valid is True
    |

tests/test_execution_classes.py:208:42: PLR2004 Magic value used in comparison, consider replacing `15000.0` with a constant variable
    |
206 |         )
207 | 
208 |         assert request.notional_value == 15000.0  # 100 * 150.0
    |                                          ^^^^^^^ PLR2004
209 | 
210 |     def test_order_request_to_dict(self):
    |

tests/test_execution_classes.py:227:44: PLR2004 Magic value used in comparison, consider replacing `25` with a constant variable
    |
225 |         assert request_dict["symbol"] == "GOOGL"
226 |         assert request_dict["side"] == "sell"
227 |         assert request_dict["quantity"] == 25
    |                                            ^^ PLR2004
228 |         assert request_dict["order_type"] == "limit"
229 |         assert request_dict["price"] == 2800.0
    |

tests/test_execution_classes.py:229:41: PLR2004 Magic value used in comparison, consider replacing `2800.0` with a constant variable
    |
227 |         assert request_dict["quantity"] == 25
228 |         assert request_dict["order_type"] == "limit"
229 |         assert request_dict["price"] == 2800.0
    |                                         ^^^^^^ PLR2004
230 |         assert request_dict["strategy"] == "momentum"
231 |         assert request_dict["time_in_force"] == "GTC"
    |

tests/test_execution_classes.py:268:33: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
    |
266 |         assert copy.side == original.side
267 |         assert copy.order_type == original.order_type
268 |         assert copy.quantity == 200  # Updated
    |                                 ^^^ PLR2004
269 |         assert copy.strategy == "new_strategy"  # Updated
270 |         assert copy.client_order_id != original.client_order_id  # Should be different
    |

tests/test_executors_sizing.py:49:29: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   |
47 |     _pred_workers = _pred_env or max(2, min(4, _cpu))
48 | 
49 |     assert _exec_workers == 6
   |                             ^ PLR2004
50 |     assert _pred_workers == 3
   |

tests/test_executors_sizing.py:50:29: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
49 |     assert _exec_workers == 6
50 |     assert _pred_workers == 3
   |                             ^ PLR2004
51 | 
52 |     # Clean up
   |

tests/test_executors_sizing.py:102:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
100 |         _pred_workers = _pred_env or max(2, min(4, _cpu))
101 | 
102 |         assert _exec_workers == 2  # Fallback to 2
    |                                 ^ PLR2004
103 |         assert _pred_workers == 2  # Fallback to 2
    |

tests/test_executors_sizing.py:103:33: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
102 |         assert _exec_workers == 2  # Fallback to 2
103 |         assert _pred_workers == 2  # Fallback to 2
    |                                 ^ PLR2004
    |

tests/test_fallback_concurrency.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import threading
 2 | | import time
 3 | | import types
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | import ai_trading.core.bot_engine as be
 8 | | 
 9 | | 
10 | | def _mk_df():
   | |_^ I001
11 |       return pd.DataFrame(
12 |           {
   |
   = help: Organize imports

tests/test_fallback_concurrency.py:66:36: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
   |
64 |     # Should complete faster than sequential (0.4s) due to parallelism
65 |     # Allow some overhead but should be significantly faster than sequential
66 |     assert end_time - start_time < 0.3, f"Parallel execution took {end_time - start_time:.2f}s, expected < 0.3s"
   |                                    ^^^ PLR2004
67 |     assert len(out) == 4
   |

tests/test_fallback_concurrency.py:67:24: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
65 |     # Allow some overhead but should be significantly faster than sequential
66 |     assert end_time - start_time < 0.3, f"Parallel execution took {end_time - start_time:.2f}s, expected < 0.3s"
67 |     assert len(out) == 4
   |                        ^ PLR2004
68 | 
69 |     # Verify calls happened in a parallel timeframe (not perfectly sequential)
   |

tests/test_fallback_concurrency.py:76:24: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
75 |     # Should be less than sequential time but account for overlap
76 |     assert time_span < 0.25, f"Call time span {time_span:.2f}s suggests sequential execution"
   |                        ^^^^ PLR2004
77 | 
78 | def test_bounded_concurrency_respects_limit(monkeypatch):
   |

tests/test_fallback_concurrency.py:109:24: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
    |
107 |     out = be._fetch_universe_bars(ctx, ["A","B","C","D","E","F"], "1D", "2024-01-01", "2024-02-01", None)
108 | 
109 |     assert len(out) == 6
    |                        ^ PLR2004
110 |     # Should never exceed our worker limit
111 |     assert max_concurrent <= 2, f"Max concurrent workers {max_concurrent} exceeded limit of 2"
    |

tests/test_fallback_concurrency.py:111:30: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
109 |     assert len(out) == 6
110 |     # Should never exceed our worker limit
111 |     assert max_concurrent <= 2, f"Max concurrent workers {max_concurrent} exceeded limit of 2"
    |                              ^ PLR2004
    |

tests/test_fallback_logging_payload.py:17:58: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
15 |     start_u, end_u = nyse_session_utc(d)
16 |     payload = _format_fallback_payload("1Min", "iex", start_u, end_u)
17 |     assert isinstance(payload, list) and len(payload) == 4
   |                                                          ^ PLR2004
18 |     tf, feed, s, e = payload
19 |     assert tf == "1Min"
   |

tests/test_features.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import sys
 2 | | import types
 3 | | 
 4 | | import pandas as pd
 5 | | import pytest
 6 | | 
 7 | | from ai_trading.features import build_features_pipeline
 8 | | 
 9 | | dotenv_stub = types.ModuleType("dotenv")
   | |_^ I001
10 |   dotenv_stub.load_dotenv = lambda *a, **k: None
11 |   sys.modules.setdefault("dotenv", dotenv_stub)
   |
   = help: Organize imports

tests/test_features.py:28:1: E402 Module level import not at top of file
   |
26 | pytestmark = pytest.mark.usefixtures("default_env", "features_env")
27 | 
28 | import pytest
   | ^^^^^^^^^^^^^ E402
   |

tests/test_features.py:59:26: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
57 |     assert not df[['macd', 'macds', 'atr', 'vwap']].isnull().all().any(), "Indicators have all NaNs"
58 |     na_counts = df[['macd', 'atr', 'vwap', 'macds']].isna().sum()
59 |     assert (na_counts <= 20).all(), f"Excessive NaNs in features: {na_counts}"
   |                          ^^ PLR2004
   |

tests/test_fetch_and_screen.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime as dt
 2 | | import sys
 3 | | import types
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | from ai_trading import data_fetcher
 8 | | from ai_trading.utils.base import health_check
 9 | | 
10 | | 
11 | | def _stub_df():
   | |_^ I001
12 |       index = pd.date_range(start="2024-01-01 09:30", periods=120, freq="min", tz="UTC")
13 |       return pd.DataFrame({
   |
   = help: Organize imports

tests/test_fetch_and_screen.py:33:49: DTZ011 `datetime.date.today()` used
   |
32 |     types.SimpleNamespace(data_fetcher=data_fetcher)
33 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
   |                                                 ^^^^^^^^^^^^^^^ DTZ011
34 |     if result is None:
35 |         result = data_fetcher.get_daily_df("AAPL", dt.date.today(), dt.date.today())
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_and_screen.py:33:66: DTZ011 `datetime.date.today()` used
   |
32 |     types.SimpleNamespace(data_fetcher=data_fetcher)
33 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
   |                                                                  ^^^^^^^^^^^^^^^ DTZ011
34 |     if result is None:
35 |         result = data_fetcher.get_daily_df("AAPL", dt.date.today(), dt.date.today())
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_and_screen.py:35:52: DTZ011 `datetime.date.today()` used
   |
33 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
34 |     if result is None:
35 |         result = data_fetcher.get_daily_df("AAPL", dt.date.today(), dt.date.today())
   |                                                    ^^^^^^^^^^^^^^^ DTZ011
36 |     assert health_check(result, "minute")
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_and_screen.py:35:69: DTZ011 `datetime.date.today()` used
   |
33 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
34 |     if result is None:
35 |         result = data_fetcher.get_daily_df("AAPL", dt.date.today(), dt.date.today())
   |                                                                     ^^^^^^^^^^^^^^^ DTZ011
36 |     assert health_check(result, "minute")
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_and_screen.py:42:49: DTZ011 `datetime.date.today()` used
   |
40 |     df = _stub_df()
41 |     monkeypatch.setattr(data_fetcher, "get_minute_df", lambda *a, **k: df)
42 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
   |                                                 ^^^^^^^^^^^^^^^ DTZ011
43 |     assert health_check(result, "minute")
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_and_screen.py:42:66: DTZ011 `datetime.date.today()` used
   |
40 |     df = _stub_df()
41 |     monkeypatch.setattr(data_fetcher, "get_minute_df", lambda *a, **k: df)
42 |     result = data_fetcher.get_minute_df("AAPL", dt.date.today(), dt.date.today())
   |                                                                  ^^^^^^^^^^^^^^^ DTZ011
43 |     assert health_check(result, "minute")
   |
   = help: Use `datetime.datetime.now(tz=...).date()` instead

tests/test_fetch_contract.py:15:1: E402 Module level import not at top of file
   |
13 | sys.modules["dotenv"] = dotenv_stub
14 | 
15 | from ai_trading import data_fetcher
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_fetch_sample_universe_cli.py:44:102: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
42 |     ]
43 |     timing = [m for m in logged if m[0] == "STAGE_TIMING"]
44 |     assert timing and timing[0][1]["stage"] == "UNIVERSE_FETCH" and timing[0][1]["universe_size"] == 3
   |                                                                                                      ^ PLR2004
45 |     stats = [m for m in logged if m[0] == "HTTP_POOL_STATS"]
46 |     assert stats and {"workers", "per_host", "pool_maxsize"} <= stats[0][1].keys()
   |

tests/test_fill_rate_calculation_fix.py:19:8: BLE001 Do not catch blind exception: `Exception`
   |
17 | try:
18 |     from ai_trading import ExecutionEngine
19 | except Exception:  # pragma: no cover - optional component
   |        ^^^^^^^^^ BLE001
20 |     pytest.skip("ExecutionEngine not available", allow_module_level=True)
   |

tests/test_fill_rate_calculation_fix.py:27:11: F821 Undefined name `MockContext`
   |
25 |     """Test that fill rate calculation now works correctly when order.filled_qty is None."""
26 | 
27 |     ctx = MockContext()
   |           ^^^^^^^^^^^ F821
28 |     engine = ExecutionEngine(ctx)
   |

tests/test_fill_rate_calculation_fix.py:33:36: F821 Undefined name `MockOrder`
   |
32 |         # Test Case: Order with filled_qty=None (the bug condition that was fixed)
33 |         order_without_filled_qty = MockOrder(filled_qty=None)
   |                                    ^^^^^^^^^ F821
34 | 
35 |         engine._reconcile_partial_fills(
   |

tests/test_fill_rate_calculation_fix.py:51:43: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
50 |         # This should now be 50 filled out of 100 = 50%
51 |         assert log_extra['filled_qty'] == 50, f"Expected filled_qty=50, got {log_extra['filled_qty']}"
   |                                           ^^ PLR2004
52 |         assert log_extra['fill_rate_pct'] == 50.0, f"Expected 50% fill rate, got {log_extra['fill_rate_pct']}"
   |

tests/test_fill_rate_calculation_fix.py:52:46: PLR2004 Magic value used in comparison, consider replacing `50.0` with a constant variable
   |
50 |         # This should now be 50 filled out of 100 = 50%
51 |         assert log_extra['filled_qty'] == 50, f"Expected filled_qty=50, got {log_extra['filled_qty']}"
52 |         assert log_extra['fill_rate_pct'] == 50.0, f"Expected 50% fill rate, got {log_extra['fill_rate_pct']}"
   |                                              ^^^^ PLR2004
   |

tests/test_fill_rate_calculation_fix.py:59:11: F821 Undefined name `MockContext`
   |
57 |     """Test that fill rate alert thresholds are now more realistic for market conditions."""
58 | 
59 |     ctx = MockContext()
   |           ^^^^^^^^^^^ F821
60 |     engine = ExecutionEngine(ctx)
   |

tests/test_fill_rate_calculation_fix.py:65:23: F821 Undefined name `MockOrder`
   |
64 |         # Test 50% fill rate - should NOT trigger any error alerts now
65 |         order_50pct = MockOrder(filled_qty=25)
   |                       ^^^^^^^^^ F821
66 | 
67 |         engine._reconcile_partial_fills(
   |

tests/test_fill_rate_calculation_fix.py:82:23: F821 Undefined name `MockOrder`
   |
80 |         # Test 30% fill rate - should trigger moderate warning but not error
81 |         mock_logger.reset_mock()
82 |         order_30pct = MockOrder(filled_qty=15)
   |                       ^^^^^^^^^ F821
83 | 
84 |         engine._reconcile_partial_fills(
   |

tests/test_fill_rate_calculation_fix.py:99:23: F821 Undefined name `MockOrder`
    |
 97 |         # Test 20% fill rate - should now trigger error-level alert
 98 |         mock_logger.reset_mock()
 99 |         order_20pct = MockOrder(filled_qty=10)
    |                       ^^^^^^^^^ F821
100 | 
101 |         engine._reconcile_partial_fills(
    |

tests/test_fill_rate_calculation_fix.py:119:11: F821 Undefined name `MockContext`
    |
117 |     """Test that fill rate calculation still works when order.filled_qty is properly set."""
118 | 
119 |     ctx = MockContext()
    |           ^^^^^^^^^^^ F821
120 |     engine = ExecutionEngine(ctx)
    |

tests/test_fill_rate_calculation_fix.py:125:33: F821 Undefined name `MockOrder`
    |
124 |         # Test Case: Order with valid filled_qty
125 |         order_with_filled_qty = MockOrder(filled_qty=75)  # 75 out of 100 requested
    |                                 ^^^^^^^^^ F821
126 | 
127 |         engine._reconcile_partial_fills(
    |

tests/test_fill_rate_calculation_fix.py:141:47: PLR2004 Magic value used in comparison, consider replacing `75` with a constant variable
    |
139 |             log_extra = partial_fill_logs[0][1]['extra']
140 |             # Should use order.filled_qty (75) not calculated value (75)
141 |             assert log_extra['filled_qty'] == 75, f"Expected filled_qty=75, got {log_extra['filled_qty']}"
    |                                               ^^ PLR2004
142 |             assert log_extra['fill_rate_pct'] == 75.0, f"Expected 75% fill rate, got {log_extra['fill_rate_pct']}"
    |

tests/test_fill_rate_calculation_fix.py:142:50: PLR2004 Magic value used in comparison, consider replacing `75.0` with a constant variable
    |
140 |             # Should use order.filled_qty (75) not calculated value (75)
141 |             assert log_extra['filled_qty'] == 75, f"Expected filled_qty=75, got {log_extra['filled_qty']}"
142 |             assert log_extra['fill_rate_pct'] == 75.0, f"Expected 75% fill rate, got {log_extra['fill_rate_pct']}"
    |                                                  ^^^^ PLR2004
    |

tests/test_fixes.py:81:16: BLE001 Do not catch blind exception: `Exception`
   |
79 |             else:
80 |                 pass
81 |         except Exception:
   |                ^^^^^^^^^ BLE001
82 |             pass
   |

tests/test_fixes.py:88:12: BLE001 Do not catch blind exception: `Exception`
   |
86 |     except ImportError:
87 |         return False
88 |     except Exception:
   |            ^^^^^^^^^ BLE001
89 |         return False
   |

tests/test_fixes.py:116:12: BLE001 Do not catch blind exception: `Exception`
    |
114 |         return True
115 | 
116 |     except Exception:
    |            ^^^^^^^^^ BLE001
117 |         return False
    |

tests/test_fixes.py:132:16: BLE001 Do not catch blind exception: `Exception`
    |
130 |         try:
131 |             results.append(test())
132 |         except Exception:
    |                ^^^^^^^^^ BLE001
133 |             results.append(False)
    |

tests/test_fixes_minimal.py:48:12: BLE001 Do not catch blind exception: `Exception`
   |
46 |         return True
47 | 
48 |     except Exception:
   |            ^^^^^^^^^ BLE001
49 |         return False
   |

tests/test_fixes_minimal.py:90:12: BLE001 Do not catch blind exception: `Exception`
   |
88 |         return True
89 | 
90 |     except Exception:
   |            ^^^^^^^^^ BLE001
91 |         return False
   |

tests/test_fixes_minimal.py:107:12: BLE001 Do not catch blind exception: `Exception`
    |
105 |         return True
106 | 
107 |     except Exception:
    |            ^^^^^^^^^ BLE001
108 |         return False
    |

tests/test_fixes_minimal.py:131:12: BLE001 Do not catch blind exception: `Exception`
    |
129 |         return True
130 | 
131 |     except Exception:
    |            ^^^^^^^^^ BLE001
132 |         return False
    |

tests/test_fixes_minimal.py:153:12: BLE001 Do not catch blind exception: `Exception`
    |
151 |         return True
152 | 
153 |     except Exception:
    |            ^^^^^^^^^ BLE001
154 |         return False
    |

tests/test_fixes_minimal.py:177:16: BLE001 Do not catch blind exception: `Exception`
    |
175 |             else:
176 |                 failed += 1
177 |         except Exception:
    |                ^^^^^^^^^ BLE001
178 |             failed += 1
    |

tests/test_grid_runner.py:16:31: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
14 |     result = grid_search(evaluator, grid, n_jobs=1)
15 | 
16 |     assert result["count"] == 4  # 2 * 2 combinations
   |                               ^ PLR2004
17 |     assert len(result["results"]) == 4
   |

tests/test_grid_runner.py:17:38: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
16 |     assert result["count"] == 4  # 2 * 2 combinations
17 |     assert len(result["results"]) == 4
   |                                      ^ PLR2004
18 | 
19 |     # Check that all combinations were tested
   |

tests/test_grid_runner.py:49:65: PLR2004 Magic value used in comparison, consider replacing `1.23` with a constant variable
   |
47 |         assert saved_data["count"] == 1
48 |         assert len(saved_data["results"]) == 1
49 |         assert saved_data["results"][0]["metrics"]["sharpe"] == 1.23
   |                                                                 ^^^^ PLR2004
50 | 
51 | def test_grid_search_empty_grid():
   |

tests/test_grid_runner.py:71:31: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
69 |     result = grid_search(evaluator, grid, n_jobs=1)
70 | 
71 |     assert result["count"] == 3
   |                               ^ PLR2004
72 |     values = [r["metrics"]["value"] for r in result["results"]]
73 |     assert sorted(values) == [2, 4, 6]
   |

tests/test_grid_sanity.py:11:33: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   |
 9 |         df = pd.DataFrame({"Sharpe": [0.6]})
10 |     assert "Sharpe" in df.columns, "Missing Sharpe column"
11 |     assert df["Sharpe"].max() > 0.5, "Best Sharpe too low, grid may have failed"
   |                                 ^^^ PLR2004
   |

tests/test_health.py:231:1: E402 Module level import not at top of file
    |
229 | # AI-AGENT-REF: Remove ai_trading.main import that causes deep torch dependency chain
230 | # from ai_trading.main import main  # Not used in this test, causes torch import issues
231 | from ai_trading.core.bot_engine import pre_trade_health_check
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
    |

tests/test_healthcheck_minute_fallback.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import logging
 2 | | from types import SimpleNamespace
 3 | | 
 4 | | import pandas as pd
 5 | | 
 6 | | import ai_trading.data.bars as data_bars
 7 | | from ai_trading import data_fetcher
 8 | | from ai_trading.core import bot_engine
 9 | | 
10 | | 
11 | | def test_minute_fallback_uses_http_yahoo(monkeypatch, caplog):
   | |_^ I001
12 |       ctx = SimpleNamespace()
13 |       ctx.data_fetcher = SimpleNamespace(get_daily_df=lambda ctx, sym: pd.DataFrame())
   |
   = help: Organize imports

tests/test_healthcheck_minute_fallback.py:42:27: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
   |
40 |     assert called.get("called")
41 |     record = next(r for r in caplog.records if "minute fallback ok" in r.message)
42 |     assert record.rows >= 300
   |                           ^^^ PLR2004
43 | 
44 |     # AI-AGENT-REF: ensure no function object leakage in logs
   |

tests/test_healthcheck_minute_fallback_handles_none.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.core.bot_engine import _ensure_df
4 | | 
5 | | 
6 | | def test_ensure_df_none_and_dict():
  | |_^ I001
7 |       assert _ensure_df(None).empty
8 |       d = {"close": [1, 2, 3]}
  |
  = help: Organize imports

tests/test_http_pooling.py:13:29: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
11 |     monkeypatch.delenv("HTTP_MAX_PER_HOST", raising=False)
12 |     st = H.pool_stats()
13 |     assert st["workers"] == 8
   |                             ^ PLR2004
14 |     assert st["per_host"] == 6
15 |     assert st["pool_maxsize"] >= st["workers"]
   |

tests/test_http_pooling.py:14:30: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   |
12 |     st = H.pool_stats()
13 |     assert st["workers"] == 8
14 |     assert st["per_host"] == 6
   |                              ^ PLR2004
15 |     assert st["pool_maxsize"] >= st["workers"]
   |

tests/test_http_pooling.py:25:42: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
23 |     monkeypatch.setenv("HTTP_MAX_PER_HOST", "3")
24 |     _ = H.map_get(["https://example.com"])
25 |     assert H.pool_stats()["per_host"] == 3
   |                                          ^ PLR2004
   |

tests/test_http_timeouts.py:35:32: PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   |
33 |     monkeypatch.setattr(s.session, "get", fake_get)
34 |     s.get("http://localhost/test")
35 |     assert calls["timeout"] == 7, "HTTPSession.get must propagate default timeout"
   |                                ^ PLR2004
   |

tests/test_http_timeouts.py:77:29: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
75 |         "http://localhost/_probe_ok"
76 |     )  # AI-AGENT-REF: trigger plugin default timeout
77 |     assert r.status_code == 200
   |                             ^^^ PLR2004
78 |     assert (
79 |         seen.get("timeout") is not None
   |

tests/test_initial_rebalance.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import datetime
 2 | | import types
 3 | | 
 4 | | import pandas as pd
 5 | | 
 6 | | from ai_trading.core import bot_engine
 7 | | 
 8 | | 
 9 | | class DummyFetcher:
   | |_^ I001
10 |       def get_daily_df(self, ctx, symbol):
11 |           return pd.DataFrame({"close": [100]})
   |
   = help: Organize imports

tests/test_initial_rebalance.py:47:41: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
46 |     bot_engine.initial_rebalance(ctx, ["AAPL"])
47 |     assert ctx.api.positions["AAPL"] == 5
   |                                         ^ PLR2004
48 | 
49 |     bot_engine.initial_rebalance(ctx, ["AAPL"])
   |

tests/test_initial_rebalance.py:51:41: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
49 |     bot_engine.initial_rebalance(ctx, ["AAPL"])
50 |     assert all(o[2] == "buy" for o in ctx.api.orders)
51 |     assert ctx.api.positions["AAPL"] == 10
   |                                         ^^ PLR2004
   |

tests/test_institutional_core.py:71:60: PLR2004 Magic value used in comparison, consider replacing `0.02` with a constant variable
   |
69 |     def test_max_position_size(self):
70 |         """Test maximum position size by risk level."""
71 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
   |                                                            ^^^^ PLR2004
72 |         assert RiskLevel.MODERATE.max_position_size == 0.05
73 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |

tests/test_institutional_core.py:72:56: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
70 |         """Test maximum position size by risk level."""
71 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
72 |         assert RiskLevel.MODERATE.max_position_size == 0.05
   |                                                        ^^^^ PLR2004
73 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |

tests/test_institutional_core.py:73:58: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
   |
71 |         assert RiskLevel.CONSERVATIVE.max_position_size == 0.02
72 |         assert RiskLevel.MODERATE.max_position_size == 0.05
73 |         assert RiskLevel.AGGRESSIVE.max_position_size == 0.10
   |                                                          ^^^^ PLR2004
74 | 
75 |     def test_max_drawdown_threshold(self):
   |

tests/test_institutional_core.py:77:65: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
75 |     def test_max_drawdown_threshold(self):
76 |         """Test maximum drawdown threshold by risk level."""
77 |         assert RiskLevel.CONSERVATIVE.max_drawdown_threshold == 0.05
   |                                                                 ^^^^ PLR2004
78 |         assert RiskLevel.MODERATE.max_drawdown_threshold == 0.10
79 |         assert RiskLevel.AGGRESSIVE.max_drawdown_threshold == 0.15
   |

tests/test_institutional_core.py:78:61: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
   |
76 |         """Test maximum drawdown threshold by risk level."""
77 |         assert RiskLevel.CONSERVATIVE.max_drawdown_threshold == 0.05
78 |         assert RiskLevel.MODERATE.max_drawdown_threshold == 0.10
   |                                                             ^^^^ PLR2004
79 |         assert RiskLevel.AGGRESSIVE.max_drawdown_threshold == 0.15
   |

tests/test_institutional_core.py:79:63: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
77 |         assert RiskLevel.CONSERVATIVE.max_drawdown_threshold == 0.05
78 |         assert RiskLevel.MODERATE.max_drawdown_threshold == 0.10
79 |         assert RiskLevel.AGGRESSIVE.max_drawdown_threshold == 0.15
   |                                                               ^^^^ PLR2004
   |

tests/test_institutional_core.py:93:46: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   |
91 |     def test_timeframe_seconds(self):
92 |         """Test timeframe conversion to seconds."""
93 |         assert TimeFrame.MINUTE_1.seconds == 60
   |                                              ^^ PLR2004
94 |         assert TimeFrame.MINUTE_5.seconds == 300
95 |         assert TimeFrame.HOUR_1.seconds == 3600
   |

tests/test_institutional_core.py:94:46: PLR2004 Magic value used in comparison, consider replacing `300` with a constant variable
   |
92 |         """Test timeframe conversion to seconds."""
93 |         assert TimeFrame.MINUTE_1.seconds == 60
94 |         assert TimeFrame.MINUTE_5.seconds == 300
   |                                              ^^^ PLR2004
95 |         assert TimeFrame.HOUR_1.seconds == 3600
96 |         assert TimeFrame.DAY_1.seconds == 86400
   |

tests/test_institutional_core.py:95:44: PLR2004 Magic value used in comparison, consider replacing `3600` with a constant variable
   |
93 |         assert TimeFrame.MINUTE_1.seconds == 60
94 |         assert TimeFrame.MINUTE_5.seconds == 300
95 |         assert TimeFrame.HOUR_1.seconds == 3600
   |                                            ^^^^ PLR2004
96 |         assert TimeFrame.DAY_1.seconds == 86400
   |

tests/test_institutional_core.py:96:43: PLR2004 Magic value used in comparison, consider replacing `86400` with a constant variable
   |
94 |         assert TimeFrame.MINUTE_5.seconds == 300
95 |         assert TimeFrame.HOUR_1.seconds == 3600
96 |         assert TimeFrame.DAY_1.seconds == 86400
   |                                           ^^^^^ PLR2004
   |

tests/test_institutional_core.py:186:51: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
    |
184 |         # Kelly parameters
185 |         kelly_params = KELLY_PARAMETERS
186 |         assert kelly_params["MIN_SAMPLE_SIZE"] >= 10
    |                                                   ^^ PLR2004
187 |         assert 0 < kelly_params["MAX_KELLY_FRACTION"] <= 1
188 |         assert 0 < kelly_params["CONFIDENCE_LEVEL"] < 1
    |

tests/test_institutional_enhancements.py:429:16: BLE001 Do not catch blind exception: `Exception`
    |
427 |             rebalance_portfolio(ctx)
428 |             enhanced_maybe_rebalance(ctx)
429 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
430 |             self.fail(f"Enhanced rebalancer raised exception: {e}")
    |

tests/test_institutional_kelly.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |   
 8 | / from unittest.mock import patch
 9 | | 
10 | | import pytest
11 | | 
12 | | from ai_trading.core.enums import RiskLevel
13 | | from ai_trading.risk.kelly import KellyCalculator, KellyCriterion
14 | | 
15 | | 
16 | | class TestKellyCriterion:
   | |_^ I001
17 |       """Test Kelly Criterion core functionality."""
   |
   = help: Organize imports

tests/test_institutional_kelly.py:25:46: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
23 |     def test_kelly_initialization(self):
24 |         """Test Kelly Criterion initialization."""
25 |         assert self.kelly.min_sample_size == 10
   |                                              ^^ PLR2004
26 |         assert self.kelly.max_fraction == 0.25
27 |         assert self.kelly.confidence_level == 0.95
   |

tests/test_institutional_kelly.py:26:43: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
24 |         """Test Kelly Criterion initialization."""
25 |         assert self.kelly.min_sample_size == 10
26 |         assert self.kelly.max_fraction == 0.25
   |                                           ^^^^ PLR2004
27 |         assert self.kelly.confidence_level == 0.95
   |

tests/test_institutional_kelly.py:27:47: PLR2004 Magic value used in comparison, consider replacing `0.95` with a constant variable
   |
25 |         assert self.kelly.min_sample_size == 10
26 |         assert self.kelly.max_fraction == 0.25
27 |         assert self.kelly.confidence_level == 0.95
   |                                               ^^^^ PLR2004
28 | 
29 |     def test_basic_kelly_calculation(self):
   |

tests/test_institutional_kelly.py:142:30: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
140 |         # 25% of full Kelly
141 |         fractional = self.kelly.fractional_kelly(full_kelly, 0.25)
142 |         assert fractional == 0.05
    |                              ^^^^ PLR2004
143 | 
144 |         # 50% of full Kelly
    |

tests/test_institutional_kelly.py:146:30: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
144 |         # 50% of full Kelly
145 |         fractional = self.kelly.fractional_kelly(full_kelly, 0.5)
146 |         assert fractional == 0.10
    |                              ^^^^ PLR2004
147 | 
148 |     def test_kelly_with_confidence(self):
    |

tests/test_institutional_kelly.py:177:52: PLR2004 Magic value used in comparison, consider replacing `252` with a constant variable
    |
175 |         """Test Kelly Calculator initialization."""
176 |         assert self.calculator.kelly_criterion is not None
177 |         assert self.calculator.lookback_periods == 252
    |                                                    ^^^ PLR2004
178 |         assert self.calculator.rebalance_frequency == 21
179 |         assert isinstance(self.calculator.calculation_history, list)
    |

tests/test_institutional_kelly.py:178:55: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
    |
176 |         assert self.calculator.kelly_criterion is not None
177 |         assert self.calculator.lookback_periods == 252
178 |         assert self.calculator.rebalance_frequency == 21
    |                                                       ^^ PLR2004
179 |         assert isinstance(self.calculator.calculation_history, list)
    |

tests/test_integration.py:56:12: BLE001 Do not catch blind exception: `Exception`
   |
56 |     except Exception:
   |            ^^^^^^^^^ BLE001
57 |         pass
   |

tests/test_integration.py:67:12: BLE001 Do not catch blind exception: `Exception`
   |
67 |     except Exception:
   |            ^^^^^^^^^ BLE001
68 |         import traceback
69 |         traceback.print_exc()
   |

tests/test_integration_robust.py:15:8: BLE001 Do not catch blind exception: `Exception`
   |
13 | try:
14 |     pass  # type: ignore
15 | except Exception:
   |        ^^^^^^^^^ BLE001
16 |     sys.modules["pandas"] = types.ModuleType("pandas")
17 |     sys.modules["pandas"].DataFrame = MagicMock()
   |

tests/test_integration_robust.py:23:8: BLE001 Do not catch blind exception: `Exception`
   |
21 | try:
22 |     import numpy  # type: ignore  # noqa: F401
23 | except Exception:
   |        ^^^^^^^^^ BLE001
24 |     sys.modules["numpy"] = types.ModuleType("numpy")
25 |     sys.modules["numpy"].array = MagicMock()
   |

tests/test_integration_robust.py:33:8: BLE001 Do not catch blind exception: `Exception`
   |
31 | try:
32 |     import pandas_ta  # type: ignore  # noqa: F401
33 | except Exception:
   |        ^^^^^^^^^ BLE001
34 |     sys.modules["pandas_ta"] = types.ModuleType("pandas_ta")
35 | if "pandas_ta" in sys.modules:
   |

tests/test_integration_robust.py:46:8: BLE001 Do not catch blind exception: `Exception`
   |
44 | try:
45 |     import pandas_market_calendars  # type: ignore  # noqa: F401
46 | except Exception:
   |        ^^^^^^^^^ BLE001
47 |     sys.modules["pandas_market_calendars"] = types.ModuleType("pandas_market_calendars")
48 | if not hasattr(sys.modules["pandas_market_calendars"], "get_calendar"):
   |

tests/test_integration_robust.py:138:1: E402 Module level import not at top of file
    |
136 | sys.modules["alpaca.trading.requests"].MarketOrderRequest = _Req
137 | sys.modules["alpaca.trading.requests"].GetOrdersRequest = _Req
138 | from enum import Enum
    | ^^^^^^^^^^^^^^^^^^^^^ E402
    |

tests/test_integration_robust.py:425:16: BLE001 Do not catch blind exception: `Exception`
    |
423 |         try:
424 |             bot.main()
425 |         except Exception:
    |                ^^^^^^^^^ BLE001
426 |             pytest.fail("Bot should handle NaN signal gracefully")
    |

tests/test_intelligent_position_management.py:96:20: F821 Undefined name `MockPosition`
   |
94 |         """Test the enhanced should_hold_position method."""
95 |         # Create mock position
96 |         position = MockPosition(
   |                    ^^^^^^^^^^^^ F821
97 |             symbol='AAPL',
98 |             qty=100,
   |

tests/test_intelligent_position_management.py:117:20: F821 Undefined name `MockPosition`
    |
115 |     def test_analyze_position_basic(self):
116 |         """Test basic position analysis."""
117 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
118 |             symbol='AAPL',
119 |             qty=100,
    |

tests/test_intelligent_position_management.py:211:28: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
209 |         rsi = self.analyzer._calculate_rsi(prices, 14)
210 |         assert isinstance(rsi, float)
211 |         assert 0 <= rsi <= 100
    |                            ^^^ PLR2004
212 | 
213 |     def test_divergence_detection(self):
    |

tests/test_intelligent_position_management.py:243:20: F821 Undefined name `MockPosition`
    |
241 |     def test_stop_initialization(self):
242 |         """Test trailing stop initialization."""
243 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
244 |             symbol='AAPL',
245 |             qty=100,
    |

tests/test_intelligent_position_management.py:254:44: PLR2004 Magic value used in comparison, consider replacing `110.0` with a constant variable
    |
252 |         assert stop_level is not None
253 |         assert stop_level.symbol == 'AAPL'
254 |         assert stop_level.current_price == 110.0
    |                                            ^^^^^ PLR2004
255 |         assert stop_level.stop_price < 110.0  # Stop should be below current price
    |

tests/test_intelligent_position_management.py:255:40: PLR2004 Magic value used in comparison, consider replacing `110.0` with a constant variable
    |
253 |         assert stop_level.symbol == 'AAPL'
254 |         assert stop_level.current_price == 110.0
255 |         assert stop_level.stop_price < 110.0  # Stop should be below current price
    |                                        ^^^^^ PLR2004
256 | 
257 |     def test_stop_movement(self):
    |

tests/test_intelligent_position_management.py:259:20: F821 Undefined name `MockPosition`
    |
257 |     def test_stop_movement(self):
258 |         """Test that stops move up with price for long positions."""
259 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
260 |             symbol='AAPL',
261 |             qty=100,
    |

tests/test_intelligent_position_management.py:275:39: PLR2004 Magic value used in comparison, consider replacing `115.0` with a constant variable
    |
273 |         # Stop should move up
274 |         assert stop2.stop_price >= initial_stop
275 |         assert stop2.current_price == 115.0
    |                                       ^^^^^ PLR2004
276 | 
277 |     def test_stop_trigger_detection(self):
    |

tests/test_intelligent_position_management.py:279:20: F821 Undefined name `MockPosition`
    |
277 |     def test_stop_trigger_detection(self):
278 |         """Test stop trigger detection."""
279 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
280 |             symbol='AAPL',
281 |             qty=100,
    |

tests/test_intelligent_position_management.py:306:20: F821 Undefined name `MockPosition`
    |
304 |     def test_profit_plan_creation(self):
305 |         """Test profit plan creation."""
306 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
307 |             symbol='AAPL',
308 |             qty=100,
    |

tests/test_intelligent_position_management.py:321:40: PLR2004 Magic value used in comparison, consider replacing `100.0` with a constant variable
    |
319 |         if plan:  # Plan creation might fail due to mocking
320 |             assert plan.symbol == 'AAPL'
321 |             assert plan.entry_price == 100.0
    |                                        ^^^^^ PLR2004
322 |             assert len(plan.targets) > 0
    |

tests/test_intelligent_position_management.py:326:20: F821 Undefined name `MockPosition`
    |
324 |     def test_target_triggering(self):
325 |         """Test profit target triggering."""
326 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
327 |             symbol='AAPL',
328 |             qty=100,
    |

tests/test_intelligent_position_management.py:355:13: F821 Undefined name `MockPosition`
    |
353 |         """Test position data extraction."""
354 |         positions = [
355 |             MockPosition('AAPL', 100, 100.0, 11000.0),
    |             ^^^^^^^^^^^^ F821
356 |             MockPosition('MSFT', 50, 200.0, 10500.0),
357 |             MockPosition('GOOGL', 25, 150.0, 3750.0)
    |

tests/test_intelligent_position_management.py:356:13: F821 Undefined name `MockPosition`
    |
354 |         positions = [
355 |             MockPosition('AAPL', 100, 100.0, 11000.0),
356 |             MockPosition('MSFT', 50, 200.0, 10500.0),
    |             ^^^^^^^^^^^^ F821
357 |             MockPosition('GOOGL', 25, 150.0, 3750.0)
358 |         ]
    |

tests/test_intelligent_position_management.py:357:13: F821 Undefined name `MockPosition`
    |
355 |             MockPosition('AAPL', 100, 100.0, 11000.0),
356 |             MockPosition('MSFT', 50, 200.0, 10500.0),
357 |             MockPosition('GOOGL', 25, 150.0, 3750.0)
    |             ^^^^^^^^^^^^ F821
358 |         ]
    |

tests/test_intelligent_position_management.py:362:38: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
360 |         position_data = self.analyzer._extract_position_data(positions)
361 | 
362 |         assert len(position_data) == 3
    |                                      ^ PLR2004
363 |         assert 'AAPL' in position_data
364 |         assert position_data['AAPL']['market_value'] == 11000.0
    |

tests/test_intelligent_position_management.py:364:57: PLR2004 Magic value used in comparison, consider replacing `11000.0` with a constant variable
    |
362 |         assert len(position_data) == 3
363 |         assert 'AAPL' in position_data
364 |         assert position_data['AAPL']['market_value'] == 11000.0
    |                                                         ^^^^^^^ PLR2004
365 | 
366 |     def test_sector_classification(self):
    |

tests/test_intelligent_position_management.py:377:13: F821 Undefined name `MockPosition`
    |
375 |         """Test concentration level analysis."""
376 |         positions = [
377 |             MockPosition('AAPL', 100, 100.0, 50000.0),  # 50% of portfolio
    |             ^^^^^^^^^^^^ F821
378 |             MockPosition('MSFT', 50, 200.0, 25000.0),   # 25% of portfolio
379 |             MockPosition('GOOGL', 25, 150.0, 25000.0)   # 25% of portfolio
    |

tests/test_intelligent_position_management.py:378:13: F821 Undefined name `MockPosition`
    |
376 |         positions = [
377 |             MockPosition('AAPL', 100, 100.0, 50000.0),  # 50% of portfolio
378 |             MockPosition('MSFT', 50, 200.0, 25000.0),   # 25% of portfolio
    |             ^^^^^^^^^^^^ F821
379 |             MockPosition('GOOGL', 25, 150.0, 25000.0)   # 25% of portfolio
380 |         ]
    |

tests/test_intelligent_position_management.py:379:13: F821 Undefined name `MockPosition`
    |
377 |             MockPosition('AAPL', 100, 100.0, 50000.0),  # 50% of portfolio
378 |             MockPosition('MSFT', 50, 200.0, 25000.0),   # 25% of portfolio
379 |             MockPosition('GOOGL', 25, 150.0, 25000.0)   # 25% of portfolio
    |             ^^^^^^^^^^^^ F821
380 |         ]
    |

tests/test_intelligent_position_management.py:384:44: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
382 |         analysis = self.analyzer.analyze_portfolio(positions)
383 | 
384 |         assert analysis.total_positions == 3
    |                                            ^ PLR2004
385 |         assert analysis.total_value == 100000.0
386 |         assert analysis.concentration_level in [ConcentrationLevel.HIGH, ConcentrationLevel.EXTREME]
    |

tests/test_intelligent_position_management.py:385:40: PLR2004 Magic value used in comparison, consider replacing `100000.0` with a constant variable
    |
384 |         assert analysis.total_positions == 3
385 |         assert analysis.total_value == 100000.0
    |                                        ^^^^^^^^ PLR2004
386 |         assert analysis.concentration_level in [ConcentrationLevel.HIGH, ConcentrationLevel.EXTREME]
    |

tests/test_intelligent_position_management.py:399:20: F821 Undefined name `MockPosition`
    |
397 |     def test_profitable_position_scenario(self):
398 |         """Test scenario with profitable position."""
399 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
400 |             symbol='AAPL',
401 |             qty=100,
    |

tests/test_intelligent_position_management.py:417:20: F821 Undefined name `MockPosition`
    |
415 |     def test_loss_position_scenario(self):
416 |         """Test scenario with losing position."""
417 |         position = MockPosition(
    |                    ^^^^^^^^^^^^ F821
418 |             symbol='AAPL',
419 |             qty=100,
    |

tests/test_intelligent_position_management.py:434:13: F821 Undefined name `MockPosition`
    |
432 |         """Test portfolio-level analysis and recommendations."""
433 |         positions = [
434 |             MockPosition('AAPL', 100, 100.0, 11000.0),
    |             ^^^^^^^^^^^^ F821
435 |             MockPosition('MSFT', 50, 200.0, 10500.0),
436 |             MockPosition('TSLA', 30, 150.0, 4800.0)
    |

tests/test_intelligent_position_management.py:435:13: F821 Undefined name `MockPosition`
    |
433 |         positions = [
434 |             MockPosition('AAPL', 100, 100.0, 11000.0),
435 |             MockPosition('MSFT', 50, 200.0, 10500.0),
    |             ^^^^^^^^^^^^ F821
436 |             MockPosition('TSLA', 30, 150.0, 4800.0)
437 |         ]
    |

tests/test_intelligent_position_management.py:436:13: F821 Undefined name `MockPosition`
    |
434 |             MockPosition('AAPL', 100, 100.0, 11000.0),
435 |             MockPosition('MSFT', 50, 200.0, 10500.0),
436 |             MockPosition('TSLA', 30, 150.0, 4800.0)
    |             ^^^^^^^^^^^^ F821
437 |         ]
    |

tests/test_json_formatter.py:54:12: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
52 |     rec = _make_record(
53 |         arr=np.array([1, 2, 3]),
54 |         dt=datetime(2024, 1, 2, 3, 4, 5),
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
55 |         d=date(2024, 1, 3),
56 |         foo=Foo(),
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_kelly_confidence_fix.py:24:15: F821 Undefined name `MockBotContext`
   |
22 |         from ai_trading.core.bot_engine import fractional_kelly_size
23 | 
24 |         ctx = MockBotContext()
   |               ^^^^^^^^^^^^^^ F821
25 |         balance = 10000.0
26 |         price = 100.0
   |

tests/test_kelly_confidence_fix.py:44:29: PLR2004 Magic value used in comparison, consider replacing `1000` with a constant variable
   |
42 |             assert isinstance(result, int), f"Result should be integer, got {type(result)}"
43 |             assert result >= 0, f"Position size should be non-negative, got {result}"
44 |             assert result < 1000, f"Position size should be reasonable, got {result}"
   |                             ^^^^ PLR2004
45 | 
46 |         # Test edge cases
   |

tests/test_kelly_confidence_fix.py:68:37: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   |
66 |             # Values > 1 should be mapped to something > 0.5
67 |             if value > 1.0:
68 |                 assert normalized > 0.5, f"High confidence {value} should map to high probability"
   |                                     ^^^ PLR2004
   |

tests/test_kelly_confidence_fix.py:77:15: F821 Undefined name `MockBotContext`
   |
75 |         from ai_trading.core.bot_engine import fractional_kelly_size
76 | 
77 |         ctx = MockBotContext()
   |               ^^^^^^^^^^^^^^ F821
78 | 
79 |         # Test invalid inputs return 0 or minimal position
   |

tests/test_logger.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import logging
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | import ai_trading.logging as logger  # Use centralized logging module
 6 | | from tests.conftest import reload_module
 7 | | 
 8 | | 
 9 | | def test_get_rotating_handler_fallback(monkeypatch, tmp_path, caplog):
   | |_^ I001
10 |       caplog.set_level("ERROR")
   |
   = help: Organize imports

tests/test_logger_rotator_smoke.py:8:8: BLE001 Do not catch blind exception: `Exception`
  |
6 | try:
7 |     import logger_rotator
8 | except Exception:  # pragma: no cover - script optional
  |        ^^^^^^^^^ BLE001
9 |     pytest.skip("logger_rotator not available", allow_module_level=True)
  |

tests/test_logger_rotator_smoke.py:19:12: BLE001 Do not catch blind exception: `Exception`
   |
17 |             if not attr_name.startswith('_'):
18 |                 getattr(mod, attr_name, None)
19 |     except Exception:
   |            ^^^^^^^^^ BLE001
20 |         # Fallback to original method if needed for coverage
21 |         lines = Path(mod.__file__).read_text().splitlines()
   |

tests/test_logging_behavior.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import time
 2 | | import types
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading import (
 7 | |     alpaca_api,  # AI-AGENT-REF: canonical import
 8 | |     utils,
 9 | | )
10 | | from ai_trading.core import bot_engine
11 | | 
12 | | try:
   | |_^ I001
13 |       from ai_trading.strategies.base import TradeSignal
14 |   except Exception:  # pragma: no cover - optional strategies package
   |
   = help: Organize imports

tests/test_logging_behavior.py:14:8: BLE001 Do not catch blind exception: `Exception`
   |
12 | try:
13 |     from ai_trading.strategies.base import TradeSignal
14 | except Exception:  # pragma: no cover - optional strategies package
   |        ^^^^^^^^^ BLE001
15 |     pytest.skip("TradeSignal unavailable", allow_module_level=True)
   |

tests/test_logging_sanitizer.py:38:31: PLR2004 Magic value used in comparison, consider replacing `321` with a constant variable
   |
36 |     assert record.x_module == "core"
37 |     assert record.x_filename == "x.py"
38 |     assert record.x_lineno == 321
   |                               ^^^ PLR2004
39 |     assert record.ok is True
   |

tests/test_main_extended2.py:19:1: E402 Module level import not at top of file
   |
17 | flask_mod.jsonify = lambda *a, **k: {}
18 | sys.modules["flask"] = flask_mod
19 | from ai_trading import app, main
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_main_smoke.py:7:8: BLE001 Do not catch blind exception: `Exception`
  |
5 | try:
6 |     main = importlib.import_module("run")
7 | except Exception:  # pragma: no cover - optional entrypoint
  |        ^^^^^^^^^ BLE001
8 |     pytest.skip("run module not available", allow_module_level=True)
  |

tests/test_market_calendar_wrapper.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | # Tests for NYSE market calendar wrapper.  # AI-AGENT-REF
 4 | | from datetime import date
 5 | | 
 6 | | import pytest
 7 | | 
 8 | | from ai_trading.data.market_calendar import is_trading_day, rth_session_utc
 9 | | 
10 | | pmc = pytest.importorskip("pandas_market_calendars")
   | |_^ I001
   |
   = help: Organize imports

tests/test_market_calendar_wrapper.py:16:22: PLR2004 Magic value used in comparison, consider replacing `13` with a constant variable
   |
14 |     # Summer (DST): 09:30 ET -> 13:30 UTC
15 |     s, e = rth_session_utc(date(2025, 8, 20))
16 |     assert s.hour == 13 and s.minute == 30
   |                      ^^ PLR2004
17 |     assert e.hour == 20 and e.minute == 0
   |

tests/test_market_calendar_wrapper.py:16:41: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
14 |     # Summer (DST): 09:30 ET -> 13:30 UTC
15 |     s, e = rth_session_utc(date(2025, 8, 20))
16 |     assert s.hour == 13 and s.minute == 30
   |                                         ^^ PLR2004
17 |     assert e.hour == 20 and e.minute == 0
   |

tests/test_market_calendar_wrapper.py:17:22: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
15 |     s, e = rth_session_utc(date(2025, 8, 20))
16 |     assert s.hour == 13 and s.minute == 30
17 |     assert e.hour == 20 and e.minute == 0
   |                      ^^ PLR2004
18 | 
19 |     # Winter (standard): 09:30 ET -> 14:30 UTC
   |

tests/test_market_calendar_wrapper.py:21:23: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
   |
19 |     # Winter (standard): 09:30 ET -> 14:30 UTC
20 |     s2, e2 = rth_session_utc(date(2025, 1, 6))
21 |     assert s2.hour == 14 and s2.minute == 30
   |                       ^^ PLR2004
22 |     assert e2.hour == 21 and e2.minute == 0
   |

tests/test_market_calendar_wrapper.py:21:43: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
19 |     # Winter (standard): 09:30 ET -> 14:30 UTC
20 |     s2, e2 = rth_session_utc(date(2025, 1, 6))
21 |     assert s2.hour == 14 and s2.minute == 30
   |                                           ^^ PLR2004
22 |     assert e2.hour == 21 and e2.minute == 0
   |

tests/test_market_calendar_wrapper.py:22:23: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
   |
20 |     s2, e2 = rth_session_utc(date(2025, 1, 6))
21 |     assert s2.hour == 14 and s2.minute == 30
22 |     assert e2.hour == 21 and e2.minute == 0
   |                       ^^ PLR2004
   |

tests/test_market_calendar_wrapper.py:28:22: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
   |
26 |     # Black Friday 2024-11-29: early close ~13:00 ET
27 |     s, e = rth_session_utc(date(2024, 11, 29))
28 |     assert s.hour == 14 and s.minute == 30  # 09:30 ET -> 14:30 UTC
   |                      ^^ PLR2004
29 |     assert e.hour == 18 and e.minute == 0   # 13:00 ET -> 18:00 UTC
   |

tests/test_market_calendar_wrapper.py:28:41: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
26 |     # Black Friday 2024-11-29: early close ~13:00 ET
27 |     s, e = rth_session_utc(date(2024, 11, 29))
28 |     assert s.hour == 14 and s.minute == 30  # 09:30 ET -> 14:30 UTC
   |                                         ^^ PLR2004
29 |     assert e.hour == 18 and e.minute == 0   # 13:00 ET -> 18:00 UTC
   |

tests/test_market_calendar_wrapper.py:29:22: PLR2004 Magic value used in comparison, consider replacing `18` with a constant variable
   |
27 |     s, e = rth_session_utc(date(2024, 11, 29))
28 |     assert s.hour == 14 and s.minute == 30  # 09:30 ET -> 14:30 UTC
29 |     assert e.hour == 18 and e.minute == 0   # 13:00 ET -> 18:00 UTC
   |                      ^^ PLR2004
   |

tests/test_mean_reversion_extra.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.strategies.mean_reversion import MeanReversionStrategy
4 | | 
5 | | 
6 | | class DummyFetcher:
  | |_^ I001
7 |       def __init__(self, df):
8 |           self.df = df
  |
  = help: Organize imports

tests/test_meta_learning.py:9:1: E402 Module level import not at top of file
   |
 7 | np.random.seed(0)
 8 | 
 9 | from ai_trading import meta_learning
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
10 | from ai_trading.meta_learning import MetaLearning
   |

tests/test_meta_learning.py:10:1: E402 Module level import not at top of file
   |
 9 | from ai_trading import meta_learning
10 | from ai_trading.meta_learning import MetaLearning
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_meta_learning.py:36:34: PLR2004 Magic value used in comparison, consider replacing `0.75` with a constant variable
   |
34 |     perf = {"a": 1.0, "b": 3.0}
35 |     res = meta_learning.update_signal_weights(w, perf)
36 |     assert round(res["b"], 2) == 0.75
   |                                  ^^^^ PLR2004
   |

tests/test_meta_learning_additional.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | from pathlib import Path
 3 | | 
 4 | | import numpy as np
 5 | | import sklearn.linear_model
 6 | | 
 7 | | from ai_trading import meta_learning
 8 | | 
 9 | | 
10 | | def test_load_weights_save_fail(monkeypatch, tmp_path, caplog):
   | |_^ I001
11 |       """Failure to write default weights is logged and default returned."""
12 |       p = tmp_path / "w.csv"
   |
   = help: Organize imports

tests/test_meta_learning_optional.py:8:31: E701 Multiple statements on one line (colon)
   |
 6 | def test_engine_imports_without_meta_learning(monkeypatch):
 7 |     # Simulate missing module to ensure optional behavior works
 8 |     class _Missing(ModuleType): pass
   |                               ^ E701
 9 |     sys.modules.pop("ai_trading.meta_learning", None)
10 |     monkeypatch.setitem(sys.modules, "ai_trading.meta_learning", _Missing("ai_trading.meta_learning"))
   |

tests/test_metalearning_strategy.py:72:49: PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   |
70 |         assert self.strategy.name == "MetaLearning Strategy"
71 |         assert self.strategy.strategy_id == "metalearning"
72 |         assert len(self.strategy.parameters) == 8
   |                                                 ^ PLR2004
73 |         assert self.strategy.parameters['lookback_period'] == 60
74 |         assert self.strategy.parameters['min_confidence'] == 0.6
   |

tests/test_metalearning_strategy.py:73:63: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   |
71 |         assert self.strategy.strategy_id == "metalearning"
72 |         assert len(self.strategy.parameters) == 8
73 |         assert self.strategy.parameters['lookback_period'] == 60
   |                                                               ^^ PLR2004
74 |         assert self.strategy.parameters['min_confidence'] == 0.6
75 |         assert not self.strategy.is_trained
   |

tests/test_metalearning_strategy.py:74:62: PLR2004 Magic value used in comparison, consider replacing `0.6` with a constant variable
   |
72 |         assert len(self.strategy.parameters) == 8
73 |         assert self.strategy.parameters['lookback_period'] == 60
74 |         assert self.strategy.parameters['min_confidence'] == 0.6
   |                                                              ^^^ PLR2004
75 |         assert not self.strategy.is_trained
   |

tests/test_minute_fallback_none_safe.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | import ai_trading.data.bars as data_bars
 6 | | from ai_trading.data.bars import safe_get_stock_bars
 7 | | 
 8 | | 
 9 | | def test_minute_fallback_none_safe(monkeypatch):
   | |_^ I001
10 |       class Client:
11 |           def get_stock_bars(self, request):
   |
   = help: Organize imports

tests/test_ml_model_loading.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import pickle
 2 | | import sys
 3 | | import types
 4 | | 
 5 | | import numpy as np
 6 | | from sklearn.dummy import DummyClassifier
 7 | | 
 8 | | # AI-AGENT-REF: Replaced unsafe _raise_dynamic_exec_disabled() with direct imports from core module
 9 | | from ai_trading.core.bot_engine import _load_ml_model
10 | | 
11 | | # Setup stub for model loader dependency
   | |_^ I001
12 |   stub = types.ModuleType("ai_trading.model_loader")
13 |   stub.ML_MODELS = {}
   |
   = help: Organize imports

tests/test_model_loading.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | 
 3 | | import joblib
 4 | | 
 5 | | from ai_trading.core.bot_engine import _load_required_model
 6 | | 
 7 | | 
 8 | | def test_load_model_from_path(monkeypatch, tmp_path):
   | |_^ I001
 9 |       mpath = tmp_path / "m.pkl"
10 |       joblib.dump({"ok": True}, mpath)
   |
   = help: Organize imports

tests/test_model_loading.py:19:16: E701 Multiple statements on one line (colon)
   |
17 | def test_load_model_from_module(monkeypatch, tmp_path):
18 |     mod = types.ModuleType("fake_model_mod")
19 |     class Dummy: pass
   |                ^ E701
20 |     mod.get_model = lambda: Dummy()
21 |     import sys
   |

tests/test_model_registry.py:4:1: I001 [*] Import block is un-sorted or un-formatted
   |
 2 |   Tests for model registry functionality.
 3 |   """
 4 | / import json
 5 | | import tempfile
 6 | | from pathlib import Path
 7 | | from unittest.mock import Mock
 8 | | 
 9 | | import pytest
10 | | 
11 | | from ai_trading.model_registry import ModelRegistry
12 | | 
13 | | 
14 | | class TestModelRegistry:
   | |_^ I001
15 |       """Test model registry round-trip functionality."""
   |
   = help: Organize imports

tests/test_model_registry_roundtrip.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Test model registry register → latest_for → load_model workflow."""
 2 |   
 3 | / import tempfile
 4 | | 
 5 | | import numpy as np
 6 | | import pytest
 7 | | from sklearn.linear_model import LinearRegression
 8 | | 
 9 | | from ai_trading.model_registry import ModelRegistry
10 | | 
11 | | 
12 | | def test_model_registry_roundtrip():
   | |_^ I001
13 |       """Test complete workflow: register_model → latest_for → load_model."""
14 |       with tempfile.TemporaryDirectory() as tmpdir:
   |
   = help: Organize imports

tests/test_model_registry_roundtrip.py:91:36: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
90 |         assert meta1["version"] == 1
91 |         assert meta2["version"] == 2
   |                                    ^ PLR2004
   |

tests/test_momentum_extra.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.strategies import momentum
4 | | from ai_trading.strategies.momentum import MomentumStrategy
5 | | 
6 | | 
7 | | class DummyFetcher:
  | |_^ I001
8 |       def __init__(self, df):
9 |           self.df = df
  |
  = help: Organize imports

tests/test_moving_average_crossover_extra.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Tests for moving average crossover strategy."""
 2 |   
 3 | / import pandas as pd
 4 | | 
 5 | | from ai_trading.strategies.moving_average_crossover import (
 6 | |     MovingAverageCrossoverStrategy,
 7 | | )
 8 | | 
 9 | | 
10 | | class DummyFetcher:
   | |_^ I001
11 |       def __init__(self, df):
12 |           self.df = df
   |
   = help: Organize imports

tests/test_nameerror_integration.py:100:35: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
 98 |         if result.returncode == 1:
 99 |             assert False, f"NameError for BUY_THRESHOLD or other trading parameter still occurs: {result.stdout}"
100 |         elif result.returncode == 2:
    |                                   ^ PLR2004
101 |             assert False, f"Unexpected NameError: {result.stdout}"
102 |         # exit code 0 means success or expected exception
    |

tests/test_net_http_timeout.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | import types
 4 | | 
 5 | | import requests
 6 | | 
 7 | | from ai_trading.net.http import TimeoutSession, build_retrying_session
 8 | | 
 9 | | 
10 | | def test_timeoutsession_injects_default_timeout(monkeypatch):
   | |_^ I001
11 |       captured = {}
   |
   = help: Organize imports

tests/test_net_http_timeout.py:25:35: PLR2004 Magic value used in comparison, consider replacing `1.23` with a constant variable
   |
23 |     captured.clear()
24 |     s.request("GET", "http://unit.test", timeout=1.23)
25 |     assert captured["timeout"] == 1.23
   |                                   ^^^^ PLR2004
   |

tests/test_parallel_speed.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import time
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading import signals
 6 | | 
 7 | | 
 8 | | def test_parallel_vs_serial_prep_speed():
   | |_^ I001
 9 |       symbols = ["AAPL", "MSFT", "GOOG", "AMZN", "TSLA"]
10 |       n = 600
   |
   = help: Organize imports

tests/test_parallel_speed.py:39:75: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
37 |     # The test should pass even if calculations fail, as it's measuring speed/structure
38 |     # In real environment with pandas, this would measure actual performance
39 |     assert duration_parallel < duration_serial * 2.5 or duration_serial < 0.1  # Allow pass if very fast (mocked)
   |                                                                           ^^^ PLR2004
   |

tests/test_parameter_optimization.py:21:54: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
20 |     # Verify optimized Kelly parameters
21 |     assert KELLY_PARAMETERS["MAX_KELLY_FRACTION"] == 0.15, f"Expected 0.15, got {KELLY_PARAMETERS['MAX_KELLY_FRACTION']}"
   |                                                      ^^^^ PLR2004
22 |     assert KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] == 20, f"Expected 20, got {KELLY_PARAMETERS['MIN_SAMPLE_SIZE']}"
23 |     assert KELLY_PARAMETERS["CONFIDENCE_LEVEL"] == 0.90, f"Expected 0.90, got {KELLY_PARAMETERS['CONFIDENCE_LEVEL']}"
   |

tests/test_parameter_optimization.py:22:51: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
20 |     # Verify optimized Kelly parameters
21 |     assert KELLY_PARAMETERS["MAX_KELLY_FRACTION"] == 0.15, f"Expected 0.15, got {KELLY_PARAMETERS['MAX_KELLY_FRACTION']}"
22 |     assert KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] == 20, f"Expected 20, got {KELLY_PARAMETERS['MIN_SAMPLE_SIZE']}"
   |                                                   ^^ PLR2004
23 |     assert KELLY_PARAMETERS["CONFIDENCE_LEVEL"] == 0.90, f"Expected 0.90, got {KELLY_PARAMETERS['CONFIDENCE_LEVEL']}"
   |

tests/test_parameter_optimization.py:23:52: PLR2004 Magic value used in comparison, consider replacing `0.90` with a constant variable
   |
21 |     assert KELLY_PARAMETERS["MAX_KELLY_FRACTION"] == 0.15, f"Expected 0.15, got {KELLY_PARAMETERS['MAX_KELLY_FRACTION']}"
22 |     assert KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] == 20, f"Expected 20, got {KELLY_PARAMETERS['MIN_SAMPLE_SIZE']}"
23 |     assert KELLY_PARAMETERS["CONFIDENCE_LEVEL"] == 0.90, f"Expected 0.90, got {KELLY_PARAMETERS['CONFIDENCE_LEVEL']}"
   |                                                    ^^^^ PLR2004
24 | 
25 |     # Ensure parameters remain within safe bounds
   |

tests/test_parameter_optimization.py:26:12: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
25 |     # Ensure parameters remain within safe bounds
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
   |            ^^^^ PLR2004
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |

tests/test_parameter_optimization.py:26:62: PLR2004 Magic value used in comparison, consider replacing `0.50` with a constant variable
   |
25 |     # Ensure parameters remain within safe bounds
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
   |                                                              ^^^^ PLR2004
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |

tests/test_parameter_optimization.py:27:12: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
25 |     # Ensure parameters remain within safe bounds
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
   |            ^^ PLR2004
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |

tests/test_parameter_optimization.py:27:57: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
25 |     # Ensure parameters remain within safe bounds
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
   |                                                         ^^^ PLR2004
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |

tests/test_parameter_optimization.py:28:12: PLR2004 Magic value used in comparison, consider replacing `0.80` with a constant variable
   |
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |            ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:28:60: PLR2004 Magic value used in comparison, consider replacing `0.99` with a constant variable
   |
26 |     assert 0.05 <= KELLY_PARAMETERS["MAX_KELLY_FRACTION"] <= 0.50, "Kelly fraction outside safe bounds"
27 |     assert 10 <= KELLY_PARAMETERS["MIN_SAMPLE_SIZE"] <= 100, "Sample size outside safe bounds"
28 |     assert 0.80 <= KELLY_PARAMETERS["CONFIDENCE_LEVEL"] <= 0.99, "Confidence level outside safe bounds"
   |                                                            ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:36:53: PLR2004 Magic value used in comparison, consider replacing `0.025` with a constant variable
   |
35 |     # Verify optimized risk parameters
36 |     assert RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] == 0.025, f"Expected 0.025, got {RISK_PARAMETERS['MAX_PORTFOLIO_RISK']}"
   |                                                     ^^^^^ PLR2004
37 |     assert RISK_PARAMETERS["MAX_POSITION_SIZE"] == 0.25, f"Expected 0.25, got {RISK_PARAMETERS['MAX_POSITION_SIZE']}"
38 |     assert RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] == 1.8, f"Expected 1.8, got {RISK_PARAMETERS['STOP_LOSS_MULTIPLIER']}"
   |

tests/test_parameter_optimization.py:37:52: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
35 |     # Verify optimized risk parameters
36 |     assert RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] == 0.025, f"Expected 0.025, got {RISK_PARAMETERS['MAX_PORTFOLIO_RISK']}"
37 |     assert RISK_PARAMETERS["MAX_POSITION_SIZE"] == 0.25, f"Expected 0.25, got {RISK_PARAMETERS['MAX_POSITION_SIZE']}"
   |                                                    ^^^^ PLR2004
38 |     assert RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] == 1.8, f"Expected 1.8, got {RISK_PARAMETERS['STOP_LOSS_MULTIPLIER']}"
39 |     assert RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] == 2.5, f"Expected 2.5, got {RISK_PARAMETERS['TAKE_PROFIT_MULTIPLIER']}"
   |

tests/test_parameter_optimization.py:38:55: PLR2004 Magic value used in comparison, consider replacing `1.8` with a constant variable
   |
36 |     assert RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] == 0.025, f"Expected 0.025, got {RISK_PARAMETERS['MAX_PORTFOLIO_RISK']}"
37 |     assert RISK_PARAMETERS["MAX_POSITION_SIZE"] == 0.25, f"Expected 0.25, got {RISK_PARAMETERS['MAX_POSITION_SIZE']}"
38 |     assert RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] == 1.8, f"Expected 1.8, got {RISK_PARAMETERS['STOP_LOSS_MULTIPLIER']}"
   |                                                       ^^^ PLR2004
39 |     assert RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] == 2.5, f"Expected 2.5, got {RISK_PARAMETERS['TAKE_PROFIT_MULTIPLIER']}"
40 |     assert RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] == 0.15, f"Expected 0.15, got {RISK_PARAMETERS['MAX_CORRELATION_EXPOSURE']}"
   |

tests/test_parameter_optimization.py:39:57: PLR2004 Magic value used in comparison, consider replacing `2.5` with a constant variable
   |
37 |     assert RISK_PARAMETERS["MAX_POSITION_SIZE"] == 0.25, f"Expected 0.25, got {RISK_PARAMETERS['MAX_POSITION_SIZE']}"
38 |     assert RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] == 1.8, f"Expected 1.8, got {RISK_PARAMETERS['STOP_LOSS_MULTIPLIER']}"
39 |     assert RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] == 2.5, f"Expected 2.5, got {RISK_PARAMETERS['TAKE_PROFIT_MULTIPLIER']}"
   |                                                         ^^^ PLR2004
40 |     assert RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] == 0.15, f"Expected 0.15, got {RISK_PARAMETERS['MAX_CORRELATION_EXPOSURE']}"
   |

tests/test_parameter_optimization.py:40:59: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
38 |     assert RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] == 1.8, f"Expected 1.8, got {RISK_PARAMETERS['STOP_LOSS_MULTIPLIER']}"
39 |     assert RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] == 2.5, f"Expected 2.5, got {RISK_PARAMETERS['TAKE_PROFIT_MULTIPLIER']}"
40 |     assert RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] == 0.15, f"Expected 0.15, got {RISK_PARAMETERS['MAX_CORRELATION_EXPOSURE']}"
   |                                                           ^^^^ PLR2004
41 | 
42 |     # Ensure parameters remain within safe bounds
   |

tests/test_parameter_optimization.py:43:12: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
   |
42 |     # Ensure parameters remain within safe bounds
43 |     assert 0.01 <= RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] <= 0.05, "Portfolio risk outside safe bounds"
   |            ^^^^ PLR2004
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
   |

tests/test_parameter_optimization.py:43:61: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
42 |     # Ensure parameters remain within safe bounds
43 |     assert 0.01 <= RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] <= 0.05, "Portfolio risk outside safe bounds"
   |                                                             ^^^^ PLR2004
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
   |

tests/test_parameter_optimization.py:44:12: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
42 |     # Ensure parameters remain within safe bounds
43 |     assert 0.01 <= RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] <= 0.05, "Portfolio risk outside safe bounds"
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
   |            ^^^^ PLR2004
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
   |

tests/test_parameter_optimization.py:44:60: PLR2004 Magic value used in comparison, consider replacing `0.30` with a constant variable
   |
42 |     # Ensure parameters remain within safe bounds
43 |     assert 0.01 <= RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] <= 0.05, "Portfolio risk outside safe bounds"
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
   |                                                            ^^^^ PLR2004
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
   |

tests/test_parameter_optimization.py:45:62: PLR2004 Magic value used in comparison, consider replacing `3.0` with a constant variable
   |
43 |     assert 0.01 <= RISK_PARAMETERS["MAX_PORTFOLIO_RISK"] <= 0.05, "Portfolio risk outside safe bounds"
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
   |                                                              ^^^ PLR2004
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
47 |     assert 0.05 <= RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] <= 0.30, "Correlation exposure outside safe bounds"
   |

tests/test_parameter_optimization.py:46:12: PLR2004 Magic value used in comparison, consider replacing `1.5` with a constant variable
   |
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
   |            ^^^ PLR2004
47 |     assert 0.05 <= RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] <= 0.30, "Correlation exposure outside safe bounds"
   |

tests/test_parameter_optimization.py:46:64: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
44 |     assert 0.05 <= RISK_PARAMETERS["MAX_POSITION_SIZE"] <= 0.30, "Position size outside safe bounds"
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
   |                                                                ^^^ PLR2004
47 |     assert 0.05 <= RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] <= 0.30, "Correlation exposure outside safe bounds"
   |

tests/test_parameter_optimization.py:47:12: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
47 |     assert 0.05 <= RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] <= 0.30, "Correlation exposure outside safe bounds"
   |            ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:47:67: PLR2004 Magic value used in comparison, consider replacing `0.30` with a constant variable
   |
45 |     assert 1.0 <= RISK_PARAMETERS["STOP_LOSS_MULTIPLIER"] <= 3.0, "Stop loss multiplier outside safe bounds"
46 |     assert 1.5 <= RISK_PARAMETERS["TAKE_PROFIT_MULTIPLIER"] <= 5.0, "Take profit multiplier outside safe bounds"
47 |     assert 0.05 <= RISK_PARAMETERS["MAX_CORRELATION_EXPOSURE"] <= 0.30, "Correlation exposure outside safe bounds"
   |                                                                   ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:55:58: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
54 |     # Verify optimized execution parameters
55 |     assert EXECUTION_PARAMETERS["PARTICIPATION_RATE"] == 0.15, f"Expected 0.15, got {EXECUTION_PARAMETERS['PARTICIPATION_RATE']}"
   |                                                          ^^^^ PLR2004
56 |     assert EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] == 15, f"Expected 15, got {EXECUTION_PARAMETERS['MAX_SLIPPAGE_BPS']}"
57 |     assert EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] == 180, f"Expected 180, got {EXECUTION_PARAMETERS['ORDER_TIMEOUT_SECONDS']}"
   |

tests/test_parameter_optimization.py:56:56: PLR2004 Magic value used in comparison, consider replacing `15` with a constant variable
   |
54 |     # Verify optimized execution parameters
55 |     assert EXECUTION_PARAMETERS["PARTICIPATION_RATE"] == 0.15, f"Expected 0.15, got {EXECUTION_PARAMETERS['PARTICIPATION_RATE']}"
56 |     assert EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] == 15, f"Expected 15, got {EXECUTION_PARAMETERS['MAX_SLIPPAGE_BPS']}"
   |                                                        ^^ PLR2004
57 |     assert EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] == 180, f"Expected 180, got {EXECUTION_PARAMETERS['ORDER_TIMEOUT_SECONDS']}"
   |

tests/test_parameter_optimization.py:57:61: PLR2004 Magic value used in comparison, consider replacing `180` with a constant variable
   |
55 |     assert EXECUTION_PARAMETERS["PARTICIPATION_RATE"] == 0.15, f"Expected 0.15, got {EXECUTION_PARAMETERS['PARTICIPATION_RATE']}"
56 |     assert EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] == 15, f"Expected 15, got {EXECUTION_PARAMETERS['MAX_SLIPPAGE_BPS']}"
57 |     assert EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] == 180, f"Expected 180, got {EXECUTION_PARAMETERS['ORDER_TIMEOUT_SECONDS']}"
   |                                                             ^^^ PLR2004
58 | 
59 |     # Ensure parameters remain within safe bounds
   |

tests/test_parameter_optimization.py:60:12: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
59 |     # Ensure parameters remain within safe bounds
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
   |            ^^^^ PLR2004
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |

tests/test_parameter_optimization.py:60:66: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
59 |     # Ensure parameters remain within safe bounds
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
   |                                                                  ^^^^ PLR2004
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |

tests/test_parameter_optimization.py:61:12: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
59 |     # Ensure parameters remain within safe bounds
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
   |            ^ PLR2004
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |

tests/test_parameter_optimization.py:61:61: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
59 |     # Ensure parameters remain within safe bounds
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
   |                                                             ^^ PLR2004
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |

tests/test_parameter_optimization.py:62:12: PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   |
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |            ^^ PLR2004
   |

tests/test_parameter_optimization.py:62:67: PLR2004 Magic value used in comparison, consider replacing `600` with a constant variable
   |
60 |     assert 0.05 <= EXECUTION_PARAMETERS["PARTICIPATION_RATE"] <= 0.25, "Participation rate outside safe bounds"
61 |     assert 5 <= EXECUTION_PARAMETERS["MAX_SLIPPAGE_BPS"] <= 50, "Slippage outside safe bounds"
62 |     assert 60 <= EXECUTION_PARAMETERS["ORDER_TIMEOUT_SECONDS"] <= 600, "Order timeout outside safe bounds"
   |                                                                   ^^^ PLR2004
   |

tests/test_parameter_optimization.py:70:58: PLR2004 Magic value used in comparison, consider replacing `1.2` with a constant variable
   |
69 |     # Verify optimized performance thresholds
70 |     assert PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] == 1.2, f"Expected 1.2, got {PERFORMANCE_THRESHOLDS['MIN_SHARPE_RATIO']}"
   |                                                          ^^^ PLR2004
71 |     assert PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] == 0.15, f"Expected 0.15, got {PERFORMANCE_THRESHOLDS['MAX_DRAWDOWN']}"
72 |     assert PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] == 0.48, f"Expected 0.48, got {PERFORMANCE_THRESHOLDS['MIN_WIN_RATE']}"
   |

tests/test_parameter_optimization.py:71:54: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
69 |     # Verify optimized performance thresholds
70 |     assert PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] == 1.2, f"Expected 1.2, got {PERFORMANCE_THRESHOLDS['MIN_SHARPE_RATIO']}"
71 |     assert PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] == 0.15, f"Expected 0.15, got {PERFORMANCE_THRESHOLDS['MAX_DRAWDOWN']}"
   |                                                      ^^^^ PLR2004
72 |     assert PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] == 0.48, f"Expected 0.48, got {PERFORMANCE_THRESHOLDS['MIN_WIN_RATE']}"
   |

tests/test_parameter_optimization.py:72:54: PLR2004 Magic value used in comparison, consider replacing `0.48` with a constant variable
   |
70 |     assert PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] == 1.2, f"Expected 1.2, got {PERFORMANCE_THRESHOLDS['MIN_SHARPE_RATIO']}"
71 |     assert PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] == 0.15, f"Expected 0.15, got {PERFORMANCE_THRESHOLDS['MAX_DRAWDOWN']}"
72 |     assert PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] == 0.48, f"Expected 0.48, got {PERFORMANCE_THRESHOLDS['MIN_WIN_RATE']}"
   |                                                      ^^^^ PLR2004
73 | 
74 |     # Ensure parameters remain within safe bounds
   |

tests/test_parameter_optimization.py:75:12: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   |
74 |     # Ensure parameters remain within safe bounds
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
   |            ^^^ PLR2004
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |

tests/test_parameter_optimization.py:75:65: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   |
74 |     # Ensure parameters remain within safe bounds
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
   |                                                                 ^^^ PLR2004
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |

tests/test_parameter_optimization.py:76:12: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
74 |     # Ensure parameters remain within safe bounds
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
   |            ^^^^ PLR2004
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |

tests/test_parameter_optimization.py:76:62: PLR2004 Magic value used in comparison, consider replacing `0.30` with a constant variable
   |
74 |     # Ensure parameters remain within safe bounds
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
   |                                                              ^^^^ PLR2004
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |

tests/test_parameter_optimization.py:77:12: PLR2004 Magic value used in comparison, consider replacing `0.30` with a constant variable
   |
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |            ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:77:62: PLR2004 Magic value used in comparison, consider replacing `0.70` with a constant variable
   |
75 |     assert 0.5 <= PERFORMANCE_THRESHOLDS["MIN_SHARPE_RATIO"] <= 2.0, "Sharpe ratio outside safe bounds"
76 |     assert 0.05 <= PERFORMANCE_THRESHOLDS["MAX_DRAWDOWN"] <= 0.30, "Drawdown outside safe bounds"
77 |     assert 0.30 <= PERFORMANCE_THRESHOLDS["MIN_WIN_RATE"] <= 0.70, "Win rate outside safe bounds"
   |                                                              ^^^^ PLR2004
   |

tests/test_parameter_optimization.py:105:20: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
    |
103 |         # Verify regime multipliers are within reasonable bounds
104 |         for regime, multiplier in sizer.regime_multipliers.items():
105 |             assert 0.1 <= multiplier <= 2.0, f"Regime multiplier {multiplier} for {regime} outside safe bounds"
    |                    ^^^ PLR2004
106 | 
107 |         # Verify volatility adjustments are within reasonable bounds
    |

tests/test_parameter_optimization.py:105:41: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
103 |         # Verify regime multipliers are within reasonable bounds
104 |         for regime, multiplier in sizer.regime_multipliers.items():
105 |             assert 0.1 <= multiplier <= 2.0, f"Regime multiplier {multiplier} for {regime} outside safe bounds"
    |                                         ^^^ PLR2004
106 | 
107 |         # Verify volatility adjustments are within reasonable bounds
    |

tests/test_parameter_optimization.py:109:20: PLR2004 Magic value used in comparison, consider replacing `0.2` with a constant variable
    |
107 |         # Verify volatility adjustments are within reasonable bounds
108 |         for vol_regime, adjustment in sizer.volatility_adjustments.items():
109 |             assert 0.2 <= adjustment <= 2.0, f"Volatility adjustment {adjustment} for {vol_regime} outside safe bounds"
    |                    ^^^ PLR2004
110 | 
111 |     except ImportError as e:
    |

tests/test_parameter_optimization.py:109:41: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
    |
107 |         # Verify volatility adjustments are within reasonable bounds
108 |         for vol_regime, adjustment in sizer.volatility_adjustments.items():
109 |             assert 0.2 <= adjustment <= 2.0, f"Volatility adjustment {adjustment} for {vol_regime} outside safe bounds"
    |                                         ^^^ PLR2004
110 | 
111 |     except ImportError as e:
    |

tests/test_parameter_optimization.py:123:29: F821 Undefined name `MockOrderManager`
    |
122 |         # Mock order manager for testing
123 |         vwap = VWAPExecutor(MockOrderManager())
    |                             ^^^^^^^^^^^^^^^^ F821
124 | 
125 |         # Verify optimized participation rate
    |

tests/test_parameter_optimization.py:126:43: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
    |
125 |         # Verify optimized participation rate
126 |         assert vwap.participation_rate == 0.15, f"Expected 0.15, got {vwap.participation_rate}"
    |                                           ^^^^ PLR2004
127 |         assert 0.05 <= vwap.participation_rate <= 0.30, "VWAP participation rate outside safe bounds"
    |

tests/test_parameter_optimization.py:127:16: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
    |
125 |         # Verify optimized participation rate
126 |         assert vwap.participation_rate == 0.15, f"Expected 0.15, got {vwap.participation_rate}"
127 |         assert 0.05 <= vwap.participation_rate <= 0.30, "VWAP participation rate outside safe bounds"
    |                ^^^^ PLR2004
128 | 
129 |     except ImportError as e:
    |

tests/test_parameter_optimization.py:127:51: PLR2004 Magic value used in comparison, consider replacing `0.30` with a constant variable
    |
125 |         # Verify optimized participation rate
126 |         assert vwap.participation_rate == 0.15, f"Expected 0.15, got {vwap.participation_rate}"
127 |         assert 0.05 <= vwap.participation_rate <= 0.30, "VWAP participation rate outside safe bounds"
    |                                                   ^^^^ PLR2004
128 | 
129 |     except ImportError as e:
    |

tests/test_parameter_validation.py:79:39: PLR2004 Magic value used in comparison, consider replacing `0.25` with a constant variable
   |
77 |         assert result["status"] == "PASS", f"Valid parameter change should pass: {result}"
78 |         assert result["parameter"] == "MAX_KELLY_FRACTION"
79 |         assert result["old_value"] == 0.25
   |                                       ^^^^ PLR2004
80 |         assert result["new_value"] == 0.15
   |

tests/test_parameter_validation.py:80:39: PLR2004 Magic value used in comparison, consider replacing `0.15` with a constant variable
   |
78 |         assert result["parameter"] == "MAX_KELLY_FRACTION"
79 |         assert result["old_value"] == 0.25
80 |         assert result["new_value"] == 0.15
   |                                       ^^^^ PLR2004
81 | 
82 |         # Test invalid parameter change (outside bounds)
   |

tests/test_parameter_validation.py:166:35: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
    |
164 |                 assert max_val <= 1.0, f"{param_name} should not exceed 100%"
165 |             if "DRAWDOWN" in param_name:
166 |                 assert max_val <= 0.5, f"{param_name} should not exceed 50%"
    |                                   ^^^ PLR2004
167 |             if "SHARPE" in param_name:
168 |                 assert max_val <= 5.0, f"{param_name} should have reasonable upper bound"
    |

tests/test_parameter_validation.py:168:35: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
    |
166 |                 assert max_val <= 0.5, f"{param_name} should not exceed 50%"
167 |             if "SHARPE" in param_name:
168 |                 assert max_val <= 5.0, f"{param_name} should have reasonable upper bound"
    |                                   ^^^ PLR2004
169 | 
170 |     except ImportError as e:
    |

tests/test_peak_performance.py:95:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
93 |     drifts = reconciler.reconcile_positions(local_positions, broker_positions)
94 | 
95 |     assert len(drifts) >= 2  # AAPL drift + GOOGL missing + MSFT missing
   |                           ^ PLR2004
96 | 
97 |     # Check AAPL drift
   |

tests/test_peak_performance.py:100:36: PLR2004 Magic value used in comparison, consider replacing `-2.0` with a constant variable
    |
 98 |     aapl_drift = next((d for d in drifts if d.symbol == "AAPL"), None)
 99 |     assert aapl_drift is not None
100 |     assert aapl_drift.drift_qty == -2.0  # local - broker
    |                                    ^^^^ PLR2004
    |

tests/test_peak_performance.py:112:24: PLR2004 Magic value used in comparison, consider replacing `5000` with a constant variable
    |
110 |     skew = clock.check_skew()
111 |     assert isinstance(skew, float)
112 |     assert abs(skew) < 5000  # Should be reasonable
    |                        ^^^^ PLR2004
113 | 
114 |     # Test bar validation
    |

tests/test_peak_performance.py:140:48: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
138 |     slippage = costs.slippage_cost_bps(volume_ratio=2.0)
139 |     expected_slippage = 1.5 * np.sqrt(2.0)
140 |     assert abs(slippage - expected_slippage) < 0.01
    |                                                ^^^^ PLR2004
141 | 
142 |     # Test total cost
    |

tests/test_peak_performance.py:145:47: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
    |
143 |     total_cost = costs.total_execution_cost_bps(volume_ratio=1.5)
144 |     expected_total = (2.0 * 2) + 0.5 + (1.5 * np.sqrt(1.5))  # spread + commission + slippage
145 |     assert abs(total_cost - expected_total) < 0.01
    |                                               ^^^^ PLR2004
146 | 
147 |     # Test cost model
    |

tests/test_peak_performance.py:181:25: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
179 |     # Test volatility calculation
180 |     vols = controller.calculate_volatilities(returns_data)
181 |     assert len(vols) == 3
    |                         ^ PLR2004
182 |     for symbol in symbols:
183 |         assert symbol in vols
    |

tests/test_peak_performance.py:189:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
187 |     try:
188 |         clusters = controller.calculate_correlation_clusters(returns_data)
189 |         assert len(clusters) == 3
    |                                 ^ PLR2004
190 |         assert all(isinstance(cluster_id, int) for cluster_id in clusters.values())
191 |     except ImportError:
    |

tests/test_peak_performance.py:198:36: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
196 |     kelly_fractions = controller.calculate_kelly_fractions(expected_returns, vols)
197 | 
198 |     assert len(kelly_fractions) == 3
    |                                    ^ PLR2004
199 |     for symbol in symbols:
200 |         assert kelly_fractions[symbol] >= 0  # Kelly fractions should be non-negative
    |

tests/test_peak_performance.py:225:26: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
    |
224 |     assert hash1 == hash2
225 |     assert len(hash1) == 16  # Should be 16-char hash
    |                          ^^ PLR2004
226 | 
227 |     # Test different data produces different hash
    |

tests/test_peak_performance.py:259:34: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
257 |     drift_metrics = monitor.monitor_feature_drift(current_features)
258 | 
259 |     assert len(drift_metrics) == 2
    |                                  ^ PLR2004
260 |     for metric in drift_metrics:
261 |         assert metric.psi_score >= 0
    |

tests/test_peak_performance.py:263:38: PLR2004 Magic value used in comparison, consider replacing `500` with a constant variable
    |
261 |         assert metric.psi_score >= 0
262 |         assert metric.drift_level in ['low', 'medium', 'high']
263 |         assert metric.sample_size == 500
    |                                      ^^^ PLR2004
    |

tests/test_peak_performance.py:343:41: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
341 |     assert order_request['symbol'] == "TEST"
342 |     assert order_request['side'] == "buy"
343 |     assert order_request['quantity'] == 100
    |                                         ^^^ PLR2004
344 |     assert 'cost_estimate' in order_request
345 |     assert 'cost_bps' in order_request['cost_estimate']
    |

tests/test_peak_performance.py:370:40: PLR2004 Magic value used in comparison, consider replacing `15.0` with a constant variable
    |
369 |     # If costs are within limit, size should be unchanged
370 |     if cost_info.get('cost_bps', 0) <= 15.0:
    |                                        ^^^^ PLR2004
371 |         assert adjusted_size == 10000
372 |     else:
    |

tests/test_peak_performance.py:371:33: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
369 |     # If costs are within limit, size should be unchanged
370 |     if cost_info.get('cost_bps', 0) <= 15.0:
371 |         assert adjusted_size == 10000
    |                                 ^^^^^ PLR2004
372 |     else:
373 |         assert adjusted_size < 10000  # Should be scaled down
    |

tests/test_peak_performance.py:373:32: PLR2004 Magic value used in comparison, consider replacing `10000` with a constant variable
    |
371 |         assert adjusted_size == 10000
372 |     else:
373 |         assert adjusted_size < 10000  # Should be scaled down
    |                                ^^^^^ PLR2004
    |

tests/test_performance_allocator_conf_gate.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import logging
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading.config.management import TradingConfig
 6 | | from ai_trading.config.settings import get_settings
 7 | | from ai_trading.strategies.performance_allocator import (
 8 | |     PerformanceBasedAllocator,
 9 | |     _resolve_conf_threshold,
10 | | )
11 | | 
12 | | 
13 | | class Sig:
   | |_^ I001
14 |       def __init__(self, symbol: str, confidence: float):
15 |           self.symbol = symbol
   |
   = help: Organize imports

tests/test_performance_allocator_conf_gate.py:41:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
40 |     drops = [rec for rec in caplog.records if rec.message == "CONFIDENCE_DROP"]
41 |     assert len(drops) >= 2
   |                          ^ PLR2004
42 |     for rec in drops:
43 |         assert getattr(rec, "threshold", 0) == pytest.approx(0.7)
   |

tests/test_performance_fixes.py:118:12: BLE001 Do not catch blind exception: `Exception`
    |
116 |     try:
117 |         engine._handle_order_result("AAPL", "buy", mock_order, 150.00, 100, start_time)
118 |     except Exception:
    |            ^^^^^^^^^ BLE001
119 |         # Expected to fail on API calls in test environment
120 |         pass
    |

tests/test_performance_fixes.py:139:12: BLE001 Do not catch blind exception: `Exception`
    |
137 |         return True
138 | 
139 |     except Exception:
    |            ^^^^^^^^^ BLE001
140 |         import traceback
141 |         traceback.print_exc()
    |

tests/test_pipeline_smoke.py:73:28: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
71 |     df = pd.DataFrame({"close": np.arange(10, dtype=float)})
72 |     arr = pipeline.FeatureBuilder().transform(df)
73 |     assert arr.shape[0] == 10
   |                            ^^ PLR2004
74 |     pipeline.model_pipeline.fit(df, np.arange(len(df)))
75 |     force_coverage(pipeline)
   |

tests/test_portfolio.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading.core import bot_engine
 6 | | 
 7 | | 
 8 | | def test_short_close_queued(monkeypatch, caplog):
   | |_^ I001
 9 |       state = bot_engine.BotState()
10 |       state.position_cache = {"TSLA": -44}
   |
   = help: Organize imports

tests/test_portfolio_integration.py:171:16: BLE001 Do not catch blind exception: `Exception`
    |
169 |             # If it doesn't crash, that's a success in this test environment
170 |             assert True
171 |         except Exception as e:
    |                ^^^^^^^^^ BLE001
172 |             # Some failures are expected due to limited test environment
173 |             # Just ensure it's handling errors gracefully
    |

tests/test_portfolio_optimization.py:176:30: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
175 |         assert spread_cost > 0
176 |         assert spread_cost < 100  # Should be reasonable relative to trade size
    |                              ^^^ PLR2004
177 | 
178 |         # Test with missing quote data (should fallback gracefully)
    |

tests/test_portfolio_snapshot.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import json
 2 | | import os
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading.core import bot_engine
 7 | | 
 8 | | 
 9 | | @pytest.mark.smoke
   | |_^ I001
10 |   def test_save_and_load_snapshot(tmp_path):
11 |       tmp_path / "portfolio_snapshot.json"
   |
   = help: Organize imports

tests/test_position_holding_simple.py:76:33: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
   |
74 |         assert result is not None, "Conversion should return data"
75 |         assert result['symbol'] == 'AAPL', "Symbol should be preserved"
76 |         assert result['qty'] == 100, "Quantity should be preserved"
   |                                 ^^^ PLR2004
77 |         assert result['side'] == 'buy', "Side should be preserved"
78 |         assert result['classification'] == 'converted', "Should be marked as converted"
   |

tests/test_position_holding_simple.py:127:12: BLE001 Do not catch blind exception: `Exception`
    |
125 |         test_meta_learning_functions()
126 |         test_signal_filtering()
127 |     except Exception:
    |            ^^^^^^^^^ BLE001
128 |         import traceback
129 |         traceback.print_exc()
    |

tests/test_position_intelligence.py:37:23: F821 Undefined name `MockSeries`
   |
35 |         # Test with trending price data
36 |         price_data = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115]
37 |         mock_prices = MockSeries(price_data)
   |                       ^^^^^^^^^^ F821
38 | 
39 |         analyzer._calculate_rsi(mock_prices, 14)
   |

tests/test_position_intelligence.py:89:12: BLE001 Do not catch blind exception: `Exception`
   |
87 |         return True
88 | 
89 |     except Exception:
   |            ^^^^^^^^^ BLE001
90 |         import traceback
91 |         traceback.print_exc()
   |

tests/test_position_intelligence.py:122:12: BLE001 Do not catch blind exception: `Exception`
    |
120 |         return True
121 | 
122 |     except Exception:
    |            ^^^^^^^^^ BLE001
123 |         return False
    |

tests/test_prediction_executor.py:27:31: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
25 |             workers = _workers_env or _default_workers
26 | 
27 |             assert workers == 4, "Should cap at 4 workers for 8 CPUs"
   |                               ^ PLR2004
28 | 
29 |     @patch('os.cpu_count')
   |

tests/test_prediction_executor.py:42:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
40 |             workers = _workers_env or _default_workers
41 | 
42 |             assert workers == 2, "Should use minimum of 2 workers for 1 CPU"
   |                               ^ PLR2004
43 | 
44 |     @patch('os.cpu_count')
   |

tests/test_prediction_executor.py:57:31: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
55 |             workers = _workers_env or _default_workers
56 | 
57 |             assert workers == 2, "Should use fallback of 2 when cpu_count returns None"
   |                               ^ PLR2004
58 | 
59 |     def test_prediction_executor_env_override(self):
   |

tests/test_prediction_executor.py:67:31: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
65 |             workers = _workers_env or _default_workers
66 | 
67 |             assert workers == 3, "Should use PREDICTION_WORKERS=3 when set"
   |                               ^ PLR2004
68 | 
69 |     def test_prediction_executor_env_zero(self):
   |

tests/test_prediction_executor.py:78:35: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
76 |                 workers = _workers_env or _default_workers
77 | 
78 |                 assert workers == 4, "Should use default logic when PREDICTION_WORKERS=0"
   |                                   ^ PLR2004
79 | 
80 |     def test_prediction_executor_env_empty_string(self):
   |

tests/test_prediction_executor.py:89:35: PLR2004 Magic value used in comparison, consider replacing `4` with a constant variable
   |
87 |                 workers = _workers_env or _default_workers
88 | 
89 |                 assert workers == 4, "Should use default logic when PREDICTION_WORKERS is empty"
   |                                   ^ PLR2004
90 | 
91 |     def test_prediction_executor_env_invalid(self):
   |

tests/test_prediction_executor.py:107:31: PLR2004 Magic value used in comparison, consider replacing `16` with a constant variable
    |
105 |             workers = _workers_env or _default_workers
106 | 
107 |             assert workers == 16, "Should accept large PREDICTION_WORKERS values"
    |                               ^^ PLR2004
108 | 
109 |     @patch('os.cpu_count')
    |

tests/test_price_snapshot_minute_fallback.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from types import SimpleNamespace
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading.portfolio import core as portfolio_core
 6 | | 
 7 | | 
 8 | | def test_price_snapshot_minute_fallback(monkeypatch):
   | |_^ I001
 9 |       ctx = SimpleNamespace(
10 |           data_fetcher=SimpleNamespace(get_daily_df=lambda ctx, s: pd.DataFrame()),
   |
   = help: Organize imports

tests/test_price_snapshot_minute_fallback.py:28:21: PLR2004 Magic value used in comparison, consider replacing `123.0` with a constant variable
   |
27 |     price = portfolio_core.get_latest_price(ctx, "SPY")
28 |     assert price == 123.0
   |                     ^^^^^ PLR2004
   |

tests/test_problem_statement_validation.py:194:16: BLE001 Do not catch blind exception: `Exception`
    |
192 |             test_func()
193 |             passed += 1
194 |         except Exception:
    |                ^^^^^^^^^ BLE001
195 |             failed += 1
    |

tests/test_production_fixes.py:128:1: I001 [*] Import block is un-sorted or un-formatted
    |
126 |           """Set up data validation test."""
127 |           try:
128 | /             import pandas as pd
129 | | 
130 | |             from ai_trading.data_validation import (
131 | |                 check_data_freshness,
132 | |                 get_staleness_threshold,
133 | |                 is_market_hours,
134 | |             )
135 | |             self.pd = pd
    | |_^ I001
136 |               self.is_market_hours = is_market_hours
137 |               self.get_staleness_threshold = get_staleness_threshold
    |
    = help: Organize imports

tests/test_production_system.py:69:12: BLE001 Do not catch blind exception: `Exception`
   |
67 |     except ImportError:
68 |         return True
69 |     except Exception:
   |            ^^^^^^^^^ BLE001
70 |         return False
   |

tests/test_production_system.py:95:46: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
   |
93 |         # Test status
94 |         status = breaker.get_status()
95 |         assert status["current_drawdown"] >= 0.10, "Drawdown should be >= 10%"
   |                                              ^^^^ PLR2004
96 |         assert not status["trading_allowed"], "Trading should be halted"
   |

tests/test_production_system.py:102:12: BLE001 Do not catch blind exception: `Exception`
    |
100 |     except ImportError:
101 |         return True
102 |     except Exception:
    |            ^^^^^^^^^ BLE001
103 |         return False
    |

tests/test_production_system.py:137:12: BLE001 Do not catch blind exception: `Exception`
    |
135 |     except ImportError:
136 |         return True
137 |     except Exception:
    |            ^^^^^^^^^ BLE001
138 |         return False
    |

tests/test_production_system.py:173:41: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
171 |         # Test alert stats
172 |         stats = alert_manager.get_alert_stats()
173 |         assert stats["total_alerts"] >= 2, "Should have at least 2 alerts"
    |                                         ^ PLR2004
174 | 
175 |         # Stop processing
    |

tests/test_production_system.py:182:12: BLE001 Do not catch blind exception: `Exception`
    |
180 |     except ImportError:
181 |         return True
182 |     except Exception:
    |            ^^^^^^^^^ BLE001
183 |         return False
    |

tests/test_production_system.py:223:12: BLE001 Do not catch blind exception: `Exception`
    |
221 |     except ImportError:
222 |         return True
223 |     except Exception:
    |            ^^^^^^^^^ BLE001
224 |         return False
    |

tests/test_production_system.py:267:12: BLE001 Do not catch blind exception: `Exception`
    |
265 |     except KeyboardInterrupt:
266 |         sys.exit(1)
267 |     except Exception:
    |            ^^^^^^^^^ BLE001
268 |         sys.exit(1)
    |

tests/test_prof_budget.py:9:30: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
 7 |     b = SoftBudget(interval_sec=0.1, fraction=0.5)
 8 |     time.sleep(0.02)
 9 |     assert b.elapsed_ms() >= 20
   |                              ^^ PLR2004
10 |     time.sleep(0.05)
11 |     assert b.over() is True or b.remaining() == 0.0
   |

tests/test_property_based.py:39:39: PLR2004 Magic value used in comparison, consider replacing `35` with a constant variable
   |
37 | def test_calculate_macd_invalid(prices):
38 |     ser = pd.Series(prices)
39 |     if ser.isna().any() or len(ser) < 35:
   |                                       ^^ PLR2004
40 |         assert signals.calculate_macd(ser) is None
41 |     else:
   |

tests/test_property_based.py:65:27: PLR2004 Magic value used in comparison, consider replacing `10` with a constant variable
   |
63 |     df = pd.DataFrame({"close": [1] * rows})
64 |     ok = utils.health_check(df, "daily")
65 |     assert ok == (rows >= 10)
   |                           ^^ PLR2004
   |

tests/test_pydantic_v2_migration.py:54:45: PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   |
53 |     # Verify classmethod decorators are present
54 |     assert content.count('@classmethod') >= 6
   |                                             ^ PLR2004
   |

tests/test_pydantic_v2_migration.py:71:1: I001 [*] Import block is un-sorted or un-formatted
   |
69 |               'FORCE_TRADES': 'false'
70 |           }):
71 | /             from ai_trading.validation import validate_env  # AI-AGENT-REF: normalized import
72 | | 
   | |_^ I001
73 |               # Test that Settings class can be instantiated
74 |               settings = validate_env.Settings()
   |
   = help: Organize imports

tests/test_pydantic_v2_migration.py:83:12: BLE001 Do not catch blind exception: `Exception`
   |
81 |     except ImportError as e:
82 |         pytest.skip(f"Cannot import validate_env module: {e}")
83 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
84 |         # Don't fail if there are other validation issues, just check syntax works
85 |         if "field_validator" in str(e) or "validator" in str(e):
   |

tests/test_pydantic_v2_migration.py:104:1: I001 [*] Import block is un-sorted or un-formatted
    |
102 |               'TRADING_MODE': 'invalid',        # Should trigger validation error
103 |           }):
104 | /             from ai_trading.validation import validate_env  # AI-AGENT-REF: normalized import
105 | | 
    | |_^ I001
106 |               # These should trigger validation errors due to invalid values
107 |               try:
    |
    = help: Organize imports

tests/test_pydantic_v2_migration.py:111:20: BLE001 Do not catch blind exception: `Exception`
    |
109 |                 # If we get here, check that the problematic values were caught
110 |                 # by validators or set to defaults
111 |             except Exception as e:
    |                    ^^^^^^^^^ BLE001
112 |                 # Validation errors are expected with invalid inputs
113 |                 assert "ALPACA_SECRET_KEY appears too short" in str(e) or \
    |

tests/test_rebalancer_additional.py:31:24: BLE001 Do not catch blind exception: `Exception`
   |
29 |                 try:
30 |                     target()
31 |                 except Exception:
   |                        ^^^^^^^^^ BLE001
32 |                     # Catch any exceptions from the loop to prevent infinite execution
33 |                     pass
   |

tests/test_regime_and_schema_guard.py:37:47: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
   |
35 |     settings = get_settings()
36 |     assert hasattr(settings, 'pretrade_lookback_days')
37 |     assert settings.pretrade_lookback_days == 120  # Default value
   |                                               ^^^ PLR2004
38 | 
39 | def test_regime_basket_proxy_function():
   |

tests/test_regime_and_schema_guard.py:66:24: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
64 |     out = _regime_basket_to_proxy_bars(wide)
65 |     assert "timestamp" in out.columns and "close" in out.columns
66 |     assert len(out) == 5
   |                        ^ PLR2004
   |

tests/test_resample_daily.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Test minute-to-daily resampling fallback."""
 2 |   
 3 | / from datetime import UTC, datetime
 4 | | 
 5 | | import pandas as pd
 6 | | 
 7 | | from ai_trading.data import bars
 8 | | 
 9 | | 
10 | | def test_get_daily_bars_resamples_minutes(monkeypatch):
   | |_^ I001
11 |       """When daily bars are empty, minute bars are resampled."""  # AI-AGENT-REF
12 |       empty = pd.DataFrame()
   |
   = help: Organize imports

tests/test_retry_idempotency_integration.py:77:14: F821 Undefined name `MockBrokerAPI`
   |
75 | def test_retry_idempotency_integration():
76 |     """Test that retry mechanism works with idempotency protection."""
77 |     broker = MockBrokerAPI(fail_count=2)  # Fail 2 times, succeed on 3rd
   |              ^^^^^^^^^^^^^ F821
78 |     idempotency_mgr = OrderIdempotencyManager()
79 |     PositionReconciler()
   |

tests/test_retry_idempotency_integration.py:107:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
106 |     # Verify retry behavior
107 |     assert broker.call_count == 3, f"Expected 3 calls, got {broker.call_count}"
    |                                 ^ PLR2004
108 |     assert len(broker.submitted_orders) == 1, "Should have exactly one order submitted"
    |

tests/test_retry_idempotency_integration.py:113:43: PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
    |
111 |     submitted_order = broker.submitted_orders[0]
112 |     assert submitted_order["symbol"] == "AAPL"
113 |     assert submitted_order["quantity"] == 100
    |                                           ^^^ PLR2004
114 | 
115 |     # Verify idempotency protection
    |

tests/test_retry_idempotency_integration.py:121:14: F821 Undefined name `MockBrokerAPI`
    |
119 | def test_reconciliation_heals_state():
120 |     """Test that reconciliation heals local/broker state after submission."""
121 |     broker = MockBrokerAPI(fail_count=0)  # No failures
    |              ^^^^^^^^^^^^^ F821
122 |     idempotency_mgr = OrderIdempotencyManager()
123 |     reconciler = PositionReconciler()
    |

tests/test_retry_idempotency_integration.py:150:14: F821 Undefined name `MockBrokerAPI`
    |
148 | def test_retry_exhaustion_with_idempotency():
149 |     """Test behavior when all retries are exhausted."""
150 |     broker = MockBrokerAPI(fail_count=5)  # Fail more times than retry limit
    |              ^^^^^^^^^^^^^ F821
151 |     idempotency_mgr = OrderIdempotencyManager()
    |

tests/test_retry_idempotency_integration.py:185:33: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
184 |     # Verify retries occurred but no order was submitted
185 |     assert broker.call_count == 3, f"Should have attempted 3 times, got {broker.call_count}"
    |                                 ^ PLR2004
186 |     assert len(broker.submitted_orders) == 0, "No orders should be submitted on failure"
    |

tests/test_risk.py:37:19: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
   |
35 |     base_frac *= comp
36 |     drawdown = (peak - balance) / peak
37 |     if drawdown > 0.10:
   |                   ^^^^ PLR2004
38 |         frac = 0.3
39 |     elif drawdown > 0.05:
   |

tests/test_risk.py:39:21: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
37 |     if drawdown > 0.10:
38 |         frac = 0.3
39 |     elif drawdown > 0.05:
   |                     ^^^^ PLR2004
40 |         frac = 0.45
41 |     else:
   |

tests/test_risk_engine_additional.py:2:1: I001 [*] Import block is un-sorted or un-formatted
   |
 2 | / import numpy as np
 3 | | import pytest
 4 | | 
 5 | | import ai_trading.risk.engine as risk_engine  # AI-AGENT-REF: normalized import
 6 | | from ai_trading.strategies import TradeSignal
 7 | | 
 8 | | 
 9 | | def test_can_trade_invalid_type(caplog):
   | |_^ I001
10 |       """can_trade rejects non-TradeSignal objects."""
11 |       eng = risk_engine.RiskEngine()
   |
   = help: Organize imports

tests/test_risk_engine_additional.py:56:27: PLR2004 Magic value used in comparison, consider replacing `0.1` with a constant variable
   |
54 |     sig = TradeSignal(symbol='A', side='buy', confidence=1.0, strategy='s', weight=1.0)
55 |     w = eng._apply_weight_limits(sig)
56 |     assert round(w, 1) == 0.1
   |                           ^^^ PLR2004
   |

tests/test_risk_engine_module.py:11:1: E402 Module level import not at top of file
   |
 9 |     sys.modules.pop(m, None)
10 | sys.modules.pop("risk_engine", None)
11 | from ai_trading.risk.engine import RiskEngine  # AI-AGENT-REF: normalized import
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
12 | from ai_trading.strategies import TradeSignal
   |

tests/test_risk_engine_module.py:12:1: E402 Module level import not at top of file
   |
10 | sys.modules.pop("risk_engine", None)
11 | from ai_trading.risk.engine import RiskEngine  # AI-AGENT-REF: normalized import
12 | from ai_trading.strategies import TradeSignal
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_risk_engine_package.py:91:16: BLE001 Do not catch blind exception: `Exception`
   |
89 |         try:
90 |             re.update_exposure(context=MockContext())
91 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
92 |             self.fail(f"update_exposure failed with context: {e}")
   |

tests/test_risk_new.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | import ai_trading.risk.engine as risk_engine  # AI-AGENT-REF: normalized import
4 | | 
5 | | 
6 | | def test_stop_levels():
  | |_^ I001
7 |       stop, take = risk_engine.compute_stop_levels(100, 2)
8 |       assert stop == 98 and take == 104
  |
  = help: Organize imports

tests/test_risk_new.py:8:20: PLR2004 Magic value used in comparison, consider replacing `98` with a constant variable
  |
6 | def test_stop_levels():
7 |     stop, take = risk_engine.compute_stop_levels(100, 2)
8 |     assert stop == 98 and take == 104
  |                    ^^ PLR2004
  |

tests/test_risk_new.py:8:35: PLR2004 Magic value used in comparison, consider replacing `104` with a constant variable
  |
6 | def test_stop_levels():
7 |     stop, take = risk_engine.compute_stop_levels(100, 2)
8 |     assert stop == 98 and take == 104
  |                                   ^^^ PLR2004
  |

tests/test_rl_features.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import numpy as np
2 | | import pandas as pd
3 | | 
4 | | from ai_trading.rl_trading.features import FeatureConfig, compute_features
5 | | 
6 | | 
7 | | def test_compute_features_shape_and_finite():
  | |_^ I001
8 |       n = 100
9 |       df = pd.DataFrame({
  |
  = help: Organize imports

tests/test_rl_module.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import numpy as np
2 | | 
3 | | import ai_trading.rl_trading.inference as inf
4 | | import ai_trading.rl_trading.train as train_mod
5 | | 
6 | | 
7 | | def test_rl_train_and_infer(monkeypatch, tmp_path):
  | |_^ I001
8 |       data = np.random.rand(20, 4)
9 |       class DummyPPO:
  |
  = help: Organize imports

tests/test_run_strategy_no_signals.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from types import SimpleNamespace
2 | | 
3 | | import pandas as pd
4 | | 
5 | | from ai_trading.core import bot_engine
6 | | 
7 | | 
8 | | class DummyStrategy:
  | |_^ I001
9 |       name = "dummy"
  |
  = help: Organize imports

tests/test_runner_additional.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / from ai_trading.core import bot_engine  # replace old bot import
2 | | from tests.test_bot import _DummyTradingClient
3 | | 
4 | | 
5 | | def test_runner_starts():
  | |_^ I001
6 |       ctx = bot_engine.ctx
7 |       ctx.api = _DummyTradingClient()
  |
  = help: Organize imports

tests/test_runtime_fixes.py:17:12: BLE001 Do not catch blind exception: `Exception`
   |
15 |     try:
16 |         success = True
17 |     except Exception:
   |            ^^^^^^^^^ BLE001
18 |         success = False
   |

tests/test_runtime_fixes.py:23:12: BLE001 Do not catch blind exception: `Exception`
   |
21 |     try:
22 |         pass
23 |     except Exception:
   |            ^^^^^^^^^ BLE001
24 |         success = False
   |

tests/test_runtime_fixes.py:29:12: BLE001 Do not catch blind exception: `Exception`
   |
27 |     try:
28 |         pass
29 |     except Exception as e:
   |            ^^^^^^^^^ BLE001
30 |         if "ALPACA_API_KEY" in str(e) or "pydantic_settings" in str(e):
31 |             pass
   |

tests/test_runtime_fixes.py:130:16: BLE001 Do not catch blind exception: `Exception`
    |
128 |             if test_func():
129 |                 passed += 1
130 |         except Exception:
    |                ^^^^^^^^^ BLE001
131 |             pass
    |

tests/test_runtime_params_hydration.py:25:31: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
24 |     # Verify default values
25 |     assert cfg.capital_cap == 0.04
   |                               ^^^^ PLR2004
26 |     assert cfg.dollar_risk_limit == 0.05
27 |     assert cfg.max_position_size == 1.0
   |

tests/test_runtime_params_hydration.py:26:37: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
24 |     # Verify default values
25 |     assert cfg.capital_cap == 0.04
26 |     assert cfg.dollar_risk_limit == 0.05
   |                                     ^^^^ PLR2004
27 |     assert cfg.max_position_size == 1.0
   |

tests/test_runtime_params_hydration.py:44:35: PLR2004 Magic value used in comparison, consider replacing `0.06` with a constant variable
   |
42 |         cfg = TradingConfig.from_env()
43 | 
44 |         assert cfg.capital_cap == 0.06
   |                                   ^^^^ PLR2004
45 |         assert cfg.dollar_risk_limit == 0.08
46 |         assert cfg.max_position_size == 2.0
   |

tests/test_runtime_params_hydration.py:45:41: PLR2004 Magic value used in comparison, consider replacing `0.08` with a constant variable
   |
44 |         assert cfg.capital_cap == 0.06
45 |         assert cfg.dollar_risk_limit == 0.08
   |                                         ^^^^ PLR2004
46 |         assert cfg.max_position_size == 2.0
   |

tests/test_runtime_params_hydration.py:46:41: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   |
44 |         assert cfg.capital_cap == 0.06
45 |         assert cfg.dollar_risk_limit == 0.08
46 |         assert cfg.max_position_size == 2.0
   |                                         ^^^ PLR2004
   |

tests/test_runtime_params_hydration.py:75:45: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
74 |     # Verify specific values
75 |     assert runtime.params['CAPITAL_CAP'] == 0.04
   |                                             ^^^^ PLR2004
76 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.05
77 |     assert runtime.params['MAX_POSITION_SIZE'] == 1.0
   |

tests/test_runtime_params_hydration.py:76:51: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
74 |     # Verify specific values
75 |     assert runtime.params['CAPITAL_CAP'] == 0.04
76 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.05
   |                                                   ^^^^ PLR2004
77 |     assert runtime.params['MAX_POSITION_SIZE'] == 1.0
   |

tests/test_runtime_params_hydration.py:98:45: PLR2004 Magic value used in comparison, consider replacing `0.08` with a constant variable
    |
 97 |     # Verify custom values are used
 98 |     assert runtime.params['CAPITAL_CAP'] == 0.08
    |                                             ^^^^ PLR2004
 99 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.10
100 |     assert runtime.params['MAX_POSITION_SIZE'] == 2.5
    |

tests/test_runtime_params_hydration.py:99:51: PLR2004 Magic value used in comparison, consider replacing `0.10` with a constant variable
    |
 97 |     # Verify custom values are used
 98 |     assert runtime.params['CAPITAL_CAP'] == 0.08
 99 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.10
    |                                                   ^^^^ PLR2004
100 |     assert runtime.params['MAX_POSITION_SIZE'] == 2.5
101 |     assert runtime.params['KELLY_FRACTION'] == 0.7
    |

tests/test_runtime_params_hydration.py:100:51: PLR2004 Magic value used in comparison, consider replacing `2.5` with a constant variable
    |
 98 |     assert runtime.params['CAPITAL_CAP'] == 0.08
 99 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.10
100 |     assert runtime.params['MAX_POSITION_SIZE'] == 2.5
    |                                                   ^^^ PLR2004
101 |     assert runtime.params['KELLY_FRACTION'] == 0.7
102 |     assert runtime.params['BUY_THRESHOLD'] == 0.8
    |

tests/test_runtime_params_hydration.py:101:48: PLR2004 Magic value used in comparison, consider replacing `0.7` with a constant variable
    |
 99 |     assert runtime.params['DOLLAR_RISK_LIMIT'] == 0.10
100 |     assert runtime.params['MAX_POSITION_SIZE'] == 2.5
101 |     assert runtime.params['KELLY_FRACTION'] == 0.7
    |                                                ^^^ PLR2004
102 |     assert runtime.params['BUY_THRESHOLD'] == 0.8
103 |     assert runtime.params['CONF_THRESHOLD'] == 0.9
    |

tests/test_runtime_params_hydration.py:102:47: PLR2004 Magic value used in comparison, consider replacing `0.8` with a constant variable
    |
100 |     assert runtime.params['MAX_POSITION_SIZE'] == 2.5
101 |     assert runtime.params['KELLY_FRACTION'] == 0.7
102 |     assert runtime.params['BUY_THRESHOLD'] == 0.8
    |                                               ^^^ PLR2004
103 |     assert runtime.params['CONF_THRESHOLD'] == 0.9
    |

tests/test_runtime_params_hydration.py:103:48: PLR2004 Magic value used in comparison, consider replacing `0.9` with a constant variable
    |
101 |     assert runtime.params['KELLY_FRACTION'] == 0.7
102 |     assert runtime.params['BUY_THRESHOLD'] == 0.8
103 |     assert runtime.params['CONF_THRESHOLD'] == 0.9
    |                                                ^^^ PLR2004
    |

tests/test_runtime_params_hydration.py:124:52: PLR2004 Magic value used in comparison, consider replacing `0.08` with a constant variable
    |
123 |     # Test parameter access
124 |     assert _param(runtime, 'CAPITAL_CAP', 0.04) == 0.08
    |                                                    ^^^^ PLR2004
125 |     assert _param(runtime, 'MISSING_KEY', 999.0) == 999.0
    |

tests/test_runtime_params_hydration.py:125:53: PLR2004 Magic value used in comparison, consider replacing `999.0` with a constant variable
    |
123 |     # Test parameter access
124 |     assert _param(runtime, 'CAPITAL_CAP', 0.04) == 0.08
125 |     assert _param(runtime, 'MISSING_KEY', 999.0) == 999.0
    |                                                     ^^^^^ PLR2004
126 | 
127 |     # Test with runtime that has no params
    |

tests/test_runtime_params_hydration.py:133:57: PLR2004 Magic value used in comparison, consider replacing `0.08` with a constant variable
    |
132 |     mock_runtime = MockRuntime(cfg)
133 |     assert _param(mock_runtime, 'CAPITAL_CAP', 0.04) == 0.08  # Falls back to cfg
    |                                                         ^^^^ PLR2004
134 |     assert _param(mock_runtime, 'MISSING_KEY', 999.0) == 999.0  # Falls back to default
    |

tests/test_runtime_params_hydration.py:134:58: PLR2004 Magic value used in comparison, consider replacing `999.0` with a constant variable
    |
132 |     mock_runtime = MockRuntime(cfg)
133 |     assert _param(mock_runtime, 'CAPITAL_CAP', 0.04) == 0.08  # Falls back to cfg
134 |     assert _param(mock_runtime, 'MISSING_KEY', 999.0) == 999.0  # Falls back to default
    |                                                          ^^^^^ PLR2004
    |

tests/test_safe_submit_order.py:32:12: BLE001 Do not catch blind exception: `Exception`
   |
30 |         else:
31 |             assert order is None  # Acceptable in degraded mode
32 |     except Exception:
   |            ^^^^^^^^^ BLE001
33 |         # If imports fail due to missing dependencies, the test still passes
34 |         # as we've verified the core import structure works
   |

tests/test_safety_fallbacks.py:29:47: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
   |
27 |     settings = get_settings()
28 |     assert hasattr(settings, 'pretrade_lookback_days')
29 |     assert settings.pretrade_lookback_days == 120
   |                                               ^^^ PLR2004
   |

tests/test_scaling_and_indicators.py:9:52: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
  |
8 | def test_volatility_parity_zero_vol():
9 |     assert volatility_parity_position(0.0, 0.5) == 0.01
  |                                                    ^^^^ PLR2004
  |

tests/test_settings_config.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import pytest
 2 | | from pydantic import ValidationError
 3 | | 
 4 | | from ai_trading.config.settings import get_settings
 5 | | from ai_trading.core.bot_engine import _current_qty
 6 | | from ai_trading.main import logger
 7 | | from ai_trading.settings import Settings
 8 | | 
 9 | | 
10 | | def test_settings_defaults(monkeypatch):
   | |_^ I001
11 |       """Defaults should populate sane values."""  # AI-AGENT-REF
12 |       for key in [
   |
   = help: Organize imports

tests/test_settings_config.py:22:29: PLR2004 Magic value used in comparison, consider replacing `0.04` with a constant variable
   |
20 |     assert s.alpaca_data_feed == "iex"
21 |     assert s.alpaca_adjustment == "all"
22 |     assert s.capital_cap == 0.04
   |                             ^^^^ PLR2004
23 |     assert s.dollar_risk_limit == 0.05
   |

tests/test_settings_config.py:23:35: PLR2004 Magic value used in comparison, consider replacing `0.05` with a constant variable
   |
21 |     assert s.alpaca_adjustment == "all"
22 |     assert s.capital_cap == 0.04
23 |     assert s.dollar_risk_limit == 0.05
   |                                   ^^^^ PLR2004
   |

tests/test_short_selling_implementation.py:102:32: BLE001 Do not catch blind exception: `Exception`
    |
100 |                         try:
101 |                             result = engine.execute_order("AAPL", 10, "sell_short")
102 |                         except Exception:
    |                                ^^^^^^^^^ BLE001
103 |                             # Expected to reach this point, meaning it passed the initial validation
104 |                             pass
    |

tests/test_signals.py:11:1: E402 Module level import not at top of file
   |
 9 | np.random.seed(0)
10 | 
11 | from ai_trading.signals import GaussianHMM, detect_market_regime_hmm
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_signals.py:40:25: E741 Ambiguous variable name: `l`
   |
38 |     import types
39 |     pta = types.ModuleType('pandas_ta')
40 |     pta.vwap = lambda h,l,c,v: pd.Series((h+l+c)/3, index=sample_df.index)
   |                         ^ E741
41 |     pta.macd = lambda c, **k: {
42 |         'MACD_12_26_9': c * 0 + 1.0,
   |

tests/test_signals.py:45:23: E741 Ambiguous variable name: `l`
   |
43 |         'MACDs_12_26_9': c * 0 + 0.5,
44 |     }
45 |     pta.kc = lambda h,l,c,length=20: pd.DataFrame({0: c*0+1.0,1:c*0+2.0,2:c*0+3.0})
   |                       ^ E741
46 |     pta.mfi = lambda h,l,c,v,length=14: pd.Series(c*0+5.0, index=sample_df.index)
47 |     pta.adx = lambda h,l,c,length=14: {
   |

tests/test_signals.py:46:24: E741 Ambiguous variable name: `l`
   |
44 |     }
45 |     pta.kc = lambda h,l,c,length=20: pd.DataFrame({0: c*0+1.0,1:c*0+2.0,2:c*0+3.0})
46 |     pta.mfi = lambda h,l,c,v,length=14: pd.Series(c*0+5.0, index=sample_df.index)
   |                        ^ E741
47 |     pta.adx = lambda h,l,c,length=14: {
48 |         'ADX_14': pd.Series(c*0+7.0, index=sample_df.index),
   |

tests/test_signals.py:47:24: E741 Ambiguous variable name: `l`
   |
45 |     pta.kc = lambda h,l,c,length=20: pd.DataFrame({0: c*0+1.0,1:c*0+2.0,2:c*0+3.0})
46 |     pta.mfi = lambda h,l,c,v,length=14: pd.Series(c*0+5.0, index=sample_df.index)
47 |     pta.adx = lambda h,l,c,length=14: {
   |                        ^ E741
48 |         'ADX_14': pd.Series(c*0+7.0, index=sample_df.index),
49 |         'DMP_14': pd.Series(c*0+1.0, index=sample_df.index),
   |

tests/test_signals.py:64:39: PLR2004 Magic value used in comparison, consider replacing `3.0` with a constant variable
   |
62 |     assert out['vwap'].iloc[-1] == pytest.approx((sample_df['high']+sample_df['low']+sample_df['close']).iloc[-1]/3)
63 |     assert out['macd'].iloc[0] == 1.0
64 |     assert out['kc_upper'].iloc[0] == 3.0
   |                                       ^^^ PLR2004
65 |     assert out['mfi_14'].iloc[0] == 5.0
66 |     assert out['adx'].iloc[0] == 7.0
   |

tests/test_signals.py:65:37: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
63 |     assert out['macd'].iloc[0] == 1.0
64 |     assert out['kc_upper'].iloc[0] == 3.0
65 |     assert out['mfi_14'].iloc[0] == 5.0
   |                                     ^^^ PLR2004
66 |     assert out['adx'].iloc[0] == 7.0
   |

tests/test_signals.py:66:34: PLR2004 Magic value used in comparison, consider replacing `7.0` with a constant variable
   |
64 |     assert out['kc_upper'].iloc[0] == 3.0
65 |     assert out['mfi_14'].iloc[0] == 5.0
66 |     assert out['adx'].iloc[0] == 7.0
   |                                  ^^^ PLR2004
   |

tests/test_signals_multi_horizon.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import pandas as pd
 2 | | 
 3 | | from ai_trading.indicators import (
 4 | |     compute_atr,
 5 | |     compute_bollinger,
 6 | |     compute_ema,
 7 | |     compute_sma,
 8 | | )
 9 | | 
10 | | 
11 | | def test_multi_horizon_indicators():
   | |_^ I001
12 |       df = pd.DataFrame({
13 |           'close': [i for i in range(100)],
   |
   = help: Organize imports

tests/test_signals_multi_horizon.py:23:48: PLR2004 Magic value used in comparison, consider replacing `51` with a constant variable
   |
21 |     for p in [5, 20, 50, 200]:
22 |         assert f'EMA_{p}' in df.columns
23 |         assert f'SMA_{p}' in df.columns or p < 51
   |                                                ^^ PLR2004
24 |     assert 'UB' in df.columns and 'LB' in df.columns
   |

tests/test_signals_scoring.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import numpy as np
2 | | import pandas as pd
3 | | 
4 | | from ai_trading import signals
5 | | 
6 | | 
7 | | class _DummyProba:
  | |_^ I001
8 |       # AI-AGENT-REF: stub model with predict_proba
9 |       def predict_proba(self, X):
  |
  = help: Organize imports

tests/test_skip_logic.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import types
 2 | | 
 3 | | import pandas as pd
 4 | | 
 5 | | from ai_trading.core import bot_engine
 6 | | 
 7 | | 
 8 | | def test_skip_logic(monkeypatch, caplog):
   | |_^ I001
 9 |       state = bot_engine.BotState()
10 |       state.position_cache = {"MSFT": 10, "TSLA": -10}
   |
   = help: Organize imports

tests/test_slippage.py:10:23: PLR2004 Magic value used in comparison, consider replacing `0.5` with a constant variable
   |
 8 |     else:
 9 |         max_slip = df["slippage_cents"].abs().max()
10 |     assert max_slip < 0.5, "Slippage exceeded 50%, review execution quality"
   |                       ^^^ PLR2004
   |

tests/test_staleness_guard.py:41:16: BLE001 Do not catch blind exception: `Exception`
   |
39 |             _ensure_data_fresh(mock_fetcher, ["AAPL"], max_age_seconds=300)
40 |             success = True
41 |         except Exception:
   |                ^^^^^^^^^ BLE001
42 |             success = False
   |

tests/test_staleness_guard.py:191:20: BLE001 Do not catch blind exception: `Exception`
    |
189 |                 _ensure_data_fresh(mock_fetcher, ["AAPL"], max_age_seconds=300)
190 |                 success = True
191 |             except Exception:
    |                    ^^^^^^^^^ BLE001
192 |                 success = False
193 |             assert success, "Should handle both timezone-aware and naive timestamps"
    |

tests/test_strategies_module.py:62:1: E402 Module level import not at top of file
   |
60 | sys.modules["finnhub"] = finnhub_stub
61 | 
62 | from ai_trading.config import settings as settings_module
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
63 | from ai_trading.core.bot_engine import get_strategies
   |

tests/test_strategies_module.py:63:1: E402 Module level import not at top of file
   |
62 | from ai_trading.config import settings as settings_module
63 | from ai_trading.core.bot_engine import get_strategies
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_strategy_allocator_exit.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import sys
 2 | | from pathlib import Path
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading.strategies import TradeSignal
 7 | | 
 8 | | # Add the project root to sys.path to ensure we can import the real module
   | |_^ I001
 9 |   project_root = Path(__file__).resolve().parents[1]
10 |   if str(project_root) not in sys.path:
   |
   = help: Organize imports

tests/test_strategy_allocator_exit.py:35:12: E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
   |
33 |     # Cleanup: restore original module if it was there
34 |     if original_module and hasattr(original_module, 'StrategyAllocator'):
35 |         if original_module.StrategyAllocator != object:
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E721
36 |             sys.modules['strategy_allocator'] = original_module
   |

tests/test_strategy_allocator_smoke.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from pathlib import Path
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading import strategy_allocator  # AI-AGENT-REF: normalized import
 6 | | from ai_trading.strategies import TradeSignal
 7 | | 
 8 | | 
 9 | | def force_coverage(mod):
   | |_^ I001
10 |       # AI-AGENT-REF: Replaced _raise_dynamic_exec_disabled() with safe compile test for coverage
11 |       lines = Path(mod.__file__).read_text().splitlines()
   |
   = help: Organize imports

tests/test_strategy_allocator_smoke.py:26:53: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
25 |     # AI-AGENT-REF: Add defensive verification to ensure config is applied correctly
26 |     assert alloc.config.signal_confirmation_bars == 2, f"Expected signal_confirmation_bars=2, got {alloc.config.signal_confirmation_bars}"
   |                                                     ^ PLR2004
27 |     assert alloc.config.min_confidence == 0.0, f"Expected min_confidence=0.0, got {alloc.config.min_confidence}"
28 |     assert alloc.config.delta_threshold == 0.0, f"Expected delta_threshold=0.0, got {alloc.config.delta_threshold}"
   |

tests/test_strategy_components.py:90:12: BLE001 Do not catch blind exception: `Exception`
   |
88 |     except ImportError:
89 |         return True
90 |     except Exception:
   |            ^^^^^^^^^ BLE001
91 |         return False
   |

tests/test_strategy_components.py:135:12: BLE001 Do not catch blind exception: `Exception`
    |
133 |     except ImportError:
134 |         return True
135 |     except Exception:
    |            ^^^^^^^^^ BLE001
136 |         return False
    |

tests/test_strategy_components.py:185:12: BLE001 Do not catch blind exception: `Exception`
    |
183 |     except ImportError:
184 |         return True
185 |     except Exception:
    |            ^^^^^^^^^ BLE001
186 |         return False
    |

tests/test_strategy_components.py:235:12: BLE001 Do not catch blind exception: `Exception`
    |
233 |     except ImportError:
234 |         return True
235 |     except Exception:
    |            ^^^^^^^^^ BLE001
236 |         return False
    |

tests/test_strategy_components.py:276:12: BLE001 Do not catch blind exception: `Exception`
    |
274 |     except KeyboardInterrupt:
275 |         sys.exit(1)
276 |     except Exception:
    |            ^^^^^^^^^ BLE001
277 |         sys.exit(1)
    |

tests/test_stream_subscription_fix.py:111:24: BLE001 Do not catch blind exception: `Exception`
    |
109 |                         # Other AttributeErrors might be expected due to mocking
110 |                         success = True
111 |                 except Exception:
    |                        ^^^^^^^^^ BLE001
112 |                     # Other import errors are expected due to missing dependencies
113 |                     success = True
    |

tests/test_stubs_and_prices.py:19:40: PLR2004 Magic value used in comparison, consider replacing `101.5` with a constant variable
   |
18 |     df_alt = pd.DataFrame({"Close": [None, "nan", 101.5]})
19 |     assert get_latest_close(df_alt) == 101.5
   |                                        ^^^^^ PLR2004
20 | 
21 |     df_ok = pd.DataFrame({"close": [99.0, 100.0, float("nan")]})
   |

tests/test_stubs_and_prices.py:22:39: PLR2004 Magic value used in comparison, consider replacing `100.0` with a constant variable
   |
21 |     df_ok = pd.DataFrame({"close": [99.0, 100.0, float("nan")]})
22 |     assert get_latest_close(df_ok) == 100.0
   |                                       ^^^^^ PLR2004
   |

tests/test_talib_enforcement.py:158:27: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
    |
156 |         lines = content.strip().split("\n")
157 |         assert (
158 |             len(lines) == 3
    |                           ^ PLR2004
159 |         ), f"Expected 3 lines (header + 2 trades), got {len(lines)}"
    |

tests/test_talib_enforcement.py:171:29: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
    |
169 |             rows = list(csv.DictReader(f))
170 | 
171 |         assert len(rows) == 2
    |                             ^ PLR2004
172 |         assert rows[0]["symbol"] == "AAPL"
173 |         assert rows[1]["symbol"] == "MSFT"
    |

tests/test_timeutils.py:10:22: PLR2004 Magic value used in comparison, consider replacing `13` with a constant variable
   |
 8 |     # July 15, 2024 (DST)
 9 |     s, e = nyse_session_utc(date(2024, 7, 15))
10 |     assert s.hour == 13 and s.tzinfo == ZoneInfo("UTC")
   |                      ^^ PLR2004
11 |     assert e.hour == 20 and e.tzinfo == ZoneInfo("UTC")
   |

tests/test_timeutils.py:11:22: PLR2004 Magic value used in comparison, consider replacing `20` with a constant variable
   |
 9 |     s, e = nyse_session_utc(date(2024, 7, 15))
10 |     assert s.hour == 13 and s.tzinfo == ZoneInfo("UTC")
11 |     assert e.hour == 20 and e.tzinfo == ZoneInfo("UTC")
   |                      ^^ PLR2004
   |

tests/test_timeutils.py:17:22: PLR2004 Magic value used in comparison, consider replacing `14` with a constant variable
   |
15 |     # Jan 15, 2024 (Standard Time)
16 |     s, e = nyse_session_utc(date(2024, 1, 15))
17 |     assert s.hour == 14 and e.hour == 21  # 14:30–21:00Z
   |                      ^^ PLR2004
   |

tests/test_timeutils.py:17:39: PLR2004 Magic value used in comparison, consider replacing `21` with a constant variable
   |
15 |     # Jan 15, 2024 (Standard Time)
16 |     s, e = nyse_session_utc(date(2024, 1, 15))
17 |     assert s.hour == 14 and e.hour == 21  # 14:30–21:00Z
   |                                       ^^ PLR2004
   |

tests/test_trade_logic.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import pandas as pd
 2 | | 
 3 | | from ai_trading.trade_logic import (
 4 | |     compute_order_price,
 5 | |     extract_price,
 6 | |     should_enter_trade,
 7 | | )
 8 | | 
 9 | | 
10 | | def test_should_enter_trade_basic():
   | |_^ I001
11 |       assert should_enter_trade(
12 |           [100, 105], {"signal_strength": 0.8}, {"max_risk": 0.02}
   |
   = help: Organize imports

tests/test_trade_logic.py:18:33: PLR2004 Magic value used in comparison, consider replacing `2.0` with a constant variable
   |
16 | def test_extract_price_generic():
17 |     df = pd.DataFrame({"close": [1.0, 2.0]})
18 |     assert extract_price(df) == 2.0
   |                                 ^^^ PLR2004
19 |     assert extract_price({"close": 3.0}) == 3.0
20 |     assert extract_price([4.0, 5.0]) == 5.0
   |

tests/test_trade_logic.py:19:45: PLR2004 Magic value used in comparison, consider replacing `3.0` with a constant variable
   |
17 |     df = pd.DataFrame({"close": [1.0, 2.0]})
18 |     assert extract_price(df) == 2.0
19 |     assert extract_price({"close": 3.0}) == 3.0
   |                                             ^^^ PLR2004
20 |     assert extract_price([4.0, 5.0]) == 5.0
   |

tests/test_trade_logic.py:20:41: PLR2004 Magic value used in comparison, consider replacing `5.0` with a constant variable
   |
18 |     assert extract_price(df) == 2.0
19 |     assert extract_price({"close": 3.0}) == 3.0
20 |     assert extract_price([4.0, 5.0]) == 5.0
   |                                         ^^^ PLR2004
   |

tests/test_trading_parameter_validation.py:46:9: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
44 |     param_definitions = {}
45 |     for i, line in enumerate(source.split('\n'), 1):
46 |         line = line.strip()
   |         ^^^^ PLW2901
47 |         for param in referenced_params:
48 |             if line.startswith(f'{param} =') and i < validate_call_line:
   |

tests/test_trigger_meta_learning_conversion.py:59:1: E402 Module level import not at top of file
   |
57 | sys.modules['config'] = MockConfig
58 | 
59 | from ai_trading import meta_learning
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ E402
   |

tests/test_universe_csv.py:1:1: I001 [*] Import block is un-sorted or un-formatted
  |
1 | / import pandas as pd
2 | | 
3 | | from ai_trading.data.universe import load_universe, locate_tickers_csv
4 | | 
5 | | 
6 | | def test_env_overrides_packaged(monkeypatch, tmp_path):
  | |_^ I001
7 |       csv = tmp_path / "tick.csv"
8 |       pd.DataFrame({"symbol": ["MSFT", "NVDA", "META"]}).to_csv(csv, index=False)
  |
  = help: Organize imports

tests/test_universe_csv.py:21:23: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
19 |     assert p and p.endswith("ai_trading/data/tickers.csv")
20 |     uni = load_universe()
21 |     assert len(uni) > 3  # S&P-100 default
   |                       ^ PLR2004
   |

tests/test_utc_timefmt.py:8:1: I001 [*] Import block is un-sorted or un-formatted
   |
 6 |   """
 7 |   
 8 | / from datetime import UTC, datetime, timedelta, timezone
 9 | | 
10 | | import pytest
11 | | 
12 | | from ai_trading.utils.timefmt import (
13 | |     ensure_utc_format,
14 | |     format_datetime_utc,
15 | |     parse_iso_utc,
16 | |     utc_now_iso,
17 | | )
18 | | 
19 | | 
20 | | class TestUTCTimestampFormatting:
   | |_^ I001
21 |       """Test UTC timestamp formatting functions."""
   |
   = help: Organize imports

tests/test_utc_timefmt.py:58:14: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
   |
56 |     def test_format_datetime_utc_with_naive_datetime(self):
57 |         """Test formatting naive datetime (assumed UTC)."""
58 |         dt = datetime(2024, 1, 1, 12, 0, 0)  # No timezone
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
59 |         result = format_datetime_utc(dt)
   |
   = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_utc_timefmt.py:85:54: PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   |
83 |         parsed = parse_iso_utc(result)
84 |         now = datetime.now(UTC)
85 |         assert abs((now - parsed).total_seconds()) < 5  # Within 5 seconds
   |                                                      ^ PLR2004
86 | 
87 |     def test_parse_iso_utc_with_z_suffix(self):
   |

tests/test_utc_timefmt.py:93:31: PLR2004 Magic value used in comparison, consider replacing `2024` with a constant variable
   |
92 |         assert result is not None
93 |         assert result.year == 2024
   |                               ^^^^ PLR2004
94 |         assert result.month == 1
95 |         assert result.day == 1
   |

tests/test_utc_timefmt.py:96:31: PLR2004 Magic value used in comparison, consider replacing `12` with a constant variable
   |
94 |         assert result.month == 1
95 |         assert result.day == 1
96 |         assert result.hour == 12
   |                               ^^ PLR2004
97 |         assert result.minute == 0
98 |         assert result.second == 0
   |

tests/test_utc_timefmt.py:107:31: PLR2004 Magic value used in comparison, consider replacing `2024` with a constant variable
    |
106 |         assert result is not None
107 |         assert result.year == 2024
    |                               ^^^^ PLR2004
108 |         assert result.tzinfo == UTC
    |

tests/test_utc_timefmt.py:172:20: DTZ001 `datetime.datetime()` called without a `tzinfo` argument
    |
170 |         assert formatted_utc.count('Z') == 1
171 | 
172 |         dt_naive = datetime(2024, 1, 1, 12, 0, 0)
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DTZ001
173 |         formatted_naive = format_datetime_utc(dt_naive)
174 |         assert 'ZZ' not in formatted_naive
    |
    = help: Pass a `datetime.timezone` object to the `tzinfo` parameter

tests/test_utc_timefmt.py:194:38: PLR2004 Magic value used in comparison, consider replacing `123456` with a constant variable
    |
192 |         # Should be parseable
193 |         parsed = parse_iso_utc(formatted)
194 |         assert parsed.microsecond == 123456
    |                                      ^^^^^^ PLR2004
    |

tests/test_utils_sleep_shadowing.py:21:30: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
19 |     utils.sleep(0)
20 | 
21 |     assert slept["count"] == 3
   |                              ^ PLR2004
   |

tests/test_validate_logging_setup_single_handler.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / from __future__ import annotations
 2 | | 
 3 | | import logging
 4 | | 
 5 | | import pytest
 6 | | 
 7 | | import ai_trading.logging as L
 8 | | 
 9 | | 
10 | | def test_validate_logging_setup_single_handler():
   | |_^ I001
11 |       """Ensure validate_logging_setup() deduplicates handlers."""
12 |       # Use a dedicated logger name to avoid global handlers
   |
   = help: Organize imports

tests/test_validate_logging_setup_single_handler.py:22:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
20 |     logger.addHandler(logging.StreamHandler())
21 |     pre_count = sum(isinstance(h, logging.StreamHandler) for h in logger.handlers)
22 |     assert pre_count == 2, "Fixture assumption failed: expected two handlers"
   |                         ^ PLR2004
23 | 
24 |     if hasattr(L, "dedupe_stream_handlers"):
   |

tests/test_workers.py:17:28: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
15 | def test_submit_and_map_background():
16 |     fut = workers.submit_background("beta", lambda x: x + 1, 1)
17 |     assert fut.result() == 2
   |                            ^ PLR2004
18 |     res = workers.map_background("gamma", lambda x: x * 2, [1, 2, 3])
19 |     assert res == [2, 4, 6]
   |

tests/unit/test_health_check.py:37:41: PLR2004 Magic value used in comparison, consider replacing `30` with a constant variable
   |
35 |     ctx = types.SimpleNamespace()
36 |     ctx.min_rows = 50
37 |     assert resolve_min_rows(30, ctx) == 30, "Explicit parameter should take precedence"
   |                                         ^^ PLR2004
38 | 
39 |     # Test ctx.min_rows is used when parameter is None
   |

tests/unit/test_health_check.py:40:43: PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   |
39 |     # Test ctx.min_rows is used when parameter is None
40 |     assert resolve_min_rows(None, ctx) == 50, "Should use ctx.min_rows when parameter is None"
   |                                           ^^ PLR2004
41 | 
42 |     # Test default is used when both are missing
   |

tests/unit/test_health_check.py:44:51: PLR2004 Magic value used in comparison, consider replacing `120` with a constant variable
   |
42 |     # Test default is used when both are missing
43 |     ctx_no_attr = types.SimpleNamespace()
44 |     assert resolve_min_rows(None, ctx_no_attr) == 120, "Should use default when ctx.min_rows missing"
   |                                                   ^^^ PLR2004
   |

tests/unit/test_retry.py:3:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 |   """Unit tests for retry_call utility."""
 2 |   
 3 | / from __future__ import annotations
 4 | | 
 5 | | import time
 6 | | 
 7 | | import pytest
 8 | | 
 9 | | from ai_trading.utils.retry import retry_call
10 | | 
11 | | 
12 | | class _Flaky:
   | |_^ I001
13 |       def __init__(self) -> None:
14 |           self.calls = 0
   |
   = help: Organize imports

tests/unit/test_retry.py:18:25: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
16 |     def __call__(self) -> str:
17 |         self.calls += 1
18 |         if self.calls < 3:
   |                         ^ PLR2004
19 |             raise RuntimeError("fail")
20 |         return "ok"
   |

tests/unit/test_retry.py:37:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
35 |     result = retry_call(flaky, exceptions=(RuntimeError,), retries=2)
36 |     assert result == "ok"
37 |     assert flaky.calls == 2
   |                           ^ PLR2004
   |

tests/unit/test_retry.py:45:29: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
43 |     with pytest.raises(ValueError):
44 |         retry_call(failing, exceptions=(ValueError,), retries=2)
45 |     assert failing.calls == 3
   |                             ^ PLR2004
   |

tests/unit/test_retry.py:56:25: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
54 |     def func() -> str:
55 |         calls["n"] += 1
56 |         if calls["n"] < 2:
   |                         ^ PLR2004
57 |             raise RuntimeError("boom")
58 |         return "done"
   |

tests/unit/test_retry.py:64:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
62 |     elapsed = time.perf_counter() - start
63 |     assert result == "done"
64 |     assert calls["n"] == 2
   |                          ^ PLR2004
65 |     assert elapsed < 0.01
   |

tests/unit/test_retry.py:65:22: PLR2004 Magic value used in comparison, consider replacing `0.01` with a constant variable
   |
63 |     assert result == "done"
64 |     assert calls["n"] == 2
65 |     assert elapsed < 0.01
   |                      ^^^^ PLR2004
   |

tests/utils/test_http_retry.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import logging
 2 | | from types import SimpleNamespace
 3 | | 
 4 | | import pytest
 5 | | 
 6 | | from ai_trading.exc import RequestException
 7 | | from ai_trading.utils import http
 8 | | 
 9 | | 
10 | | def test_get_retries_and_logs(monkeypatch: pytest.MonkeyPatch, caplog: pytest.LogCaptureFixture) -> None:
   | |_^ I001
11 |       calls = {"n": 0}
   |
   = help: Organize imports

tests/utils/test_http_retry.py:15:26: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
13 |     def fake_request(self, method, url, **kwargs):  # type: ignore[override]
14 |         calls["n"] += 1
15 |         if calls["n"] <= 2:
   |                          ^ PLR2004
16 |             raise RequestException("boom")
17 |         return SimpleNamespace(status_code=200, content=b"ok")
   |

tests/utils/test_http_retry.py:22:32: PLR2004 Magic value used in comparison, consider replacing `200` with a constant variable
   |
20 |     with caplog.at_level(logging.DEBUG):
21 |         resp = http.get("http://example.com")
22 |     assert resp.status_code == 200
   |                                ^^^ PLR2004
23 |     warnings = [r for r in caplog.records if r.levelno == logging.WARNING]
24 |     debug = [r for r in caplog.records if r.levelno == logging.DEBUG]
   |

tests/utils/test_retry.py:1:1: I001 [*] Import block is un-sorted or un-formatted
   |
 1 | / import time
 2 | | 
 3 | | import pytest
 4 | | 
 5 | | from ai_trading.utils.retry import retry_call
 6 | | 
 7 | | 
 8 | | class Flaky:
   | |_^ I001
 9 |       def __init__(self, fail_times: int) -> None:
10 |           self.calls = 0
   |
   = help: Organize imports

tests/utils/test_retry.py:30:24: PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   |
28 |     fn = Flaky(2)
29 |     assert retry_call(fn, exceptions=(TimeoutError,), retries=3) == "ok"
30 |     assert fn.calls == 3
   |                        ^ PLR2004
31 |     assert len(sleeps) == 2
   |

tests/utils/test_retry.py:31:27: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
29 |     assert retry_call(fn, exceptions=(TimeoutError,), retries=3) == "ok"
30 |     assert fn.calls == 3
31 |     assert len(sleeps) == 2
   |                           ^ PLR2004
   |

tests/utils/test_retry.py:46:26: PLR2004 Magic value used in comparison, consider replacing `0.3` with a constant variable
   |
44 |     with pytest.raises(TimeoutError):
45 |         retry_call(fn, exceptions=(TimeoutError,), retries=4, backoff=0.1, max_backoff=0.3, jitter=0)
46 |     assert sleeps[-1] <= 0.3
   |                          ^^^ PLR2004
47 |     assert sleeps == sorted(sleeps)
   |

tests/watchdog_ext.py:38:12: BLE001 Do not catch blind exception: `Exception`
   |
36 |     try:
37 |         import requests  # noqa: F401
38 |     except Exception:
   |            ^^^^^^^^^ BLE001
39 |         return None, None
40 |     Session = getattr(sys.modules["requests"], "Session", None)
   |

tests/watchdog_ext.py:45:16: BLE001 Do not catch blind exception: `Exception`
   |
43 |             sess_mod = importlib.import_module("requests.sessions")
44 |             Session = getattr(sess_mod, "Session", None)
45 |         except Exception:  # pragma: no cover - defensive
   |                ^^^^^^^^^ BLE001
46 |             Session = None
47 |     return Session, sys.modules.get("requests")
   |

tests/watchdog_ext.py:91:16: BLE001 Do not catch blind exception: `Exception`
   |
89 |         try:
90 |             ip = socket.gethostbyname(host)
91 |         except Exception:
   |                ^^^^^^^^^ BLE001
92 |             ip = str(host)
93 |         if ip.startswith("127.") or host in ("::1", "localhost"):
   |

tools/ci/full_cleanup.py:58:33: E702 Multiple statements on one line (semicolon)
   |
56 |         i += 1
57 |     if i < len(lines) and lines[i].lstrip().startswith(('"""',"'''")):
58 |         q = lines[i].strip()[:3]; i += 1
   |                                 ^ E702
59 |         while i < len(lines) and q not in lines[i]: i += 1
60 |         if i < len(lines): i += 1
   |

tools/ci/full_cleanup.py:59:51: E701 Multiple statements on one line (colon)
   |
57 |     if i < len(lines) and lines[i].lstrip().startswith(('"""',"'''")):
58 |         q = lines[i].strip()[:3]; i += 1
59 |         while i < len(lines) and q not in lines[i]: i += 1
   |                                                   ^ E701
60 |         if i < len(lines): i += 1
61 |     while i < len(lines) and lines[i].lstrip().startswith(("import ","from ")):
   |

tools/ci/full_cleanup.py:60:26: E701 Multiple statements on one line (colon)
   |
58 |         q = lines[i].strip()[:3]; i += 1
59 |         while i < len(lines) and q not in lines[i]: i += 1
60 |         if i < len(lines): i += 1
   |                          ^ E701
61 |     while i < len(lines) and lines[i].lstrip().startswith(("import ","from ")):
62 |         i += 1
   |

tools/ci/full_cleanup.py:69:17: E701 Multiple statements on one line (colon)
   |
67 | def migrate_config_callsites(text: str):
68 |     names = set(m.group(1) for m in UPPER.finditer(text))
69 |     if not names: return text, set()
   |                 ^ E701
70 |     new = UPPER.sub(lambda m: f"S.{m.group(1).lower()}", text)
71 |     if "from ai_trading.config import get_settings" not in new:
   |

tools/ci/gen_audit_artifacts.py:32:16: BLE001 Do not catch blind exception: `Exception`
   |
30 |         try:
31 |             text = p.read_text(encoding="utf-8", errors="ignore")
32 |         except Exception:
   |                ^^^^^^^^^ BLE001
33 |             continue
34 |         for name, rx in PATTERNS.items():
   |

tools/ci/gen_audit_artifacts.py:50:16: BLE001 Do not catch blind exception: `Exception`
   |
48 |         try:
49 |             compile(p.read_text(encoding="utf-8", errors="ignore"), srel, "exec")
50 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
51 |             errs.append({"file": srel, "error": repr(e)})
52 |     return errs
   |

tools/ci/guard_ast.py:67:16: BLE001 Do not catch blind exception: `Exception`
   |
65 |         try:
66 |             mod = cst.parse_module(py.read_text(encoding="utf-8"))
67 |         except Exception:
   |                ^^^^^^^^^ BLE001
68 |             continue
69 |         mod.visit(Visitor(py))
   |

tools/ci/list_shims.py:23:16: BLE001 Do not catch blind exception: `Exception`
   |
21 |         try:
22 |             text = p.read_text(encoding="utf-8", errors="ignore")
23 |         except Exception:
   |                ^^^^^^^^^ BLE001
24 |             continue
   |

tools/ci/list_targets.py:30:12: BLE001 Do not catch blind exception: `Exception`
   |
28 |     try:
29 |         text = p.read_text(encoding="utf-8")
30 |     except Exception:
   |            ^^^^^^^^^ BLE001
31 |         continue
32 |     lines = text.splitlines()
   |

tools/ci/sweep_tests_tools.py:50:33: E702 Multiple statements on one line (semicolon)
   |
48 |         i += 1
49 |     if i < len(lines) and lines[i].lstrip().startswith(('"""',"'''")):
50 |         q = lines[i].strip()[:3]; i += 1
   |                                 ^ E702
51 |         while i < len(lines) and q not in lines[i]: i += 1
52 |         if i < len(lines): i += 1
   |

tools/ci/sweep_tests_tools.py:51:51: E701 Multiple statements on one line (colon)
   |
49 |     if i < len(lines) and lines[i].lstrip().startswith(('"""',"'''")):
50 |         q = lines[i].strip()[:3]; i += 1
51 |         while i < len(lines) and q not in lines[i]: i += 1
   |                                                   ^ E701
52 |         if i < len(lines): i += 1
53 |     while i < len(lines) and lines[i].lstrip().startswith(("import ","from ")):
   |

tools/ci/sweep_tests_tools.py:52:26: E701 Multiple statements on one line (colon)
   |
50 |         q = lines[i].strip()[:3]; i += 1
51 |         while i < len(lines) and q not in lines[i]: i += 1
52 |         if i < len(lines): i += 1
   |                          ^ E701
53 |     while i < len(lines) and lines[i].lstrip().startswith(("import ","from ")):
54 |         i += 1
   |

tools/ci/sweep_tests_tools.py:78:26: E702 Multiple statements on one line (semicolon)
   |
76 |         txt = strip_mock_classes(txt)
77 |         if txt != txt0:
78 |             write(p, txt); changed += 1
   |                          ^ E702
   |

tools/ci/unwrap_import_guards.py:118:16: BLE001 Do not catch blind exception: `Exception`
    |
116 |                     continue
117 |             files += 1
118 |         except Exception:
    |                ^^^^^^^^^ BLE001
119 |             continue
    |

tools/codemod_none_is.py:33:16: BLE001 Do not catch blind exception: `Exception`
   |
31 |                 p.write_text(out.code, encoding="utf-8")
32 |                 print(f"REWROTE {p}")
33 |         except Exception as e:
   |                ^^^^^^^^^ BLE001
34 |             print(f"SKIP {p}: {e}", file=sys.stderr)
   |

tools/codemods/codemod_io_safety_yaml.py:46:21: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
44 |                 # Simple case: single line call
45 |                 if ")" in line:
46 |                     line = re.sub(
   |                     ^^^^ PLW2901
47 |                         r"(requests\.(get|post|put|delete|patch)\s*\([^)]*)\)",
48 |                         r"\1, timeout=30)",
   |

tools/codemods/codemod_io_safety_yaml.py:53:21: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
51 |                 # Handle case where call spans multiple lines - add to the line with the opening paren
52 |                 else:
53 |                     line = re.sub(
   |                     ^^^^ PLW2901
54 |                         r"(requests\.(get|post|put|delete|patch)\s*\()",
55 |                         r"\1timeout=30, ",
   |

tools/codemods/codemod_io_safety_yaml.py:87:21: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
85 |             if not has_timeout:
86 |                 if ")" in line:
87 |                     line = re.sub(
   |                     ^^^^ PLW2901
88 |                         r"(subprocess\.(run|Popen|call|check_call|check_output)\s*\([^)]*)\)",
89 |                         r"\1, timeout=30)",
   |

tools/codemods/codemod_io_safety_yaml.py:93:21: PLW2901 `for` loop variable `line` overwritten by assignment target
   |
91 |                     )
92 |                 else:
93 |                     line = re.sub(
   |                     ^^^^ PLW2901
94 |                         r"(subprocess\.(run|Popen|call|check_call|check_output)\s*\()",
95 |                         r"\1timeout=30, ",
   |

tools/codemods/codemod_io_safety_yaml.py:181:13: PLW2901 `for` loop variable `line` overwritten by assignment target
    |
179 |         # Replace time.sleep in async functions
180 |         if in_async_function and "time.sleep(" in line:
181 |             line = line.replace("time.sleep(", "await asyncio.sleep(")
    |             ^^^^ PLW2901
182 | 
183 |             # Add asyncio import if needed
    |

tools/codemods/codemod_io_safety_yaml.py:224:12: BLE001 Do not catch blind exception: `Exception`
    |
222 |             return True
223 | 
224 |     except Exception:
    |            ^^^^^^^^^ BLE001
225 |         return False
    |

tools/codemods/codemod_logging_time.py:125:12: BLE001 Do not catch blind exception: `Exception`
    |
123 |             return True
124 | 
125 |     except Exception:
    |            ^^^^^^^^^ BLE001
126 |         return False
    |

tools/codemods/none_comparisons.py:19:17: PLW2901 `for` loop variable `op` overwritten by assignment target
   |
17 |         for op, comp in updated.comparators:
18 |             if isinstance(op, cst.Equal) and m.matches(comp, m.Name("None")):
19 |                 op = cst.Is()
   |                 ^^ PLW2901
20 |                 changed = True
21 |             elif isinstance(op, cst.NotEqual) and m.matches(comp, m.Name("None")):
   |

tools/codemods/none_comparisons.py:22:17: PLW2901 `for` loop variable `op` overwritten by assignment target
   |
20 |                 changed = True
21 |             elif isinstance(op, cst.NotEqual) and m.matches(comp, m.Name("None")):
22 |                 op = cst.IsNot()
   |                 ^^ PLW2901
23 |                 changed = True
24 |             comparators.append((op, comp))
   |

tools/codemods/remove_import_guards.py:10:9: PLR0911 Too many return statements (7 > 6)
   |
 9 | class StripImportGuards(cst.CSTTransformer):
10 |     def leave_Try(self, original: cst.Try, updated: cst.Try) -> cst.BaseStatement | cst.FlattenSentinel[cst.BaseStatement]:
   |         ^^^^^^^^^ PLR0911
11 |         # If the try-body is ONLY import statements and except ImportError exists,
12 |         # replace the whole try/except with just the import statements.
   |

tools/codemods/remove_import_guards.py:56:12: BLE001 Do not catch blind exception: `Exception`
   |
54 |             p.write_text(new.code, encoding="utf-8")
55 |             return True
56 |     except Exception:
   |            ^^^^^^^^^ BLE001
57 |         pass
58 |     return False
   |

tools/codemods/replace_eval_exec.py:46:16: BLE001 Do not catch blind exception: `Exception`
   |
44 |                 p.write_text(new, encoding="utf-8")
45 |                 changed_files += 1
46 |         except Exception:
   |                ^^^^^^^^^ BLE001
47 |             pass
   |

tools/codemods/strip_config_magic.py:47:16: BLE001 Do not catch blind exception: `Exception`
   |
45 |             if new.code != src:
46 |                 CFG_INIT.write_text(new.code, encoding="utf-8")
47 |         except Exception:
   |                ^^^^^^^^^ BLE001
48 |             pass
   |

tools/codemods/strip_config_magic.py:61:16: BLE001 Do not catch blind exception: `Exception`
   |
59 |             if new.code != src:
60 |                 management.write_text(new.code, encoding="utf-8")
61 |         except Exception:
   |                ^^^^^^^^^ BLE001
62 |             pass
   |

tools/codemods/sweep_fix.py:13:55: PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   |
11 | PKG = pathlib.Path("ai_trading")
12 | REQ_TIMEOUT = int(sys.argv[1]) if len(sys.argv) > 1 else 10
13 | SUBPROC_TIMEOUT = int(sys.argv[2]) if len(sys.argv) > 2 else 60
   |                                                       ^ PLR2004
   |

tools/fix_import_time.py:31:19: E701 Multiple statements on one line (colon)
   |
30 | def ensure_getter_imports(lines, getters):
31 |     if not getters: return False
   |                   ^ E701
32 |     imp_line = IMPORT_GETTERS_TMPL.format(", ".join(sorted(getters)))
33 |     joined = "".join(lines)
   |

tools/fix_import_time.py:34:26: E701 Multiple statements on one line (colon)
   |
32 |     imp_line = IMPORT_GETTERS_TMPL.format(", ".join(sorted(getters)))
33 |     joined = "".join(lines)
34 |     if imp_line in joined: return False
   |                          ^ E701
35 |     idx = 0
36 |     while idx < len(lines) and lines[idx].startswith(("#!", "# -*-", "from __future__")):
   |

tools/fix_import_time.py:50:17: E701 Multiple statements on one line (colon)
   |
48 |     while True:
49 |         m = func.search(j, pos)
50 |         if not m: break
   |                 ^ E701
51 |         start = m.end()
52 |         head_line = j[:m.start()].count("\n")
   |

tools/fix_import_time.py:104:53: E701 Multiple statements on one line (colon)
    |
102 |     changed = 0
103 |     for py in ROOT.rglob("*.py"):
104 |         if any(part in EXCLUDE for part in py.parts): continue
    |                                                     ^ E701
105 |         if py.parts[0] not in {"ai_trading", "tests"}: continue
106 |         if py.name == "settings.py" and py.parts[-2] == "ai_trading": continue
    |

tools/fix_import_time.py:105:54: E701 Multiple statements on one line (colon)
    |
103 |     for py in ROOT.rglob("*.py"):
104 |         if any(part in EXCLUDE for part in py.parts): continue
105 |         if py.parts[0] not in {"ai_trading", "tests"}: continue
    |                                                      ^ E701
106 |         if py.name == "settings.py" and py.parts[-2] == "ai_trading": continue
107 |         try:
    |

tools/fix_import_time.py:106:69: E701 Multiple statements on one line (colon)
    |
104 |         if any(part in EXCLUDE for part in py.parts): continue
105 |         if py.parts[0] not in {"ai_trading", "tests"}: continue
106 |         if py.name == "settings.py" and py.parts[-2] == "ai_trading": continue
    |                                                                     ^ E701
107 |         try:
108 |             if patch_file(py): changed += 1
    |

tools/fix_import_time.py:108:30: E701 Multiple statements on one line (colon)
    |
106 |         if py.name == "settings.py" and py.parts[-2] == "ai_trading": continue
107 |         try:
108 |             if patch_file(py): changed += 1
    |                              ^ E701
109 |         except Exception:
110 |             pass
    |

tools/fix_import_time.py:109:16: BLE001 Do not catch blind exception: `Exception`
    |
107 |         try:
108 |             if patch_file(py): changed += 1
109 |         except Exception:
    |                ^^^^^^^^^ BLE001
110 |             pass
    |

tools/package_health.py:16:12: BLE001 Do not catch blind exception: `Exception`
   |
14 |         import psutil  # noqa: F401
15 |         return True
16 |     except Exception:
   |            ^^^^^^^^^ BLE001
17 |         return False
   |

tools/package_health.py:26:12: BLE001 Do not catch blind exception: `Exception`
   |
24 |         getattr(alpaca_trade_api, "__version__", "unknown")
25 |         return True
26 |     except Exception:
   |            ^^^^^^^^^ BLE001
27 |         return False
   |

tools/package_health.py:37:12: BLE001 Do not catch blind exception: `Exception`
   |
35 |         assert PerformanceBasedAllocator is not None
36 |         return True
37 |     except Exception:
   |            ^^^^^^^^^ BLE001
38 |         return False
   |

tools/package_health.py:46:12: BLE001 Do not catch blind exception: `Exception`
   |
44 |     try:
45 |         import pytest_asyncio  # type: ignore  # noqa: F401
46 |     except Exception:
   |            ^^^^^^^^^ BLE001
47 |         ok = False
48 |     try:
   |

tools/package_health.py:50:12: BLE001 Do not catch blind exception: `Exception`
   |
48 |     try:
49 |         import anyio  # type: ignore  # noqa: F401
50 |     except Exception:
   |            ^^^^^^^^^ BLE001
51 |         ok = False
52 |     return ok
   |

tools/package_health.py:63:12: BLE001 Do not catch blind exception: `Exception`
   |
61 |     try:
62 |         import joblib  # noqa
63 |     except Exception:
   |            ^^^^^^^^^ BLE001
64 |         pass
   |

tools/package_health.py:80:12: BLE001 Do not catch blind exception: `Exception`
   |
78 |     try:
79 |         import joblib  # noqa: F401
80 |     except Exception:
   |            ^^^^^^^^^ BLE001
81 |         return False
82 |     return True
   |

tools/ruff_histogram.py:8:9: E701 Multiple statements on one line (colon)
   |
 6 | for line in sys.stdin:
 7 |     m = re.search(r"\s([A-Z]{1,3}\d{3})\s", line)
 8 |     if m: counts[m.group(1)] += 1
   |         ^ E701
 9 | for code, n in counts.most_common(50):
10 |     print(f"{code}\t{n}")
   |

tools/scan_import_time.py:20:40: E701 Multiple statements on one line (colon)
   |
18 |     txt = p.read_text(encoding="utf-8", errors="ignore")
19 |     hits = []
20 |     if PATS["MODULE_CONST"].search(txt): hits.append("MODULE_CONST_FROM_SETTINGS")
   |                                        ^ E701
21 |     if PATS["MODULE_CFG"].search(txt):   hits.append("MODULE_CFG_FROM_SETTINGS")
22 |     if PATS["DIRECT_ATTR"].search(txt):  hits.append("DIRECT_SETTINGS_ATTR")
   |

tools/scan_import_time.py:21:38: E701 Multiple statements on one line (colon)
   |
19 |     hits = []
20 |     if PATS["MODULE_CONST"].search(txt): hits.append("MODULE_CONST_FROM_SETTINGS")
21 |     if PATS["MODULE_CFG"].search(txt):   hits.append("MODULE_CFG_FROM_SETTINGS")
   |                                      ^ E701
22 |     if PATS["DIRECT_ATTR"].search(txt):  hits.append("DIRECT_SETTINGS_ATTR")
23 |     if PATS["BARE_CALL"].search(txt):    hits.append("BARE_GET_SETTINGS")
   |

tools/scan_import_time.py:22:39: E701 Multiple statements on one line (colon)
   |
20 |     if PATS["MODULE_CONST"].search(txt): hits.append("MODULE_CONST_FROM_SETTINGS")
21 |     if PATS["MODULE_CFG"].search(txt):   hits.append("MODULE_CFG_FROM_SETTINGS")
22 |     if PATS["DIRECT_ATTR"].search(txt):  hits.append("DIRECT_SETTINGS_ATTR")
   |                                       ^ E701
23 |     if PATS["BARE_CALL"].search(txt):    hits.append("BARE_GET_SETTINGS")
24 |     return hits
   |

tools/scan_import_time.py:23:37: E701 Multiple statements on one line (colon)
   |
21 |     if PATS["MODULE_CFG"].search(txt):   hits.append("MODULE_CFG_FROM_SETTINGS")
22 |     if PATS["DIRECT_ATTR"].search(txt):  hits.append("DIRECT_SETTINGS_ATTR")
23 |     if PATS["BARE_CALL"].search(txt):    hits.append("BARE_GET_SETTINGS")
   |                                     ^ E701
24 |     return hits
   |

tools/scan_import_time.py:29:53: E701 Multiple statements on one line (colon)
   |
27 |     any_hits = False
28 |     for py in ROOT.rglob("*.py"):
29 |         if any(part in EXCLUDE for part in py.parts): continue
   |                                                     ^ E701
30 |         if py.parts[0] not in INCLUDE: continue
31 |         hits = scan_file(py)
   |

tools/scan_import_time.py:30:38: E701 Multiple statements on one line (colon)
   |
28 |     for py in ROOT.rglob("*.py"):
29 |         if any(part in EXCLUDE for part in py.parts): continue
30 |         if py.parts[0] not in INCLUDE: continue
   |                                      ^ E701
31 |         hits = scan_file(py)
32 |         if hits:
   |

Found 2303 errors.
[*] 95 fixable with the `--fix` option (13 hidden fixes can be enabled with the `--unsafe-fixes` option).
